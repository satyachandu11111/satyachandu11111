require.config({"config": {
        "jsbuild":{"mage/backend/floating-header.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery/ui'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.floatingHeader', {\n        options: {\n            placeholderAttrs: {\n                'class': 'page-actions-placeholder'\n            },\n            fixedClass: '_fixed',\n            hiddenClass: '_hidden',\n            title: '.page-title-wrapper .page-title',\n            pageMainActions: '.page-main-actions',\n            contains: '[data-role=modal]'\n        },\n\n        /**\n         * Widget initialization\n         * @private\n         */\n        _create: function () {\n            var title = $(this.options.title).text(),\n                wrapped = this.element.find('.page-actions-buttons').children();\n\n            if (this.element.parents(this.options.contains).length) {\n                return this;\n            }\n\n            this._setVars();\n            this._bind();\n            this.element.find('script').remove();\n\n            if (wrapped.length) {\n                wrapped\n                    .unwrap()   // .page-actions-buttons\n                    .unwrap();  // .page-actions-inner\n            }\n            this.element.wrapInner($('<div/>', {\n                'class': 'page-actions-buttons'\n            }));\n            this.element.wrapInner($('<div/>', {\n                'class': 'page-actions-inner', 'data-title': title\n            }));\n            this.element.removeClass('floating-header');\n        },\n\n        /**\n         * Set privat variables on load, for performance purposes\n         * @private\n         */\n        _setVars: function () {\n            this._placeholder = this.element.before($('<div/>', this.options.placeholderAttrs)).prev();\n            this._offsetTop = this._placeholder.offset().top;\n            this._height = this.element\n                .parents(this.options.pageMainActions)\n                .outerHeight();\n        },\n\n        /**\n         * Event binding, will monitor scroll and resize events (resize events left for backward compat)\n         * @private\n         */\n        _bind: function () {\n            this._on(window, {\n                scroll: this._handlePageScroll,\n                resize: this._handlePageScroll\n            });\n        },\n\n        /**\n         * Event handler for setting fixed positioning\n         * @private\n         */\n        _handlePageScroll: function () {\n            var isActive = $(window).scrollTop() > this._offsetTop;\n\n            if (isActive) {\n                this.element\n                    .addClass(this.options.fixedClass)\n                    .parents(this.options.pageMainActions)\n                    .addClass(this.options.hiddenClass);\n            } else {\n                this.element\n                    .removeClass(this.options.fixedClass)\n                    .parents(this.options.pageMainActions)\n                    .removeClass(this.options.hiddenClass);\n            }\n\n            this._placeholder.height(isActive ? this._height : '');\n        },\n\n        /**\n         * Widget destroy functionality\n         * @private\n         */\n        _destroy: function () {\n            this._placeholder.remove();\n            this._off($(window));\n        }\n    });\n\n    return $.mage.floatingHeader;\n});\n","mage/backend/notification.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/template',\n    'jquery/ui'\n], function ($, mageTemplate) {\n    'use strict';\n\n    $.widget('mage.notification', {\n        options: {\n            templates: {\n                global: '<div data-role=\"messages\" id=\"messages\">' +\n                    '<div class=\"message <% if (data.error) { %>error<% } %>\"><div><%- data.message %></div></div>' +\n                '</div>',\n                error: '<div data-role=\"messages\" id=\"messages\">' +\n                    '<div class=\"messages\"><div class=\"message message-error error\">' +\n                        '<div data-ui-id=\"messages-message-error\"><%- data.message %></div></div>' +\n                    '</div></div>'\n            }\n        },\n        placeholder: '[data-role=messages]',\n\n        /**\n         * Notification creation\n         * @protected\n         */\n        _create: function () {\n            $(document).on('ajaxComplete ajaxError', $.proxy(this._add, this));\n        },\n\n        /**\n         * Add new message\n         * @protected\n         * @param {Object} event - object\n         * @param {Object} jqXHR - The jQuery XMLHttpRequest object returned by $.ajax()\n         */\n        _add: function (event, jqXHR) {\n            var response;\n\n            try {\n                response = JSON.parse(jqXHR.responseText);\n\n                if (response && response.error && response['html_message']) {\n                    $(this.placeholder).html(response['html_message']);\n                }\n            } catch (e) {}\n        },\n\n        /**\n         * Adds new message.\n         *\n         * @param {Object} data - Data with a message to be displayed.\n         */\n        add: function (data) {\n            var template = data.error ? this.options.templates.error : this.options.templates.global,\n                message = mageTemplate(template, {\n                    data: data\n                }),\n                messageContainer;\n\n            if (typeof data.insertMethod === 'function') {\n                data.insertMethod(message);\n            } else {\n                messageContainer = data.messageContainer || this.placeholder;\n                $(messageContainer).prepend(message);\n            }\n\n            return this;\n        },\n\n        /**\n         * Removes error messages.\n         */\n        clear: function () {\n            $(this.placeholder).html('');\n        }\n    });\n\n    return $.mage.notification;\n});\n","mage/backend/menu.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery/ui'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.menu', {\n        widgetEventPrefix: 'menu',\n        version: '1.10.1',\n        defaultElement: '<ul>',\n        delay: 300,\n        options: {\n            icons: {\n                submenu: 'ui-icon-carat-1-e'\n            },\n            menus: 'ul',\n            position: {\n                my: 'left top',\n                at: 'right top'\n            },\n            role: 'menu',\n\n            // callbacks\n            blur: null,\n            focus: null,\n            select: null\n        },\n\n        /**\n         * @private\n         */\n        _create: function () {\n            this.activeMenu = this.element;\n            // flag used to prevent firing of the click handler\n            // as the event bubbles up through nested menus\n            this.mouseHandled = false;\n            this.element\n                .uniqueId()\n                .addClass('ui-menu ui-widget ui-widget-content ui-corner-all')\n                .toggleClass('ui-menu-icons', !!this.element.find('.ui-icon').length)\n                .attr({\n                    role: this.options.role,\n                    tabIndex: 0\n                })\n                // need to catch all clicks on disabled menu\n                // not possible through _on\n                .bind('click' + this.eventNamespace, $.proxy(function (event) {\n                    if (this.options.disabled) {\n                        event.preventDefault();\n                    }\n                }, this));\n\n            if (this.options.disabled) {\n                this.element\n                    .addClass('ui-state-disabled')\n                    .attr('aria-disabled', 'true');\n            }\n\n            this._on({\n                /**\n                 * Prevent focus from sticking to links inside menu after clicking\n                 * them (focus should always stay on UL during navigation).\n                 */\n                'mousedown .ui-menu-item > a': function (event) {\n                    event.preventDefault();\n                },\n\n                /**\n                 * Prevent focus from sticking to links inside menu after clicking\n                 * them (focus should always stay on UL during navigation).\n                 */\n                'click .ui-state-disabled > a': function (event) {\n                    event.preventDefault();\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                'click .ui-menu-item:has(a)': function (event) {\n                    var target = $(event.target).closest('.ui-menu-item');\n\n                    if (!this.mouseHandled && target.not('.ui-state-disabled').length) {\n                        this.mouseHandled = true;\n\n                        this.select(event);\n                        // Open submenu on click\n                        if (target.has('.ui-menu').length) {\n                            this.expand(event);\n                        } else if (!this.element.is(':focus')) {\n                            // Redirect focus to the menu\n                            this.element.trigger('focus', [true]);\n\n                            // If the active item is on the top level, let it stay active.\n                            // Otherwise, blur the active item since it is no longer visible.\n                            if (this.active && this.active.parents('.ui-menu').length === 1) { //eslint-disable-line\n                                clearTimeout(this.timer);\n                            }\n                        }\n                    }\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                'mouseenter .ui-menu-item': function (event) {\n                    var target = $(event.currentTarget);\n\n                    // Remove ui-state-active class from siblings of the newly focused menu item\n                    // to avoid a jump caused by adjacent elements both having a class with a border\n                    target.siblings().children('.ui-state-active').removeClass('ui-state-active');\n                    this.focus(event, target);\n                },\n                mouseleave: 'collapseAll',\n                'mouseleave .ui-menu': 'collapseAll',\n\n                /**\n                 * @param {jQuery.Event} event\n                 * @param {*} keepActiveItem\n                 */\n                focus: function (event, keepActiveItem) {\n                    // If there's already an active item, keep it active\n                    // If not, activate the first item\n                    var item = this.active || this.element.children('.ui-menu-item').eq(0);\n\n                    if (!keepActiveItem) {\n                        this.focus(event, item);\n                    }\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                blur: function (event) {\n                    this._delay(function () {\n                        if (!$.contains(this.element[0], this.document[0].activeElement)) {\n                            this.collapseAll(event);\n                        }\n                    });\n                },\n                keydown: '_keydown'\n            });\n\n            this.refresh();\n\n            // Clicks outside of a menu collapse any open menus\n            this._on(this.document, {\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                click: function (event) {\n                    if (!$(event.target).closest('.ui-menu').length) {\n                        this.collapseAll(event);\n                    }\n\n                    // Reset the mouseHandled flag\n                    this.mouseHandled = false;\n                }\n            });\n        },\n\n        /**\n         * @private\n         */\n        _destroy: function () {\n            // Destroy (sub)menus\n            this.element\n                .removeAttr('aria-activedescendant')\n                .find('.ui-menu').addBack()\n                .removeClass('ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons')\n                .removeAttr('role')\n                .removeAttr('tabIndex')\n                .removeAttr('aria-labelledby')\n                .removeAttr('aria-expanded')\n                .removeAttr('aria-hidden')\n                .removeAttr('aria-disabled')\n                .removeUniqueId()\n                .show();\n\n            // Destroy menu items\n            this.element.find('.ui-menu-item')\n                .removeClass('ui-menu-item')\n                .removeAttr('role')\n                .removeAttr('aria-disabled')\n                .children('a')\n                .removeUniqueId()\n                .removeClass('ui-corner-all ui-state-hover')\n                .removeAttr('tabIndex')\n                .removeAttr('role')\n                .removeAttr('aria-haspopup')\n                .children().each(function () {\n                    var elem = $(this);\n\n                    if (elem.data('ui-menu-submenu-carat')) {\n                        elem.remove();\n                    }\n                });\n\n            // Destroy menu dividers\n            this.element.find('.ui-menu-divider').removeClass('ui-menu-divider ui-widget-content');\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _keydown: function (event) {\n            var match, prev, character, skip, regex,\n                preventDefault = true;\n\n            /**\n             * @param {String} value\n             */\n            function escape(value) {\n                return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n            }\n\n            switch (event.keyCode) {\n                case $.ui.keyCode.PAGE_UP:\n                    this.previousPage(event);\n                    break;\n\n                case $.ui.keyCode.PAGE_DOWN:\n                    this.nextPage(event);\n                    break;\n\n                case $.ui.keyCode.HOME:\n                    this._move('first', 'first', event);\n                    break;\n\n                case $.ui.keyCode.END:\n                    this._move('last', 'last', event);\n                    break;\n\n                case $.ui.keyCode.UP:\n                    this.previous(event);\n                    break;\n\n                case $.ui.keyCode.DOWN:\n                    this.next(event);\n                    break;\n\n                case $.ui.keyCode.LEFT:\n                    this.collapse(event);\n                    break;\n\n                case $.ui.keyCode.RIGHT:\n                    if (this.active && !this.active.is('.ui-state-disabled')) {\n                        this.expand(event);\n                    }\n                    break;\n\n                case $.ui.keyCode.ENTER:\n                case $.ui.keyCode.SPACE:\n                    this._activate(event);\n                    break;\n\n                case $.ui.keyCode.ESCAPE:\n                    this.collapse(event);\n                    break;\n\n                default:\n                    preventDefault = false;\n                    prev = this.previousFilter || '';\n                    character = String.fromCharCode(event.keyCode);\n                    skip = false;\n\n                    clearTimeout(this.filterTimer);\n\n                    if (character === prev) {\n                        skip = true;\n                    } else {\n                        character = prev + character;\n                    }\n\n                    regex = new RegExp('^' + escape(character), 'i');\n                    match = this.activeMenu.children('.ui-menu-item').filter(function () {\n                        return regex.test($(this).children('a').text());\n                    });\n                    match = skip && match.index(this.active.next()) !== -1 ?\n                        this.active.nextAll('.ui-menu-item') :\n                        match;\n\n                    // If no matches on the current filter, reset to the last character pressed\n                    // to move down the menu to the first item that starts with that character\n                    if (!match.length) {\n                        character = String.fromCharCode(event.keyCode);\n                        regex = new RegExp('^' + escape(character), 'i');\n                        match = this.activeMenu.children('.ui-menu-item').filter(function () {\n                            return regex.test($(this).children('a').text());\n                        });\n                    }\n\n                    if (match.length) {\n                        this.focus(event, match);\n\n                        if (match.length > 1) { //eslint-disable-line max-depth\n                            this.previousFilter = character;\n                            this.filterTimer = this._delay(function () {\n                                delete this.previousFilter;\n                            }, 1000);\n                        } else {\n                            delete this.previousFilter;\n                        }\n                    } else {\n                        delete this.previousFilter;\n                    }\n            }\n\n            if (preventDefault) {\n                event.preventDefault();\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _activate: function (event) {\n            if (!this.active.is('.ui-state-disabled')) {\n                if (this.active.children('a[aria-haspopup=\"true\"]').length) {\n                    this.expand(event);\n                } else {\n                    this.select(event);\n                }\n            }\n        },\n\n        /**\n         * Refresh.\n         */\n        refresh: function () {\n            var menus,\n                icon = this.options.icons.submenu,\n                submenus = this.element.find(this.options.menus);\n\n            // Initialize nested menus\n            submenus.filter(':not(.ui-menu)')\n                .addClass('ui-menu ui-widget ui-widget-content ui-corner-all')\n                .hide()\n                .attr({\n                    role: this.options.role,\n                    'aria-hidden': 'true',\n                    'aria-expanded': 'false'\n                })\n                .each(function () {\n                    var menu = $(this),\n                        item = menu.prev('a'),\n                        submenuCarat = $('<span>')\n                            .addClass('ui-menu-icon ui-icon ' + icon)\n                            .data('ui-menu-submenu-carat', true);\n\n                    item\n                        .attr('aria-haspopup', 'true')\n                        .prepend(submenuCarat);\n                    menu.attr('aria-labelledby', item.attr('id'));\n                });\n\n            menus = submenus.add(this.element);\n\n            // Don't refresh list items that are already adapted\n            menus.children(':not(.ui-menu-item):has(a)')\n                .addClass('ui-menu-item')\n                .attr('role', 'presentation')\n                .children('a')\n                .uniqueId()\n                .addClass('ui-corner-all')\n                .attr({\n                    tabIndex: -1,\n                    role: this._itemRole()\n                });\n\n            // Initialize unlinked menu-items containing spaces and/or dashes only as dividers\n            menus.children(':not(.ui-menu-item)').each(function () {\n                var item = $(this);\n\n                // hyphen, em dash, en dash\n                if (!/[^\\-\\u2014\\u2013\\s]/.test(item.text())) {\n                    item.addClass('ui-widget-content ui-menu-divider');\n                }\n            });\n\n            // Add aria-disabled attribute to any disabled menu item\n            menus.children('.ui-state-disabled').attr('aria-disabled', 'true');\n\n            // If the active item has been removed, blur the menu\n            if (this.active && !$.contains(this.element[0], this.active[0])) {\n                this.blur();\n            }\n        },\n\n        /**\n         * @return {*}\n         * @private\n         */\n        _itemRole: function () {\n            return {\n                menu: 'menuitem',\n                listbox: 'option'\n            }[this.options.role];\n        },\n\n        /**\n         * @param {String} key\n         * @param {*} value\n         * @private\n         */\n        _setOption: function (key, value) {\n            if (key === 'icons') {\n                this.element.find('.ui-menu-icon')\n                    .removeClass(this.options.icons.submenu)\n                    .addClass(value.submenu);\n            }\n            this._super(key, value);\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @param {Object} item\n         */\n        focus: function (event, item) {\n            var nested, focused;\n\n            this.blur(event, event && event.type === 'focus');\n\n            this._scrollIntoView(item);\n\n            this.active = item.first();\n            focused = this.active.children('a').addClass('ui-state-focus');\n            // Only update aria-activedescendant if there's a role\n            // otherwise we assume focus is managed elsewhere\n            if (this.options.role) {\n                this.element.attr('aria-activedescendant', focused.attr('id'));\n            }\n\n            // Highlight active parent menu item, if any\n            this.active\n                .parent()\n                .closest('.ui-menu-item')\n                .children('a:first')\n                .addClass('ui-state-active');\n\n            if (event && event.type === 'keydown') {\n                this._close();\n            } else {\n                this.timer = this._delay(function () {\n                    this._close();\n                }, this.delay);\n            }\n\n            nested = item.children('.ui-menu');\n\n            if (nested.length && /^mouse/.test(event.type)) {\n                this._startOpening(nested);\n            }\n            this.activeMenu = item.parent();\n\n            this._trigger('focus', event, {\n                item: item\n            });\n        },\n\n        /**\n         * @param {Object} item\n         * @private\n         */\n        _scrollIntoView: function (item) {\n            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;\n\n            if (this._hasScroll()) {\n                borderTop = parseFloat($.css(this.activeMenu[0], 'borderTopWidth')) || 0;\n                paddingTop = parseFloat($.css(this.activeMenu[0], 'paddingTop')) || 0;\n                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;\n                scroll = this.activeMenu.scrollTop();\n                elementHeight = this.activeMenu.height();\n                itemHeight = item.height();\n\n                if (offset < 0) {\n                    this.activeMenu.scrollTop(scroll + offset);\n                } else if (offset + itemHeight > elementHeight) {\n                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);\n                }\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @param {*} fromFocus\n         */\n        blur: function (event, fromFocus) {\n            if (!fromFocus) {\n                clearTimeout(this.timer);\n            }\n\n            if (!this.active) {\n                return;\n            }\n\n            this.active.children('a').removeClass('ui-state-focus');\n            this.active = null;\n\n            this._trigger('blur', event, {\n                item: this.active\n            });\n        },\n\n        /**\n         * @param {*} submenu\n         * @private\n         */\n        _startOpening: function (submenu) {\n            clearTimeout(this.timer);\n\n            // Don't open if already open fixes a Firefox bug that caused a .5 pixel\n            // shift in the submenu position when mousing over the carat icon\n            if (submenu.attr('aria-hidden') !== 'true') {\n                return;\n            }\n\n            this.timer = this._delay(function () {\n                this._close();\n                this._open(submenu);\n            }, this.delay);\n        },\n\n        /**\n         * @param {*} submenu\n         * @private\n         */\n        _open: function (submenu) {\n            var position = $.extend({\n                of: this.active\n            }, this.options.position);\n\n            clearTimeout(this.timer);\n            this.element.find('.ui-menu').not(submenu.parents('.ui-menu'))\n                .hide()\n                .attr('aria-hidden', 'true');\n\n            submenu\n                .show()\n                .removeAttr('aria-hidden')\n                .attr('aria-expanded', 'true')\n                .position(position);\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @param {*} all\n         */\n        collapseAll: function (event, all) {\n            clearTimeout(this.timer);\n            this.timer = this._delay(function () {\n                // If we were passed an event, look for the submenu that contains the event\n                var currentMenu = all ? this.element :\n                    $(event && event.target).closest(this.element.find('.ui-menu'));\n\n                // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway\n                if (!currentMenu.length) {\n                    currentMenu = this.element;\n                }\n\n                this._close(currentMenu);\n\n                this.blur(event);\n                this.activeMenu = currentMenu;\n            }, this.delay);\n        },\n\n        // With no arguments, closes the currently active menu - if nothing is active\n        // it closes all menus.  If passed an argument, it will search for menus BELOW\n        /**\n         * With no arguments, closes the currently active menu - if nothing is active\n         * it closes all menus.  If passed an argument, it will search for menus BELOW.\n         *\n         * @param {*} startMenu\n         * @private\n         */\n        _close: function (startMenu) {\n            if (!startMenu) {\n                startMenu = this.active ? this.active.parent() : this.element;\n            }\n\n            startMenu\n                .find('.ui-menu')\n                .hide()\n                .attr('aria-hidden', 'true')\n                .attr('aria-expanded', 'false')\n                .end()\n                .find('a.ui-state-active')\n                .removeClass('ui-state-active');\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        collapse: function (event) {\n            var newItem = this.active &&\n                this.active.parent().closest('.ui-menu-item', this.element);\n\n            if (newItem && newItem.length) {\n                this._close();\n                this.focus(event, newItem);\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        expand: function (event) {\n            var newItem = this.active &&\n                this.active\n                    .children('.ui-menu ')\n                    .children('.ui-menu-item')\n                    .first();\n\n            if (newItem && newItem.length) {\n                this._open(newItem.parent());\n\n                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT\n                this._delay(function () {\n                    this.focus(event, newItem);\n                });\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        next: function (event) {\n            this._move('next', 'first', event);\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        previous: function (event) {\n            this._move('prev', 'last', event);\n        },\n\n        /**\n         * @return {null|Boolean}\n         */\n        isFirstItem: function () {\n            return this.active && !this.active.prevAll('.ui-menu-item').length;\n        },\n\n        /**\n         * @return {null|Boolean}\n         */\n        isLastItem: function () {\n            return this.active && !this.active.nextAll('.ui-menu-item').length;\n        },\n\n        /**\n         * @param {*} direction\n         * @param {*} filter\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _move: function (direction, filter, event) {\n            var next;\n\n            if (this.active) {\n                if (direction === 'first' || direction === 'last') {\n                    next = this.active\n                        [direction === 'first' ? 'prevAll' : 'nextAll']('.ui-menu-item')\n                        .eq(-1);\n                } else {\n                    next = this.active\n                        [direction + 'All']('.ui-menu-item')\n                        .eq(0);\n                }\n            }\n\n            if (!next || !next.length || !this.active) {\n                next = this.activeMenu.children('.ui-menu-item')[filter]();\n            }\n\n            this.focus(event, next);\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        nextPage: function (event) {\n            var item, base, height;\n\n            if (!this.active) {\n                this.next(event);\n\n                return;\n            }\n\n            if (this.isLastItem()) {\n                return;\n            }\n\n            if (this._hasScroll()) {\n                base = this.active.offset().top;\n                height = this.element.height();\n                this.active.nextAll('.ui-menu-item').each(function () {\n                    item = $(this);\n\n                    return item.offset().top - base - height < 0;\n                });\n\n                this.focus(event, item);\n            } else {\n                this.focus(event, this.activeMenu.children('.ui-menu-item')\n                    [!this.active ? 'first' : 'last']());\n            }\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        previousPage: function (event) {\n            var item, base, height;\n\n            if (!this.active) {\n                this.next(event);\n\n                return;\n            }\n\n            if (this.isFirstItem()) {\n                return;\n            }\n\n            if (this._hasScroll()) {\n                base = this.active.offset().top;\n                height = this.element.height();\n                this.active.prevAll('.ui-menu-item').each(function () {\n                    item = $(this);\n\n                    return item.offset().top - base + height > 0;\n                });\n\n                this.focus(event, item);\n            } else {\n                this.focus(event, this.activeMenu.children('.ui-menu-item').first());\n            }\n        },\n\n        /**\n         * @return {Boolean}\n         * @private\n         */\n        _hasScroll: function () {\n            return this.element.outerHeight() < this.element.prop('scrollHeight');\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         */\n        select: function (event) {\n            // TODO: It should never be possible to not have an active item at this\n            // point, but the tests don't trigger mouseenter before click.\n            var ui;\n\n            this.active = this.active || $(event.target).closest('.ui-menu-item');\n            ui = {\n                item: this.active\n            };\n\n            if (!this.active.has('.ui-menu').length) {\n                this.collapseAll(event, true);\n            }\n            this._trigger('select', event, ui);\n        }\n    });\n\n    return $.mage.menu;\n});\n","mage/backend/jstree-mixin.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'jquery'\n], function ($) {\n    'use strict';\n\n    return function () {\n        $.jstree._themes = require.s.contexts._.config.baseUrl + 'jquery/jstree/themes/';\n    };\n});\n","mage/backend/suggest.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'mage/template',\n    'mage/mage',\n    'jquery/ui',\n    'mage/backend/menu',\n    'mage/translate'\n], function ($, mageTemplate) {\n    'use strict';\n\n    /**\n     * Implement base functionality\n     */\n    $.widget('mage.suggest', {\n        widgetEventPrefix: 'suggest',\n        options: {\n            template: '<% if (data.items.length) { %>' +\n                '<% if (!data.term && !data.allShown() && data.recentShown()) { %>' +\n                '<h5 class=\"title\"><%- data.recentTitle %></h5>' +\n                '<% } %>' +\n                '<ul data-mage-init=\\'{\"menu\":[]}\\'>' +\n                '<% _.each(data.items, function(value){ %>' +\n                '<% if (!data.itemSelected(value)) { %><li <%= data.optionData(value) %>>' +\n                '<a href=\"#\"><%- value.label %></a></li><% } %>' +\n                '<% }); %>' +\n                '<% if (!data.term && !data.allShown() && data.recentShown()) { %>' +\n                '<li data-mage-init=\\'{\"actionLink\":{\"event\":\"showAll\"}}\\' class=\"show-all\">' +\n                '<a href=\"#\"><%- data.showAllTitle %></a></li>' +\n                '<% } %>' +\n                '</ul><% } else { %><span class=\"mage-suggest-no-records\"><%- data.noRecordsText %></span><% } %>',\n            minLength: 1,\n\n            /**\n             * @type {(String|Array)}\n             */\n            source: null,\n            delay: 500,\n            loadingClass: 'mage-suggest-state-loading',\n            events: {},\n            appendMethod: 'after',\n            controls: {\n                selector: ':ui-menu, :mage-menu',\n                eventsMap: {\n                    focus: ['menufocus'],\n                    blur: ['menublur'],\n                    select: ['menuselect']\n                }\n            },\n            termAjaxArgument: 'label_part',\n            filterProperty: 'label',\n            className: null,\n            inputWrapper: '<div class=\"mage-suggest\"><div class=\"mage-suggest-inner\"></div></div>',\n            dropdownWrapper: '<div class=\"mage-suggest-dropdown\"></div>',\n            preventClickPropagation: true,\n            currentlySelected: null,\n            submitInputOnEnter: true\n        },\n\n        /**\n         * Component's constructor\n         * @private\n         */\n        _create: function () {\n            this._term = null;\n            this._nonSelectedItem = {\n                id: '',\n                label: ''\n            };\n            this.templates = {};\n            this._renderedContext = null;\n            this._selectedItem = this._nonSelectedItem;\n            this._control = this.options.controls || {};\n            this._setTemplate();\n            this._prepareValueField();\n            this._render();\n            this._bind();\n        },\n\n        /**\n         * Render base elements for suggest component\n         * @private\n         */\n        _render: function () {\n            var wrapper;\n\n            this.dropdown = $(this.options.dropdownWrapper).hide();\n            wrapper = this.options.className ?\n                $(this.options.inputWrapper).addClass(this.options.className) :\n                $(this.options.inputWrapper);\n            this.element\n                .wrap(wrapper)[this.options.appendMethod](this.dropdown)\n                .attr('autocomplete', 'off');\n        },\n\n        /**\n         * Define a field for storing item id (find in DOM or create a new one)\n         * @private\n         */\n        _prepareValueField: function () {\n            if (this.options.valueField) {\n                this.valueField = $(this.options.valueField);\n            } else {\n                this.valueField = this._createValueField()\n                    .insertBefore(this.element)\n                    .attr('name', this.element.attr('name'));\n                this.element.removeAttr('name');\n            }\n        },\n\n        /**\n         * Create value field which keeps a id for selected option\n         * can be overridden in descendants\n         * @return {jQuery}\n         * @private\n         */\n        _createValueField: function () {\n            return $('<input/>', {\n                type: 'hidden'\n            });\n        },\n\n        /**\n         * Component's destructor\n         * @private\n         */\n        _destroy: function () {\n            this.element\n                .unwrap()\n                .removeAttr('autocomplete');\n\n            if (!this.options.valueField) {\n                this.element.attr('name', this.valueField.attr('name'));\n                this.valueField.remove();\n            }\n\n            this.dropdown.remove();\n            this._off(this.element, 'keydown keyup blur');\n        },\n\n        /**\n         * Return actual value of an \"input\"-element\n         * @return {String}\n         * @private\n         */\n        _value: function () {\n            return $.trim(this.element[this.element.is(':input') ? 'val' : 'text']());\n        },\n\n        /**\n         * Pass original event to a control component for handling it as it's own event\n         * @param {Object} event - event object\n         * @private\n         */\n        _proxyEvents: function (event) {\n            var fakeEvent = $.extend({}, $.Event(event.type), {\n                    ctrlKey: event.ctrlKey,\n                    keyCode: event.keyCode,\n                    which: event.keyCode\n                }),\n                target = this._control.selector ? this.dropdown.find(this._control.selector) : this.dropdown;\n\n            target.trigger(fakeEvent);\n        },\n\n        /**\n         * Bind handlers on specific events\n         * @private\n         */\n        _bind: function () {\n            this._on($.extend({\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                keydown: function (event) {\n                    var keyCode = $.ui.keyCode,\n                        suggestList,\n                        hasSuggestedItems,\n                        hasSelectedItems,\n                        selectedItem;\n\n                    switch (event.keyCode) {\n                        case keyCode.PAGE_UP:\n                        case keyCode.UP:\n                            if (!event.shiftKey) {\n                                event.preventDefault();\n                                this._proxyEvents(event);\n                            }\n\n                            suggestList = event.currentTarget.parentNode.getElementsByTagName('ul')[0];\n                            hasSuggestedItems = event.currentTarget\n                                    .parentNode.getElementsByTagName('ul')[0].children.length >= 0;\n\n                            if (hasSuggestedItems) {\n                                selectedItem =  $(suggestList.getElementsByClassName('_active')[0])\n                                    .removeClass('_active').prev().addClass('_active');\n                                event.currentTarget.value = selectedItem.find('a').text();\n                            }\n\n                            break;\n\n                        case keyCode.PAGE_DOWN:\n                        case keyCode.DOWN:\n                            if (!event.shiftKey) {\n                                event.preventDefault();\n                                this._proxyEvents(event);\n                            }\n\n                            suggestList = event.currentTarget.parentNode.getElementsByTagName('ul')[0];\n                            hasSuggestedItems = event.currentTarget\n                                .parentNode.getElementsByTagName('ul')[0].children.length >= 0;\n\n                            if (hasSuggestedItems) {\n                                hasSelectedItems = suggestList.getElementsByClassName('_active').length === 0;\n\n                                if (hasSelectedItems) { //eslint-disable-line max-depth\n                                    selectedItem = $(suggestList.children[0]).addClass('_active');\n                                    event.currentTarget.value = selectedItem.find('a').text();\n                                } else {\n                                    selectedItem = $(suggestList.getElementsByClassName('_active')[0])\n                                        .removeClass('_active').next().addClass('_active');\n                                    event.currentTarget.value = selectedItem.find('a').text();\n                                }\n                            }\n                            break;\n\n                        case keyCode.TAB:\n                            if (this.isDropdownShown()) {\n                                this._onSelectItem(event, null);\n                                event.preventDefault();\n                            }\n                            break;\n\n                        case keyCode.ENTER:\n                        case keyCode.NUMPAD_ENTER:\n                            this._toggleEnter(event);\n\n                            if (this.isDropdownShown() && this._focused) {\n                                this._proxyEvents(event);\n                                event.preventDefault();\n                            }\n                            break;\n\n                        case keyCode.ESCAPE:\n                            if (this.isDropdownShown()) {\n                                event.stopPropagation();\n                            }\n                            this.close(event);\n                            this._blurItem();\n                            break;\n                    }\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                keyup: function (event) {\n                    var keyCode = $.ui.keyCode;\n\n                    switch (event.keyCode) {\n                        case keyCode.HOME:\n                        case keyCode.END:\n                        case keyCode.PAGE_UP:\n                        case keyCode.PAGE_DOWN:\n                        case keyCode.ESCAPE:\n                        case keyCode.UP:\n                        case keyCode.DOWN:\n                        case keyCode.LEFT:\n                        case keyCode.RIGHT:\n                        case keyCode.TAB:\n                            break;\n\n                        case keyCode.ENTER:\n                        case keyCode.NUMPAD_ENTER:\n                            if (this.isDropdownShown()) {\n                                event.preventDefault();\n                            }\n                            break;\n                        default:\n                            this.search(event);\n                    }\n                },\n\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                blur: function (event) {\n                    if (!this.preventBlur) {\n                        this._abortSearch();\n                        this.close(event);\n                        this._change(event);\n                    } else {\n                        this.element.trigger('focus');\n                    }\n                },\n                cut: this.search,\n                paste: this.search,\n                input: this.search,\n                selectItem: this._onSelectItem,\n                click: this.search\n            }, this.options.events));\n\n            this._bindSubmit();\n            this._bindDropdown();\n        },\n\n        /**\n         * @param {Object} event\n         * @private\n         */\n        _toggleEnter: function (event) {\n            var suggestList,\n                activeItems,\n                selectedItem;\n\n            if (!this.options.submitInputOnEnter) {\n                event.preventDefault();\n            }\n\n            suggestList = $(event.currentTarget.parentNode).find('ul').first();\n            activeItems = suggestList.find('._active');\n\n            if (activeItems.length >= 0) {\n                selectedItem = activeItems.first();\n\n                if (selectedItem.find('a') && selectedItem.find('a').attr('href') !== undefined) {\n                    window.location = selectedItem.find('a').attr('href');\n                    event.preventDefault();\n                }\n            }\n        },\n\n        /**\n         * Bind handlers for submit on enter\n         * @private\n         */\n        _bindSubmit: function () {\n            this.element.parents('form').on('submit', function (event) {\n                if (!this.submitInputOnEnter) {\n                    event.preventDefault();\n                }\n            });\n        },\n\n        /**\n         * @param {Object} e - event object\n         * @private\n         */\n        _change: function (e) {\n            if (this._term !== this._value()) {\n                this._trigger('change', e);\n            }\n        },\n\n        /**\n         * Bind handlers for dropdown element on specific events\n         * @private\n         */\n        _bindDropdown: function () {\n            var events = {\n                /**\n                 * @param {jQuery.Event} e\n                 */\n                click: function (e) {\n                    // prevent default browser's behavior of changing location by anchor href\n                    e.preventDefault();\n                },\n\n                /**\n                 * @param {jQuery.Event} e\n                 */\n                mousedown: function (e) {\n                    e.preventDefault();\n                }\n            };\n\n            $.each(this._control.eventsMap, $.proxy(function (suggestEvent, controlEvents) {\n                $.each(controlEvents, $.proxy(function (i, handlerName) {\n                    switch (suggestEvent) {\n                        case 'select':\n                            events[handlerName] = this._onSelectItem;\n                            break;\n\n                        case 'focus':\n                            events[handlerName] = this._focusItem;\n                            break;\n\n                        case 'blur':\n                            events[handlerName] = this._blurItem;\n                            break;\n                    }\n                }, this));\n            }, this));\n\n            if (this.options.preventClickPropagation) {\n                this._on(this.dropdown, events);\n            }\n            // Fix for IE 8\n            this._on(this.dropdown, {\n                /**\n                 * Mousedown.\n                 */\n                mousedown: function () {\n                    this.preventBlur = true;\n                },\n\n                /**\n                 * Mouseup.\n                 */\n                mouseup: function () {\n                    this.preventBlur = false;\n                }\n            });\n        },\n\n        /**\n         * @override\n         */\n        _trigger: function (type, event) {\n            var result = this._superApply(arguments);\n\n            if (result === false && event) {\n                event.stopImmediatePropagation();\n                event.preventDefault();\n            }\n\n            return result;\n        },\n\n        /**\n         * Handle focus event of options item\n         * @param {Object} e - event object\n         * @param {Object} ui - object that can contain information about focused item\n         * @private\n         */\n        _focusItem: function (e, ui) {\n            if (ui && ui.item) {\n                this._focused = $(ui.item).prop('tagName') ?\n                    this._readItemData(ui.item) :\n                    ui.item;\n\n                this.element.val(this._focused.label);\n                this._trigger('focus', e, {\n                    item: this._focused\n                });\n            }\n        },\n\n        /**\n         * Handle blur event of options item\n         * @private\n         */\n        _blurItem: function () {\n            this._focused = null;\n            this.element.val(this._term);\n        },\n\n        /**\n         * @param {Object} e - event object\n         * @param {Object} item\n         * @private\n         */\n        _onSelectItem: function (e, item) {\n            if (item && $.type(item) === 'object' && $(e.target).is(this.element)) {\n                this._focusItem(e, {\n                    item: item\n                });\n            }\n\n            if (this._trigger('beforeselect', e || null, {\n                    item: this._focused\n                }) === false) {\n                return;\n            }\n            this._selectItem(e);\n            this._blurItem();\n            this._trigger('select', e || null, {\n                item: this._selectedItem\n            });\n        },\n\n        /**\n         * Save selected item and hide dropdown\n         * @private\n         * @param {Object} e - event object\n         */\n        _selectItem: function (e) {\n            if (this._focused) {\n                this._selectedItem = this._focused;\n\n                if (this._selectedItem !== this._nonSelectedItem) {\n                    this._term = this._selectedItem.label;\n                    this.valueField.val(this._selectedItem.id);\n                    this.close(e);\n                }\n            }\n        },\n\n        /**\n         * Read option data from item element\n         * @param {Element} element\n         * @return {Object}\n         * @private\n         */\n        _readItemData: function (element) {\n            return element.data('suggestOption') || this._nonSelectedItem;\n        },\n\n        /**\n         * Check if dropdown is shown\n         * @return {Boolean}\n         */\n        isDropdownShown: function () {\n            return this.dropdown.is(':visible');\n        },\n\n        /**\n         * Open dropdown\n         * @private\n         * @param {Object} e - event object\n         */\n        open: function (e) {\n            if (!this.isDropdownShown()) {\n                this.element.addClass('_suggest-dropdown-open');\n                this.dropdown.show();\n                this._trigger('open', e);\n            }\n        },\n\n        /**\n         * Close and clear dropdown content\n         * @private\n         * @param {Object} e - event object\n         */\n        close: function (e) {\n            this._renderedContext = null;\n\n            if (this.dropdown.length) {\n                this.element.removeClass('_suggest-dropdown-open');\n                this.dropdown.hide().empty();\n            }\n\n            this._trigger('close', e);\n        },\n\n        /**\n         * Acquire content template\n         * @private\n         */\n        _setTemplate: function () {\n            this.templateName = 'suggest' + Math.random().toString(36).substr(2);\n\n            this.templates[this.templateName] = mageTemplate(this.options.template);\n        },\n\n        /**\n         * Execute search process\n         * @public\n         * @param {Object} e - event object\n         */\n        search: function (e) {\n            var term = this._value();\n\n            if ((this._term !== term || term.length === 0) && !this.preventBlur) {\n                this._term = term;\n\n                if ($.type(term) === 'string' && term.length >= this.options.minLength) {\n                    if (this._trigger('search', e) === false) { //eslint-disable-line max-depth\n                        return;\n                    }\n                    this._search(e, term, {});\n                } else {\n                    this._selectedItem = this._nonSelectedItem;\n                    this._resetSuggestValue();\n                }\n            }\n        },\n\n        /**\n         * Clear suggest hidden input\n         * @private\n         */\n        _resetSuggestValue: function () {\n            this.valueField.val(this._nonSelectedItem.id);\n        },\n\n        /**\n         * Actual search method, can be overridden in descendants\n         * @param {Object} e - event object\n         * @param {String} term - search phrase\n         * @param {Object} context - search context\n         * @private\n         */\n        _search: function (e, term, context) {\n            var response = $.proxy(function (items) {\n                return this._processResponse(e, items, context || {});\n            }, this);\n\n            this.element.addClass(this.options.loadingClass);\n\n            if (this.options.delay) {\n                if ($.type(this.options.data) !== 'undefined') {\n                    response(this.filter(this.options.data, term));\n                }\n                clearTimeout(this._searchTimeout);\n                this._searchTimeout = this._delay(function () {\n                    this._source(term, response);\n                }, this.options.delay);\n            } else {\n                this._source(term, response);\n            }\n        },\n\n        /**\n         * Extend basic context with additional data (search results, search term)\n         * @param {Object} context\n         * @return {Object}\n         * @private\n         */\n        _prepareDropdownContext: function (context) {\n            return $.extend(context, {\n                items: this._items,\n                term: this._term,\n\n                /**\n                 * @param {Object} item\n                 * @return {String}\n                 */\n                optionData: function (item) {\n                    return 'data-suggest-option=\"' +\n                        $('<div>').text(JSON.stringify(item)).html().replace(/\"/g, '&quot;') + '\"';\n                },\n                itemSelected: $.proxy(this._isItemSelected, this),\n                noRecordsText: $.mage.__('No records found.')\n            });\n        },\n\n        /**\n         * @param {Object} item\n         * @return {Boolean}\n         * @private\n         */\n        _isItemSelected: function (item) {\n            return item.id == (this._selectedItem && this._selectedItem.id ? //eslint-disable-line eqeqeq\n                this._selectedItem.id :\n                this.options.currentlySelected);\n        },\n\n        /**\n         * Render content of suggest's dropdown\n         * @param {Object} e - event object\n         * @param {Array} items - list of label+id objects\n         * @param {Object} context - template's context\n         * @private\n         */\n        _renderDropdown: function (e, items, context) {\n            var tmpl = this.templates[this.templateName];\n\n            this._items = items;\n\n            tmpl = tmpl({\n                data: this._prepareDropdownContext(context)\n            });\n\n            $(tmpl).appendTo(this.dropdown.empty());\n\n            this.dropdown.trigger('contentUpdated')\n                .find(this._control.selector).on('focus', function (event) {\n                    event.preventDefault();\n                });\n\n            this._renderedContext = context;\n            this.element.removeClass(this.options.loadingClass);\n            this.open(e);\n        },\n\n        /**\n         * @param {Object} e\n         * @param {Object} items\n         * @param {Object} context\n         * @private\n         */\n        _processResponse: function (e, items, context) {\n            var renderer = $.proxy(function (i) {\n                return this._renderDropdown(e, i, context || {});\n            }, this);\n\n            if (this._trigger('response', e, [items, renderer]) === false) {\n                return;\n            }\n            this._renderDropdown(e, items, context);\n        },\n\n        /**\n         * Implement search process via spesific source\n         * @param {String} term - search phrase\n         * @param {Function} response - search results handler, process search result\n         * @private\n         */\n        _source: function (term, response) {\n            var o = this.options,\n                ajaxData;\n\n            if ($.isArray(o.source)) {\n                response(this.filter(o.source, term));\n            } else if ($.type(o.source) === 'string') {\n                ajaxData = {};\n                ajaxData[this.options.termAjaxArgument] = term;\n\n                this._xhr = $.ajax($.extend(true, {\n                    url: o.source,\n                    type: 'POST',\n                    dataType: 'json',\n                    data: ajaxData,\n                    success: $.proxy(function (items) {\n                        this.options.data = items;\n                        response.apply(response, arguments);\n                    }, this)\n                }, o.ajaxOptions || {}));\n            } else if ($.type(o.source) === 'function') {\n                o.source.apply(o.source, arguments);\n            }\n        },\n\n        /**\n         * Abort search process\n         * @private\n         */\n        _abortSearch: function () {\n            this.element.removeClass(this.options.loadingClass);\n            clearTimeout(this._searchTimeout);\n        },\n\n        /**\n         * Perform filtering in advance loaded items and returns search result\n         * @param {Array} items - all available items\n         * @param {String} term - search phrase\n         * @return {Object}\n         */\n        filter: function (items, term) {\n            var matcher = new RegExp(term.replace(/[\\-\\/\\\\\\^$*+?.()|\\[\\]{}]/g, '\\\\$&'), 'i'),\n                itemsArray = $.isArray(items) ? items : $.map(items, function (element) {\n                    return element;\n                }),\n                property = this.options.filterProperty;\n\n            return $.grep(\n                itemsArray,\n                function (value) {\n                    return matcher.test(value[property] || value.id || value);\n                }\n            );\n        }\n    });\n\n    /**\n     * Implement show all functionality and storing and display recent searches\n     */\n    $.widget('mage.suggest', $.mage.suggest, {\n        options: {\n            showRecent: false,\n            showAll: false,\n            storageKey: 'suggest',\n            storageLimit: 10\n        },\n\n        /**\n         * @override\n         */\n        _create: function () {\n            var recentItems;\n\n            if (this.options.showRecent && window.localStorage) {\n                recentItems = JSON.parse(localStorage.getItem(this.options.storageKey));\n\n                /**\n                 * @type {Array} - list of recently searched items\n                 * @private\n                 */\n                this._recentItems = $.isArray(recentItems) ? recentItems : [];\n            }\n            this._super();\n        },\n\n        /**\n         * @override\n         */\n        _bind: function () {\n            this._super();\n            this._on(this.dropdown, {\n                /**\n                 * @param {jQuery.Event} e\n                 */\n                showAll: function (e) {\n                    e.stopImmediatePropagation();\n                    e.preventDefault();\n                    this.element.trigger('showAll');\n                }\n            });\n\n            if (this.options.showRecent || this.options.showAll) {\n                this._on({\n                    /**\n                     * @param {jQuery.Event} e\n                     */\n                    focus: function (e) {\n                        if (!this.isDropdownShown()) {\n                            this.search(e);\n                        }\n                    },\n                    showAll: this._showAll\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {Object} e - event object\n         */\n        _showAll: function (e) {\n            this._abortSearch();\n            this._search(e, '', {\n                _allShown: true\n            });\n        },\n\n        /**\n         * @override\n         */\n        search: function (e) {\n            if (!this._value()) {\n\n                if (this.options.showRecent) {\n\n                    if (this._recentItems.length) { //eslint-disable-line max-depth\n                        this._processResponse(e, this._recentItems, {});\n                    } else {\n                        this._showAll(e);\n                    }\n                } else if (this.options.showAll) {\n                    this._showAll(e);\n                }\n            }\n            this._superApply(arguments);\n        },\n\n        /**\n         * @override\n         */\n        _selectItem: function () {\n            this._superApply(arguments);\n\n            if (this._selectedItem && this._selectedItem.id && this.options.showRecent) {\n                this._addRecent(this._selectedItem);\n            }\n        },\n\n        /**\n         * @override\n         */\n        _prepareDropdownContext: function () {\n            var context = this._superApply(arguments);\n\n            return $.extend(context, {\n                recentShown: $.proxy(function () {\n                    return this.options.showRecent;\n                }, this),\n                recentTitle: $.mage.__('Recent items'),\n                showAllTitle: $.mage.__('Show all...'),\n\n                /**\n                 * @return {Boolean}\n                 */\n                allShown: function () {\n                    return !!context._allShown;\n                }\n            });\n        },\n\n        /**\n         * Add selected item of search result into storage of recents\n         * @param {Object} item - label+id object\n         * @private\n         */\n        _addRecent: function (item) {\n            this._recentItems = $.grep(this._recentItems, function (obj) {\n                return obj.id !== item.id;\n            });\n            this._recentItems.unshift(item);\n            this._recentItems = this._recentItems.slice(0, this.options.storageLimit);\n            localStorage.setItem(this.options.storageKey, JSON.stringify(this._recentItems));\n        }\n    });\n\n    /**\n     * Implement multi suggest functionality\n     */\n    $.widget('mage.suggest', $.mage.suggest, {\n        options: {\n            multiSuggestWrapper: '<ul class=\"mage-suggest-choices\">' +\n                '<li class=\"mage-suggest-search-field\" data-role=\"parent-choice-element\"><' +\n                'label class=\"mage-suggest-search-label\"></label></li></ul>',\n            choiceTemplate: '<li class=\"mage-suggest-choice button\"><div><%- text %></div>' +\n            '<span class=\"mage-suggest-choice-close\" tabindex=\"-1\" ' +\n            'data-mage-init=\\'{\"actionLink\":{\"event\":\"removeOption\"}}\\'></span></li>',\n            selectedClass: 'mage-suggest-selected'\n        },\n\n        /**\n         * @override\n         */\n        _create: function () {\n            this.choiceTmpl = mageTemplate(this.options.choiceTemplate);\n\n            this._super();\n\n            if (this.options.multiselect) {\n                this.valueField.hide();\n            }\n        },\n\n        /**\n         * @override\n         */\n        _render: function () {\n            this._super();\n\n            if (this.options.multiselect) {\n                this._renderMultiselect();\n            }\n        },\n\n        /**\n         * Render selected options\n         * @private\n         */\n        _renderMultiselect: function () {\n            var that = this;\n\n            this.element.wrap(this.options.multiSuggestWrapper);\n            this.elementWrapper = this.element.closest('[data-role=\"parent-choice-element\"]');\n            $(function () {\n                that._getOptions()\n                    .each(function (i, option) {\n                        option = $(option);\n                        that._createOption({\n                            id: option.val(),\n                            label: option.text()\n                        });\n                    });\n            });\n        },\n\n        /**\n         * @return {Array} array of DOM-elements\n         * @private\n         */\n        _getOptions: function () {\n            return this.valueField.find('option');\n        },\n\n        /**\n         * @override\n         */\n        _bind: function () {\n            this._super();\n\n            if (this.options.multiselect) {\n                this._on({\n                    /**\n                     * @param {jQuery.Event} event\n                     */\n                    keydown: function (event) {\n                        if (event.keyCode === $.ui.keyCode.BACKSPACE) {\n                            if (!this._value()) {\n                                this._removeLastAdded(event);\n                            }\n                        }\n                    },\n                    removeOption: this.removeOption\n                });\n            }\n        },\n\n        /**\n         * @param {Array} items\n         * @return {Array}\n         * @private\n         */\n        _filterSelected: function (items) {\n            var options = this._getOptions();\n\n            return $.grep(items, function (value) {\n                var itemSelected = false;\n\n                $.each(options, function () {\n                    if (value.id == $(this).val()) { //eslint-disable-line eqeqeq\n                        itemSelected = true;\n                    }\n                });\n\n                return !itemSelected;\n            });\n        },\n\n        /**\n         * @override\n         */\n        _processResponse: function (e, items, context) {\n            if (this.options.multiselect) {\n                items = this._filterSelected(items, context);\n            }\n            this._superApply([e, items, context]);\n        },\n\n        /**\n         * @override\n         */\n        _prepareValueField: function () {\n            this._super();\n\n            if (this.options.multiselect && !this.options.valueField && this.options.selectedItems) {\n                $.each(this.options.selectedItems, $.proxy(function (i, item) {\n                    this._addOption(item);\n                }, this));\n            }\n        },\n\n        /**\n         * If \"multiselect\" option is set, then do not need to clear value for hidden select, to avoid losing of\n         *      previously selected items\n         * @override\n         */\n        _resetSuggestValue: function () {\n            if (!this.options.multiselect) {\n                this._super();\n            }\n        },\n\n        /**\n         * @override\n         */\n        _createValueField: function () {\n            if (this.options.multiselect) {\n                return $('<select/>', {\n                    type: 'hidden',\n                    multiple: 'multiple'\n                });\n            }\n\n            return this._super();\n        },\n\n        /**\n         * @override\n         */\n        _selectItem: function (e) {\n            if (this.options.multiselect) {\n                if (this._focused) {\n                    this._selectedItem = this._focused;\n\n                    /* eslint-disable max-depth */\n                    if (this._selectedItem !== this._nonSelectedItem) {\n                        this._term = '';\n                        this.element.val(this._term);\n\n                        if (this._isItemSelected(this._selectedItem)) {\n                            $(e.target).removeClass(this.options.selectedClass);\n                            this.removeOption(e, this._selectedItem);\n                            this._selectedItem = this._nonSelectedItem;\n                        } else {\n                            $(e.target).addClass(this.options.selectedClass);\n                            this._addOption(e, this._selectedItem);\n                        }\n                    }\n\n                    /* eslint-enable max-depth */\n                }\n                this.close(e);\n            } else {\n                this._superApply(arguments);\n            }\n        },\n\n        /**\n         * @override\n         */\n        _isItemSelected: function (item) {\n            if (this.options.multiselect) {\n                return this.valueField.find('option[value=' + item.id + ']').length > 0;\n            }\n\n            return this._superApply(arguments);\n        },\n\n        /**\n         *\n         * @param {Object} item\n         * @return {Element}\n         * @private\n         */\n        _createOption: function (item) {\n            var option = this._getOption(item);\n\n            if (!option.length) {\n                option = $('<option>', {\n                    value: item.id,\n                    selected: true\n                }).text(item.label);\n            }\n\n            return option.data('renderedOption', this._renderOption(item));\n        },\n\n        /**\n         * Add selected item in to select options\n         * @param {Object} e - event object\n         * @param {*} item\n         * @private\n         */\n        _addOption: function (e, item) {\n            this.valueField.append(this._createOption(item).data('selectTarget', $(e.target)));\n        },\n\n        /**\n         * @param {Object|Element} item\n         * @return {Element}\n         * @private\n         */\n        _getOption: function (item) {\n            return $(item).prop('tagName') ?\n                $(item) :\n                this.valueField.find('option[value=' + item.id + ']');\n        },\n\n        /**\n         * Remove last added option\n         * @private\n         * @param {Object} e - event object\n         */\n        _removeLastAdded: function (e) {\n            var lastAdded = this._getOptions().last();\n\n            if (lastAdded.length) {\n                this.removeOption(e, lastAdded);\n            }\n        },\n\n        /**\n         * Remove item from select options\n         * @param {Object} e - event object\n         * @param {Object} item\n         * @private\n         */\n        removeOption: function (e, item) {\n            var option = this._getOption(item),\n                selectTarget = option.data('selectTarget');\n\n            if (selectTarget && selectTarget.length) {\n                selectTarget.removeClass(this.options.selectedClass);\n            }\n\n            option.data('renderedOption').remove();\n            option.remove();\n        },\n\n        /**\n         * Render visual element of selected item\n         * @param {Object} item - selected item\n         * @private\n         */\n        _renderOption: function (item) {\n            var tmpl = this.choiceTmpl({\n                text: item.label\n            });\n\n            return $(tmpl)\n                .insertBefore(this.elementWrapper)\n                .trigger('contentUpdated')\n                .on('removeOption', $.proxy(function (e) {\n                    this.removeOption(e, item);\n                }, this));\n        }\n    });\n\n    return $.mage.suggest;\n});\n","mage/backend/validation.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/* global BASE_URL, alertAlreadyDisplayed */\ndefine([\n    'jquery',\n    'underscore',\n    'Magento_Ui/js/modal/alert',\n    'jquery/ui',\n    'jquery/validate',\n    'mage/translate',\n    'mage/validation'\n], function ($, _, alert) {\n    'use strict';\n\n    $.extend(true, $.validator.prototype, {\n        /**\n         * Focus invalid fields\n         */\n        focusInvalid: function () {\n            if (this.settings.focusInvalid) {\n                try {\n                    $(this.errorList.length && this.errorList[0].element || [])\n                        .focus()\n                        .trigger('focusin');\n                } catch (e) {\n                    // ignore IE throwing errors when focusing hidden elements\n                }\n            }\n        },\n\n        /**\n         * Elements.\n         */\n        elements: function () {\n            var validator = this,\n                rulesCache = {};\n\n            // select all valid inputs inside the form (no submit or reset buttons)\n            return $(this.currentForm)\n                .find('input, select, textarea')\n                .not(this.settings.forceIgnore)\n                .not(':submit, :reset, :image, [disabled]')\n                .not(this.settings.ignore)\n                .filter(function () {\n                    if (!this.name && validator.settings.debug && window.console) {\n                        console.error('%o has no name assigned', this);\n                    }\n\n                    // select only the first element for each name, and only those with rules specified\n                    if (this.name in rulesCache || !validator.objectLength($(this).rules())) {\n                        return false;\n                    }\n\n                    rulesCache[this.name] = true;\n\n                    return true;\n                });\n        }\n    });\n\n    $.extend($.fn, {\n        /**\n         * ValidationDelegate overridden for those cases where the form is located in another form,\n         *     to avoid not correct working of validate plug-in\n         * @override\n         * @param {String} delegate - selector, if event target matched against this selector,\n         *     then event will be delegated\n         * @param {String} type - event type\n         * @param {Function} handler - event handler\n         * @return {Element}\n         */\n        validateDelegate: function (delegate, type, handler) {\n            return this.on(type, $.proxy(function (event) {\n                var target = $(event.target),\n                    form = target[0].form;\n\n                if (form && $(form).is(this) && $.data(form, 'validator') && target.is(delegate)) {\n                    return handler.apply(target, arguments);\n                }\n            }, this));\n        }\n    });\n\n    $.widget('mage.validation', $.mage.validation, {\n        options: {\n            messagesId: 'messages',\n            forceIgnore: '',\n            ignore: ':disabled, .ignore-validate, .no-display.template, ' +\n                ':disabled input, .ignore-validate input, .no-display.template input, ' +\n                ':disabled select, .ignore-validate select, .no-display.template select, ' +\n                ':disabled textarea, .ignore-validate textarea, .no-display.template textarea',\n            errorElement: 'label',\n            errorUrl: typeof BASE_URL !== 'undefined' ? BASE_URL : null,\n\n            /**\n             * @param {HTMLElement} element\n             */\n            highlight: function (element) {\n                if ($.validator.defaults.highlight && $.isFunction($.validator.defaults.highlight)) {\n                    $.validator.defaults.highlight.apply(this, arguments);\n                }\n                $(element).trigger('highlight.validate');\n            },\n\n            /**\n             * @param {HTMLElement} element\n             */\n            unhighlight: function (element) {\n                if ($.validator.defaults.unhighlight && $.isFunction($.validator.defaults.unhighlight)) {\n                    $.validator.defaults.unhighlight.apply(this, arguments);\n                }\n                $(element).trigger('unhighlight.validate');\n            }\n        },\n\n        /**\n         * Validation creation\n         * @protected\n         */\n        _create: function () {\n            if (!this.options.submitHandler && $.type(this.options.submitHandler) !== 'function') {\n                if (!this.options.frontendOnly && this.options.validationUrl) {\n                    this.options.submitHandler = $.proxy(this._ajaxValidate, this);\n                } else {\n                    this.options.submitHandler = $.proxy(this._submit, this);\n                }\n            }\n            this.element.on('resetElement', function (e) {\n                $(e.target).rules('remove');\n            });\n            this._super('_create');\n        },\n\n        /**\n         * ajax validation\n         * @protected\n         */\n        _ajaxValidate: function () {\n            $.ajax({\n                url: this.options.validationUrl,\n                type: 'POST',\n                dataType: 'json',\n                data: this.element.serialize(),\n                context: $('body'),\n                success: $.proxy(this._onSuccess, this),\n                error: $.proxy(this._onError, this),\n                showLoader: true,\n                dontHide: false\n            });\n        },\n\n        /**\n         * Process ajax success.\n         *\n         * @protected\n         * @param {Object} response\n         */\n        _onSuccess: function (response) {\n            if (!response.error) {\n                this._submit();\n            } else {\n                this._showErrors(response);\n                $(this.element[0]).trigger('afterValidate.error');\n                $('body').trigger('processStop');\n            }\n        },\n\n        /**\n         * Submitting a form.\n         * @private\n         */\n        _submit: function () {\n            $(this.element[0]).trigger('afterValidate.beforeSubmit');\n            this.element[0].submit();\n        },\n\n        /**\n         * Displays errors after backend validation.\n         *\n         * @param {Object} data - Data that came from backend.\n         */\n        _showErrors: function (data) {\n            $('body').notification('clear')\n                .notification('add', {\n                    error: data.error,\n                    message: data.message,\n\n                    /**\n                     * @param {*} message\n                     */\n                    insertMethod: function (message) {\n                        $('.messages:first').html(message);\n                    }\n                });\n        },\n\n        /**\n         * Tries to retrieve element either by id or by inputs' name property.\n         * @param {String} code - String to search by.\n         * @returns {jQuery} jQuery element.\n         */\n        _getByCode: function (code) {\n            var parent = this.element[0],\n                element;\n\n            element = parent.querySelector('#' + code) || parent.querySelector('input[name=' + code + ']');\n\n            return $(element);\n        },\n\n        /**\n         * Process ajax error\n         * @protected\n         */\n        _onError: function () {\n            $(this.element[0]).trigger('afterValidate.error');\n            $('body').trigger('processStop');\n\n            if (this.options.errorUrl) {\n                location.href = this.options.errorUrl;\n            }\n        }\n    });\n\n    _.each({\n        'validate-greater-zero-based-on-option': [\n            function (v, el) {\n                var optionType = $(el)\n                    .closest('.form-list')\n                    .prev('.fieldset-alt')\n                    .find('select.select-product-option-type'),\n                    optionTypeVal = optionType.val();\n\n                v = Number(v) || 0;\n\n                if (optionType && (optionTypeVal == 'checkbox' || optionTypeVal == 'multi') && v <= 0) { //eslint-disable-line\n                    return false;\n                }\n\n                return true;\n            },\n            $.mage.__('Please enter a number greater 0 in this field.')\n        ],\n        'validate-rating': [\n            function () {\n                var ratings = $('#detailed_rating').find('.field-rating'),\n                    noError = true;\n\n                ratings.each(function (index, rating) {\n                    noError = noError && $(rating).find('input:checked').length > 0;\n                });\n\n                return noError;\n            },\n            $.mage.__('Please select one of each ratings above.')\n        ],\n        'validate-downloadable-file': [\n            function (v, element) {\n                var elmParent = $(element).parent(),\n                    linkType = elmParent.find('input[value=\"file\"]'),\n                    newFileContainer;\n\n                if (linkType.is(':checked') && (v === '' || v === '[]')) {\n                    newFileContainer = elmParent.find('.new-file');\n\n                    if (!alertAlreadyDisplayed && (newFileContainer.empty() || newFileContainer.is(':visible'))) {\n                        window.alertAlreadyDisplayed = true;\n                        alert({\n                            content: $.mage.__('There are files that were selected but not uploaded yet. ' +\n                            'Please upload or remove them first')\n                        });\n                    }\n\n                    return false;\n                }\n\n                return true;\n            },\n            'Please upload a file.'\n        ],\n        'validate-downloadable-url': [\n            function (v, element) {\n                var linkType = $(element).parent().find('input[value=\"url\"]');\n\n                if (linkType.is(':checked') && v === '') {\n                    return false;\n                }\n\n                return true;\n            },\n            $.mage.__('Please specify Url.')\n        ]\n    }, function (rule, i) {\n        rule.unshift(i);\n        $.validator.addMethod.apply($.validator, rule);\n    });\n\n    return $.mage.validation;\n});\n","mage/backend/bootstrap.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/* global FORM_KEY */\ndefine([\n    'jquery',\n    'mage/apply/main',\n    'mage/backend/notification',\n    'Magento_Ui/js/lib/knockout/bootstrap',\n    'mage/mage',\n    'mage/translate'\n], function ($, mage, notification) {\n    'use strict';\n\n    var bootstrap;\n\n    $.ajaxSetup({\n        /*\n         * @type {string}\n         */\n        type: 'POST',\n\n        /**\n         * Ajax before send callback.\n         *\n         * @param {Object} jqXHR - The jQuery XMLHttpRequest object returned by $.ajax()\n         * @param {Object} settings\n         */\n        beforeSend: function (jqXHR, settings) {\n            var formKey = typeof FORM_KEY !== 'undefined' ? FORM_KEY : null;\n\n            if (!settings.url.match(new RegExp('[?&]isAjax=true',''))) {\n                settings.url = settings.url.match(\n                    new RegExp('\\\\?', 'g')) ?\n                    settings.url + '&isAjax=true' :\n                    settings.url + '?isAjax=true';\n            }\n\n            if (!settings.data) {\n                settings.data = {\n                    'form_key': formKey\n                };\n            } else if ($.type(settings.data) === 'string' &&\n                settings.data.indexOf('form_key=') === -1) {\n                settings.data += '&' + $.param({\n                    'form_key': formKey\n                });\n            } else if ($.isPlainObject(settings.data) && !settings.data['form_key']) {\n                settings.data['form_key'] = formKey;\n            }\n        },\n\n        /**\n         * Ajax complete callback.\n         *\n         * @param {Object} jqXHR - The jQuery XMLHttpRequest object returned by $.ajax()\n         */\n        complete: function (jqXHR) {\n            var jsonObject;\n\n            if (jqXHR.readyState === 4) {\n                try {\n                    jsonObject = $.parseJSON(jqXHR.responseText);\n\n                    if (jsonObject.ajaxExpired && jsonObject.ajaxRedirect) { //eslint-disable-line max-depth\n                        window.location.replace(jsonObject.ajaxRedirect);\n                    }\n                } catch (e) {}\n            }\n        },\n\n        /**\n         * Error callback.\n         */\n        error: function () {\n            $('body').notification('clear')\n                .notification('add', {\n                    error: true,\n                    message: $.mage.__(\n                        'A technical problem with the server created an error. ' +\n                        'Try again to continue what you were doing. If the problem persists, try again later.'\n                    ),\n\n                    /**\n                     * @param {String} message\n                     */\n                    insertMethod: function (message) {\n                        var $wrapper = $('<div/>').html(message);\n\n                        $('.page-main-actions').after($wrapper);\n                    }\n                });\n        }\n    });\n\n    /**\n     * Bootstrap application.\n     */\n    bootstrap = function () {\n        /**\n         * Init all components defined via data-mage-init attribute\n         * and subscribe init action on contentUpdated event\n         */\n        mage.apply();\n\n        /*\n         * Initialization of notification widget\n         */\n        notification({}, $('body'));\n    };\n\n    $(bootstrap);\n});\n","mage/backend/editablemultiselect.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\n/* global EditableMultiselect */\n/* eslint-disable strict */\ndefine([\n    'jquery',\n    'Magento_Ui/js/modal/alert',\n    'Magento_Ui/js/modal/confirm',\n    'jquery/editableMultiselect/js/jquery.editable',\n    'jquery/editableMultiselect/js/jquery.multiselect'\n], function ($, alert, confirm) {\n    /**\n     * Editable multiselect wrapper for multiselects\n     * This class is defined in global scope ('var' is not needed).\n     *\n     *  @param {Object} settings - settings object.\n     *  @param {String} settings.add_button_caption - caption of the 'Add New Value' button\n     *  @param {String} settings.new_url - URL to which new request has to be submitted\n     *  @param {String} settings.save_url - URL to which save request has to be submitted\n     *  @param {String} settings.delete_url - URL to which delete request has to be submitted\n     *  @param {String} settings.delete_confirm_message - confirmation message that is shown to user during\n     *      delete operation\n     *  @param {String} settings.target_select_id - HTML ID of target select element\n     *  @param {Hash} settings.submit_data - extra parameters to send with new/edit/delete requests\n     *  @param {String} settings.entity_value_name - name of the request parameter that represents select option text\n     *  @param {String} settings.entity_id_name - name of the request parameter that represents select option value\n     *  @param {Boolean} settings.is_entry_editable - flag that shows if user can add/edit/remove data\n     *\n     * @constructor\n     */\n    window.EditableMultiselect = function (settings) {\n\n        this.settings = settings || {};\n        this.addButtonCaption = this.settings['add_button_caption'] || 'Add new value';\n        this.newUrl = this.settings['new_url'];\n        this.saveUrl = this.settings['save_url'];\n        this.deleteUrl = this.settings['delete_url'];\n        this.deleteConfirmMessage = this.settings['delete_confirm_message'];\n        this.targetSelectId = this.settings['target_select_id'];\n        this.submitData = this.settings['submit_data'] || {};\n        this.entityIdName = this.settings['entity_id_name'] || 'entity_id';\n        this.entityValueName = this.settings['entity_value_name'] || 'entity_value';\n        this.isEntityEditable = this.settings['is_entity_editable'] || false;\n\n        /**\n         * Initialize editable multiselect (make it visible in UI)\n         */\n        EditableMultiselect.prototype.init = function () {\n            var self = this,\n                mselectOptions = {\n                    addText: this.addButtonCaption,\n\n                    /**\n                     * @param {*} value\n                     * @param {*} options\n                     */\n                    mselectInputSubmitCallback: function (value, options) {\n                        self.createEntity(value, options);\n                    }\n                },\n                mselectList;\n\n            if (!this.isEntityEditable) {\n                // Override default layout of editable multiselect\n                mselectOptions.layout = '<section class=\"block %mselectListClass%\">' +\n                    '<div class=\"block-content\"><div class=\"%mselectItemsWrapperClass%\">' +\n                    '%items%' +\n                    '</div></div>' +\n                    '<div class=\"%mselectInputContainerClass%\">' +\n                    '<input type=\"text\" class=\"%mselectInputClass%\" title=\"%inputTitle%\"/>' +\n                    '<span class=\"%mselectButtonCancelClass%\" title=\"%cancelText%\"></span>' +\n                    '<span class=\"%mselectButtonSaveClass%\" title=\"Add\"></span>' +\n                    '</div>' +\n                    '</section>';\n            }\n\n            $('#' + this.targetSelectId).multiselect(mselectOptions);\n\n            // Make multiselect editable if needed\n            if (this.isEntityEditable) {\n                this.makeMultiselectEditable();\n\n                // Root element of HTML markup that represents select element in UI\n                mselectList = $('#' + this.targetSelectId).next();\n                this.attachEventsToControls(mselectList);\n            }\n        };\n\n        /**\n         * Attach required event handlers to control elements of editable multiselect\n         *\n         * @param {Object} mselectList\n         */\n        EditableMultiselect.prototype.attachEventsToControls = function (mselectList) {\n            mselectList.on('click.mselect-delete', '.mselect-delete', {\n                container: this\n            }, function (event) {\n                // Pass the clicked button to container\n                event.data.container.deleteEntity({\n                    'delete_button': this\n                });\n            });\n\n            mselectList.on('click.mselect-checked', '.mselect-list-item input', {\n                container: this\n            }, function (event) {\n                var el = $(this),\n                    checkedClassName = 'mselect-checked';\n\n                el[el.is(':checked') ? 'addClass' : 'removeClass'](checkedClassName);\n                event.data.container.makeMultiselectEditable();\n            });\n\n            mselectList.on('click.mselect-edit', '.mselect-edit', {\n                container: this\n            }, function (event) {\n                event.data.container.makeMultiselectEditable();\n                $(this).parent().find('label span').trigger('dblclick');\n            });\n        };\n\n        /**\n         * Make multiselect editable\n         */\n        EditableMultiselect.prototype.makeMultiselectEditable = function () {\n            var entityIdName = this.entityIdName,\n                entityValueName = this.entityValueName,\n                selectList = $('#' + this.targetSelectId).next();\n\n            selectList.find('.mselect-list-item:not(.mselect-list-item-not-editable) label span').editable(this.saveUrl,\n            {\n                type: 'text',\n                submit: '<button class=\"mselect-save\" title=\"Save\" type=\"submit\" />',\n                cancel: '<span class=\"mselect-cancel\" title=\"Cancel\"></span>',\n                event: 'dblclick',\n                placeholder: '',\n\n                /**\n                 * Is checked.\n                 */\n                isChecked: function () {\n                    var that = $(this),\n                        checked;\n\n                    if (!that.closest('.mselect-list-item').hasClass('mselect-disabled')) {\n                        checked = that.parent().find('[type=checkbox]').prop('disabled');\n                        that.parent().find('[type=checkbox]').prop({\n                            disabled: !checked\n                        });\n                    }\n                },\n\n                /**\n                 * @param {*} value\n                 * @param {Object} sett\n                 * @return {*}\n                 */\n                data: function (value, sett) {\n                    var retval;\n\n                    sett.isChecked.apply(this, [sett]);\n\n                    if (typeof value === 'string') {\n                        retval = value.unescapeHTML();\n\n                        return retval;\n                    }\n\n                    return value;\n                },\n                submitdata: this.submitData,\n                onblur: 'cancel',\n                name: entityValueName,\n                ajaxoptions: {\n                    dataType: 'json'\n                },\n\n                /**\n                 * @param {Object} sett\n                 * @param {*} original\n                 */\n                onsubmit: function (sett, original) {\n                    var select = $(original).closest('.mselect-list').prev(),\n                        current = $(original).closest('.mselect-list-item').index(),\n                        entityId = select.find('option').eq(current).val(),\n                        entityInfo = {};\n\n                    entityInfo[entityIdName] = entityId;\n                    sett.submitdata = $.extend(sett.submitdata || {}, entityInfo);\n                },\n\n                /**\n                 * @param {Object} result\n                 * @param {Object} sett\n                 */\n                callback: function (result, sett) {\n                    var select, current;\n\n                    sett.isChecked.apply(this, [sett]);\n                    select = $(this).closest('.mselect-list').prev();\n                    current = $(this).closest('.mselect-list-item').index();\n\n                    if (result.success) {\n                        if (typeof result[entityValueName] === 'string') {\n                            select.find('option').eq(current).val(result[entityIdName]).text(result[entityValueName]);\n                            $(this).html(result[entityValueName].escapeHTML());\n                        }\n                    } else {\n                        alert({\n                            content: result['error_message']\n                        });\n                    }\n                }\n            });\n        };\n\n        /**\n         * Callback function that is called when admin adds new value to select\n         *\n         * @param {*} value\n         * @param {Object} options - list of settings of multiselect\n         */\n        EditableMultiselect.prototype.createEntity = function (value, options) {\n            var select, entityIdName, entityValueName, entityInfo, postData, ajaxOptions;\n\n            if (!value) {\n                return;\n            }\n\n            select = $('#' + this.targetSelectId),\n            entityIdName = this.entityIdName,\n            entityValueName = this.entityValueName,\n            entityInfo = {};\n            entityInfo[entityIdName] = null;\n            entityInfo[entityValueName] = value;\n\n            postData = $.extend(entityInfo, this.submitData);\n\n            ajaxOptions = {\n                type: 'POST',\n                data: postData,\n                dataType: 'json',\n                url: this.newUrl,\n\n                /**\n                 * @param {Object} result\n                 */\n                success: function (result) {\n                    var resultEntityValueName, mselectItemHtml, sectionBlock, itemsWrapper, inputSelector;\n\n                    if (result.success) {\n                        resultEntityValueName = '';\n\n                        if (typeof result[entityValueName] === 'string') {\n                            resultEntityValueName = result[entityValueName].escapeHTML();\n                        } else {\n                            resultEntityValueName = result[entityValueName];\n                        }\n                        // Add item to initial select element\n                        select.append('<option value=\"' + result[entityIdName] + '\" selected=\"selected\">' +\n                        resultEntityValueName + '</option>');\n                        // Add editable multiselect item\n                        mselectItemHtml = $(options.item.replace(/%value%|%label%/gi, resultEntityValueName)\n                                .replace(/%mselectDisabledClass%|%iseditable%|%isremovable%/gi, '')\n                                .replace(/%mselectListItemClass%/gi, options.mselectListItemClass))\n                                .find('[type=checkbox]')\n                                .attr('checked', true)\n                                .addClass(options.mselectCheckedClass)\n                                .end();\n                        sectionBlock = select.nextAll('section.block:first');\n                        itemsWrapper = sectionBlock.find('.' + options.mselectItemsWrapperClass + '');\n\n                        if (itemsWrapper.children('.' + options.mselectListItemClass + '').length) {\n                            itemsWrapper.children('.' + options.mselectListItemClass + ':last').after(mselectItemHtml);\n                        } else {\n                            itemsWrapper.prepend(mselectItemHtml);\n                        }\n                        // Trigger blur event on input field, that is used to add new value, to hide it\n                        inputSelector = '.' + options.mselectInputContainerClass + ' [type=text].' +\n                            options.mselectInputClass + '';\n                        sectionBlock.find(inputSelector).trigger('blur');\n                    } else {\n                        alert({\n                            content: result['error_message']\n                        });\n                    }\n                }\n            };\n            $.ajax(ajaxOptions);\n        };\n\n        /**\n         * Callback function that is called when user tries to delete value from select\n         *\n         * @param {Object} options\n         */\n        EditableMultiselect.prototype.deleteEntity = function (options) {\n            var self = this;\n\n            if (options['delete_button']) {\n                confirm({\n                    content: this.deleteConfirmMessage,\n                    actions: {\n                        /**\n                         * Confirm.\n                         */\n                        confirm: function () {\n                            // Button that has been clicked\n                            var deleteButton = $(options['delete_button']),\n                                index = deleteButton.parent().index(),\n                                select = deleteButton.closest('.mselect-list').prev(),\n                                entityId = select.find('option').eq(index).val(),\n                                entityInfo = {},\n                                postData, ajaxOptions;\n\n                            entityInfo[self.entityIdName] = entityId;\n                            postData = $.extend(entityInfo, self.submitData);\n\n                            ajaxOptions = {\n                                type: 'POST',\n                                data: postData,\n                                dataType: 'json',\n                                url: self.deleteUrl,\n\n                                /**\n                                 * @param {Object} result\n                                 */\n                                success: function (result) {\n                                    if (result.success) {\n                                        deleteButton.parent().remove();\n                                        select.find('option').eq(index).remove();\n                                    } else {\n                                        alert({\n                                            content: result['error_message']\n                                        });\n                                    }\n                                }\n                            };\n                            $.ajax(ajaxOptions);\n                        }\n                    }\n                });\n            }\n        };\n    };\n});\n","mage/backend/tree-suggest.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'jquery/ui',\n    'jquery/jstree/jquery.jstree',\n    'mage/backend/suggest'\n], function ($) {\n    'use strict';\n\n    /* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */\n    var hover_node, dehover_node, select_node, init;\n\n    $.extend(true, $, {\n        // @TODO: Move method 'treeToList' in file with utility functions\n        mage: {\n            /**\n             * @param {Array} list\n             * @param {Object} nodes\n             * @param {*} level\n             * @param {*} path\n             * @return {*}\n             */\n            treeToList: function (list, nodes, level, path) {\n                $.each(nodes, function () {\n                    if ($.type(this) === 'object') {\n                        list.push({\n                            label: this.label,\n                            id: this.id,\n                            level: level,\n                            item: this,\n                            path: path + this.label\n                        });\n\n                        if (this.children) {\n                            $.mage.treeToList(list, this.children, level + 1, path + this.label + ' / ');\n                        }\n                    }\n                });\n\n                return list;\n            }\n        }\n    });\n\n    hover_node = $.jstree._instance.prototype.hover_node;\n    dehover_node = $.jstree._instance.prototype.dehover_node;\n    select_node = $.jstree._instance.prototype.select_node;\n    init = $.jstree._instance.prototype.init;\n\n    $.extend(true, $.jstree._instance.prototype, {\n        /**\n         * @override\n         */\n        init: function () {\n            this.get_container()\n                .show()\n                .on('keydown', $.proxy(function (e) {\n                    var o;\n\n                    if (e.keyCode === $.ui.keyCode.ENTER) {\n                        o = this.data.ui.hovered || this.data.ui.last_selected || -1;\n                        this.select_node(o, true);\n                    }\n                }, this));\n            init.call(this);\n        },\n\n        /**\n         * @override\n         */\n        hover_node: function (obj) {\n            hover_node.apply(this, arguments);\n            obj = this._get_node(obj);\n\n            if (!obj.length) {\n                return false;\n            }\n            this.get_container().trigger('hover_node', [{\n                item: obj.find('a:first')\n            }]);\n        },\n\n        /**\n         * @override\n         */\n        dehover_node: function () {\n            dehover_node.call(this);\n            this.get_container().trigger('dehover_node');\n        },\n\n        /**\n         * @override\n         */\n        select_node: function (o) {\n            var node;\n\n            select_node.apply(this, arguments);\n            node = this._get_node(o);\n\n            (node ? $(node) : this.data.ui.last_selected)\n                .trigger('select_tree_node');\n        }\n    });\n\n    $.widget('mage.treeSuggest', $.mage.suggest, {\n        widgetEventPrefix: 'suggest',\n        options: {\n            template:\n                '<% if (data.items.length) { %>' +\n                    '<% if (data.allShown()) { %>' +\n                        '<% if (typeof data.nested === \"undefined\") { %>' +\n                            '<div style=\"display:none;\" data-mage-init=\"{&quot;jstree&quot;:{&quot;plugins&quot;:[&quot;themes&quot;,&quot;html_data&quot;,&quot;ui&quot;,&quot;hotkeys&quot;],&quot;themes&quot;:{&quot;theme&quot;:&quot;default&quot;,&quot;dots&quot;:false,&quot;icons&quot;:false}}}\">' + //eslint-disable-line max-len\n                        '<% } %>' +\n                        '<ul>' +\n                            '<% _.each(data.items, function(value) { %>' +\n                                '<li class=\"<% if (data.itemSelected(value)) { %>mage-suggest-selected<% } %>' +\n                '                   <% if (value.is_active == 0) { %> mage-suggest-not-active<% } %>\">' +\n                                    '<a href=\"#\" <%= data.optionData(value) %>><%- value.label %></a>' +\n                                    '<% if (value.children && value.children.length) { %>' +\n                                        '<%= data.renderTreeLevel(value.children) %>' +\n                                    '<% } %>' +\n                                '</li>' +\n                            '<% }); %>' +\n                        '</ul>' +\n                        '<% if (typeof data.nested === \"undefined\") { %>' +\n                            '</div>' +\n                        '<% } %>' +\n                    '<% } else { %>' +\n                        '<ul data-mage-init=\"{&quot;menu&quot;:[]}\">' +\n                            '<% _.each(data.items, function(value) { %>' +\n                                '<% if (!data.itemSelected(value)) {%>' +\n                                    '<li <%= data.optionData(value) %>>' +\n                                        '<a href=\"#\">' +\n                                            '<span class=\"category-label\"><%- value.label %></span>' +\n                                            '<span class=\"category-path\"><%- value.path %></span>' +\n                                        '</a>' +\n                                    '</li>' +\n                                '<% } %>' +\n                            '<% }); %>' +\n                        '</ul>' +\n                    '<% } %>' +\n                '<% } else { %>' +\n                    '<span class=\"mage-suggest-no-records\"><%- data.noRecordsText %></span>' +\n                '<% } %>',\n            controls: {\n                selector: ':ui-menu, :mage-menu, .jstree',\n                eventsMap: {\n                    focus: ['menufocus', 'hover_node'],\n                    blur: ['menublur', 'dehover_node'],\n                    select: ['menuselect', 'select_tree_node']\n                }\n            }\n        },\n\n        /**\n         * @override\n         */\n        _bind: function () {\n            this._super();\n            this._on({\n                /**\n                 * @param {jQuery.Event} event\n                 */\n                keydown: function (event) {\n                    var keyCode = $.ui.keyCode;\n\n                    switch (event.keyCode) {\n                        case keyCode.LEFT:\n                        case keyCode.RIGHT:\n\n                            if (this.isDropdownShown()) {\n                                event.preventDefault();\n                                this._proxyEvents(event);\n                            }\n                            break;\n                    }\n                }\n            });\n        },\n\n        /**\n         * @override\n         */\n        close: function (e) {\n            var eType = e ? e.type : null;\n\n            if (eType === 'select_tree_node') {\n                this.element.focus();\n            } else {\n                this._superApply(arguments);\n            }\n        },\n\n        /**\n         * @override\n         */\n        _filterSelected: function (items, context) {\n            if (context._allShown) {\n                return items;\n            }\n\n            return this._superApply(arguments);\n        },\n\n        /**\n         * @override\n         */\n        _prepareDropdownContext: function () {\n            var context = this._superApply(arguments),\n                optionData = context.optionData,\n                templates = this.templates,\n                tmplName = this.templateName;\n\n            /**\n             * @param {Object} item\n             * @return {*|String}\n             */\n            context.optionData = function (item) {\n                item = $.extend({}, item);\n                delete item.children;\n\n                return optionData(item);\n            };\n\n            return $.extend(context, {\n                /**\n                 * @param {*} children\n                 * @return {*|jQuery}\n                 */\n                renderTreeLevel: function (children) {\n                    var _context = $.extend({}, this, {\n                        items: children,\n                        nested: true\n                    }),\n                    tmpl = templates[tmplName];\n\n                    tmpl = tmpl({\n                        data: _context\n                    });\n\n                    return $('<div>').append($(tmpl)).html();\n                }\n            });\n        },\n\n        /**\n         * @override\n         */\n        _processResponse: function (e, items, context) {\n            var control;\n\n            if (context && !context._allShown) {\n                items = this.filter($.mage.treeToList([], items, 0, ''), this._term);\n            }\n            control = this.dropdown.find(this._control.selector);\n\n            if (control.length && control.hasClass('jstree')) {\n                control.jstree('destroy');\n            }\n            this._superApply([e, items, context]);\n        }\n    });\n\n    return $.mage.treeSuggest;\n});\n","mage/view/composite.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\n/* eslint-disable strict */\ndefine(['jquery'], function ($) {\n    return function () {\n        var renderedChildren = {},\n            children = {};\n\n        return {\n            /**\n             * @param {*} child\n             * @param {String} key\n             */\n            addChild: function (child, key) {\n                children[key] = child;\n            },\n\n            /**\n             * @param {*} root\n             */\n            render: function (root) {\n                $.each(children, function (key, child) {\n                    var childRoot = $('<div>');\n\n                    renderedChildren[key] = child.render(childRoot);\n                    root.append(childRoot);\n                });\n            }\n        };\n    };\n});\n","Magento_AdobeStockAdminUi/js/connection.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'ko',\n    'uiComponent',\n    'jquery'\n], function (ko, Component, $) {\n    'use strict';\n\n    return Component.extend({\n        defaults: {\n            template: 'Magento_AdobeStockAdminUi/connection',\n            connectionFailedMessage: 'Connection test failed.',\n            emptyApiKeyMessage: 'Please fill the \"API Key (Client ID)\" field for a connection test',\n            apiKeyInputId: 'system_adobe_stock_integration_api_key',\n            url: '',\n            success: false,\n            message: '',\n            visible: false\n        },\n\n        /**\n         * Init observable variables\n         * @return {Object}\n         */\n        initObservable: function () {\n            this._super()\n                .observe([\n                    'success',\n                    'message',\n                    'visible'\n                ]);\n\n            return this;\n        },\n\n        /**\n         * @override\n         */\n        initialize: function () {\n            this._super();\n            this.messageClass = ko.computed(function () {\n                return 'message-validation message message-' + (this.success() ? 'success' : 'error');\n            }, this);\n\n            if (!this.success()) {\n                this.showMessage(false, this.connectionFailedMessage);\n            }\n        },\n\n        /**\n         * @param {bool} success\n         * @param {String} message\n         */\n        showMessage: function (success, message) {\n            this.message(message);\n            this.success(success);\n            this.visible(true);\n        },\n\n        /**\n         * Send request to server to test connection to Adobe Stock API and display the result\n         */\n        testConnection: function () {\n            var apiKey = document.getElementById(this.apiKeyInputId).value;\n\n            if (apiKey.length === 0) {\n                this.showMessage(false, this.emptyApiKeyMessage);\n\n                return;\n            }\n\n            this.visible(false);\n\n            $.ajax({\n                type: 'POST',\n                url: this.url,\n                dataType: 'json',\n                data: {\n                    'api_key': apiKey\n                },\n                success: function (response) {\n                    this.showMessage(response.success === true, response.message);\n                }.bind(this),\n                error: function () {\n                    this.showMessage(false, this.connectionFailedMessage);\n                }.bind(this)\n            });\n        }\n    });\n});\n","Magento_Rule/rules.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @api\n */\n\ndefine([\n    'jquery',\n    'Magento_Ui/js/modal/alert',\n    'mage/translate',\n    'prototype'\n], function (jQuery) {\n    'use strict';\n\n    var VarienRulesForm = new Class.create();\n\n    VarienRulesForm.prototype = {\n        initialize: function (parent, newChildUrl) {\n            this.parent = $(parent);\n            this.newChildUrl  = newChildUrl;\n            this.shownElement = null;\n            this.updateElement = null;\n            this.chooserSelectedItems = $H({});\n            this.readOnly = false;\n\n            var elems = this.parent.getElementsByClassName('rule-param');\n\n            for (var i = 0; i < elems.length; i++) {\n                this.initParam(elems[i]);\n            }\n        },\n\n        setReadonly: function (readonly) {\n            this.readOnly = readonly;\n            var elems = this.parent.getElementsByClassName('rule-param-remove');\n\n            for (var i = 0; i < elems.length; i++) {\n                var element = elems[i];\n\n                if (this.readOnly) {\n                    element.hide();\n                } else {\n                    element.show();\n                }\n            }\n\n            var elems = this.parent.getElementsByClassName('rule-param-new-child');\n\n            for (var i = 0; i < elems.length; i++) {\n                var element = elems[i];\n\n                if (this.readOnly) {\n                    element.hide();\n                } else {\n                    element.show();\n                }\n            }\n\n            var elems = this.parent.getElementsByClassName('rule-param');\n\n            for (var i = 0; i < elems.length; i++) {\n                var container = elems[i];\n                var label = Element.down(container, '.label');\n\n                if (label) {\n                    if (this.readOnly) {\n                        label.addClassName('label-disabled');\n                    } else {\n                        label.removeClassName('label-disabled');\n                    }\n                }\n            }\n        },\n\n        initParam: function (container) {\n            container.rulesObject = this;\n            var label = Element.down(container, '.label');\n\n            if (label) {\n                Event.observe(label, 'click', this.showParamInputField.bind(this, container));\n            }\n\n            var elem = Element.down(container, '.element');\n\n            if (elem) {\n                var trig = elem.down('.rule-chooser-trigger');\n\n                if (trig) {\n                    Event.observe(trig, 'click', this.toggleChooser.bind(this, container));\n                }\n\n                var apply = elem.down('.rule-param-apply');\n\n                if (apply) {\n                    Event.observe(apply, 'click', this.hideParamInputField.bind(this, container));\n                } else {\n                    elem = elem.down('.element-value-changer');\n                    elem.container = container;\n\n                    if (!elem.multiple) {\n                        Event.observe(elem, 'change', this.hideParamInputField.bind(this, container));\n\n                        this.changeVisibilityForValueRuleParam(elem);\n\n                    }\n                    Event.observe(elem, 'blur', this.hideParamInputField.bind(this, container));\n                }\n            }\n\n            var remove = Element.down(container, '.rule-param-remove');\n\n            if (remove) {\n                Event.observe(remove, 'click', this.removeRuleEntry.bind(this, container));\n            }\n        },\n\n        showChooserElement: function (chooser) {\n            this.chooserSelectedItems = $H({});\n\n            if (chooser.hasClassName('no-split')) {\n                this.chooserSelectedItems.set(this.updateElement.value, 1);\n            } else {\n                var values = this.updateElement.value.split(','),\n s = '';\n\n                for (var i = 0; i < values.length; i++) {\n                    s = values[i].strip();\n\n                    if (s != '') {\n                        this.chooserSelectedItems.set(s, 1);\n                    }\n                }\n            }\n            new Ajax.Request(chooser.getAttribute('url'), {\n                evalScripts: true,\n                parameters: {\n                    'form_key': FORM_KEY, 'selected[]': this.chooserSelectedItems.keys()\n                },\n                onSuccess: function (transport) {\n                    if (this._processSuccess(transport)) {\n                        jQuery(chooser).html(transport.responseText);\n                        this.showChooserLoaded(chooser, transport);\n                        jQuery(chooser).trigger('contentUpdated');\n                    }\n                }.bind(this),\n                onFailure: this._processFailure.bind(this)\n            });\n        },\n\n        showChooserLoaded: function (chooser, transport) {\n            chooser.style.display = 'block';\n        },\n\n        showChooser: function (container, event) {\n            var chooser = container.up('li');\n\n            if (!chooser) {\n                return;\n            }\n            chooser = chooser.down('.rule-chooser');\n\n            if (!chooser) {\n                return;\n            }\n            this.showChooserElement(chooser);\n        },\n\n        hideChooser: function (container, event) {\n            var chooser = container.up('li');\n\n            if (!chooser) {\n                return;\n            }\n            chooser = chooser.down('.rule-chooser');\n\n            if (!chooser) {\n                return;\n            }\n            chooser.style.display = 'none';\n        },\n\n        toggleChooser: function (container, event) {\n            if (this.readOnly) {\n                return false;\n            }\n\n            var chooser = container.up('li').down('.rule-chooser');\n\n            if (!chooser) {\n                return;\n            }\n\n            if (chooser.style.display == 'block') {\n                chooser.style.display = 'none';\n                this.cleanChooser(container, event);\n            } else {\n                this.showChooserElement(chooser);\n            }\n        },\n\n        cleanChooser: function (container, event) {\n            var chooser = container.up('li').down('.rule-chooser');\n\n            if (!chooser) {\n                return;\n            }\n            chooser.innerHTML = '';\n        },\n\n        showParamInputField: function (container, event) {\n            if (this.readOnly) {\n                return false;\n            }\n\n            if (this.shownElement) {\n                this.hideParamInputField(this.shownElement, event);\n            }\n\n            Element.addClassName(container, 'rule-param-edit');\n            var elemContainer = Element.down(container, '.element');\n\n            var elem = Element.down(elemContainer, 'input.input-text');\n\n            jQuery(elem).trigger('contentUpdated');\n\n            if (elem) {\n                elem.focus();\n\n                if (elem && elem.id && elem.id.match(/__value$/)) {\n                    this.updateElement = elem;\n                }\n\n            }\n\n            var elem = Element.down(elemContainer, '.element-value-changer');\n\n            if (elem) {\n                elem.focus();\n            }\n\n            this.shownElement = container;\n        },\n\n        hideParamInputField: function (container, event) {\n            Element.removeClassName(container, 'rule-param-edit');\n            var label = Element.down(container, '.label'),\n elem;\n\n            if (!container.hasClassName('rule-param-new-child')) {\n                elem = Element.down(container, '.element-value-changer');\n\n                if (elem && elem.options) {\n                    var selectedOptions = [];\n\n                    for (var i = 0; i < elem.options.length; i++) {\n                        if (elem.options[i].selected) {\n                            selectedOptions.push(elem.options[i].text);\n                        }\n                    }\n\n                    var str = selectedOptions.join(', ');\n\n                    label.innerHTML = str != '' ? str : '...';\n                }\n\n                this.changeVisibilityForValueRuleParam(elem);\n\n                elem = Element.down(container, 'input.input-text');\n\n                if (elem) {\n                    var str = elem.value.replace(/(^\\s+|\\s+$)/g, '');\n\n                    elem.value = str;\n\n                    if (str == '') {\n                        str = '...';\n                    } else if (str.length > 30) {\n                        str = str.substr(0, 30) + '...';\n                    }\n                    label.innerHTML = str.escapeHTML();\n                }\n            } else {\n                elem = container.down('.element-value-changer');\n\n                if (elem.value) {\n                    this.addRuleNewChild(elem);\n                }\n                elem.value = '';\n            }\n\n            if (elem && elem.id && elem.id.match(/__value$/)) {\n                this.hideChooser(container, event);\n                this.updateElement = null;\n            }\n\n            this.shownElement = null;\n        },\n\n        changeVisibilityForValueRuleParam: function(elem) {\n            var parsedElementId = elem.id.split('__');\n            if (parsedElementId[2] !== 'operator') {\n                return false;\n            }\n\n            var valueElement = jQuery('#' + parsedElementId[0] + '__' + parsedElementId[1] + '__value');\n\n            if(elem.value === '<=>') {\n                valueElement.closest('.rule-param').hide();\n            } else {\n                valueElement.closest('.rule-param').show();\n            }\n\n            return true;\n        },\n\n        addRuleNewChild: function (elem) {\n            var parent_id = elem.id.replace(/^.*__(.*)__.*$/, '$1');\n            var children_ul_id = elem.id.replace(/__/g, ':').replace(/[^:]*$/, 'children').replace(/:/g, '__');\n            var children_ul = $(this.parent).select('#' + children_ul_id)[0];\n            var max_id = 0,\n i;\n            var children_inputs = Selector.findChildElements(children_ul, $A(['input.hidden']));\n\n            if (children_inputs.length) {\n                children_inputs.each(function (el) {\n                    if (el.id.match(/__type$/)) {\n                        i = 1 * el.id.replace(/^.*__.*?([0-9]+)__.*$/, '$1');\n                        max_id = i > max_id ? i : max_id;\n                    }\n                });\n            }\n            var new_id = parent_id + '--' + (max_id + 1);\n            var new_type = elem.value;\n            var new_elem = document.createElement('LI');\n\n            new_elem.className = 'rule-param-wait';\n            new_elem.innerHTML = jQuery.mage.__('This won\\'t take long . . .');\n            children_ul.insertBefore(new_elem, $(elem).up('li'));\n\n            new Ajax.Request(this.newChildUrl, {\n                evalScripts: true,\n                parameters: {\n                    form_key: FORM_KEY, type: new_type.replace('/', '-'), id: new_id\n                },\n                onComplete: this.onAddNewChildComplete.bind(this, new_elem),\n                onSuccess: function (transport) {\n                    if (this._processSuccess(transport)) {\n                        $(new_elem).update(transport.responseText);\n                    }\n                }.bind(this),\n                onFailure: this._processFailure.bind(this)\n            });\n        },\n\n        _processSuccess: function (transport) {\n            if (transport.responseText.isJSON()) {\n                var response = transport.responseText.evalJSON();\n\n                if (response.error) {\n                    alert(response.message);\n                }\n\n                if (response.ajaxExpired && response.ajaxRedirect) {\n                    setLocation(response.ajaxRedirect);\n                }\n\n                return false;\n            }\n\n            return true;\n        },\n\n        _processFailure: function (transport) {\n            location.href = BASE_URL;\n        },\n\n        onAddNewChildComplete: function (new_elem) {\n            if (this.readOnly) {\n                return false;\n            }\n\n            $(new_elem).removeClassName('rule-param-wait');\n            var elems = new_elem.getElementsByClassName('rule-param');\n\n            for (var i = 0; i < elems.length; i++) {\n                this.initParam(elems[i]);\n            }\n        },\n\n        removeRuleEntry: function (container, event) {\n            var li = Element.up(container, 'li');\n\n            li.parentNode.removeChild(li);\n        },\n\n        chooserGridInit: function (grid) {\n            //grid.reloadParams = {'selected[]':this.chooserSelectedItems.keys()};\n        },\n\n        chooserGridRowInit: function (grid, row) {\n            if (!grid.reloadParams) {\n                grid.reloadParams = {\n                    'selected[]': this.chooserSelectedItems.keys()\n                };\n            }\n        },\n\n        chooserGridRowClick: function (grid, event) {\n            var trElement = Event.findElement(event, 'tr');\n            var isInput = Event.element(event).tagName == 'INPUT';\n\n            if (trElement) {\n                var checkbox = Element.select(trElement, 'input');\n\n                if (checkbox[0]) {\n                    var checked = isInput ? checkbox[0].checked : !checkbox[0].checked;\n\n                    grid.setCheckboxChecked(checkbox[0], checked);\n\n                }\n            }\n        },\n\n        chooserGridCheckboxCheck: function (grid, element, checked) {\n            if (checked) {\n                if (!element.up('th')) {\n                    this.chooserSelectedItems.set(element.value, 1);\n                }\n            } else {\n                this.chooserSelectedItems.unset(element.value);\n            }\n            grid.reloadParams = {\n                'selected[]': this.chooserSelectedItems.keys()\n            };\n            this.updateElement.value = this.chooserSelectedItems.keys().join(', ');\n        }\n    };\n\n    return VarienRulesForm;\n});\n","Magento_Rule/conditions-data-normalizer.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'jquery',\n    'underscore'\n], function ($, _) {\n    'use strict';\n\n    /**\n     * @constructor\n     */\n    var ConditionsDataNormalizer = function () {\n        this.patterns = {\n            validate: /^[a-z0-9_.-][a-z0-9_.-]*(?:\\[(?:\\d*|[a-z0-9_.-]+)\\])*$/i,\n            key: /[a-z0-9_.-]+|(?=\\[\\])/gi,\n            push: /^$/,\n            fixed: /^\\d+$/,\n            named: /^[a-z0-9_.-]+$/i\n        };\n    };\n\n    ConditionsDataNormalizer.prototype = {\n        /**\n         * Will convert an object:\n         * {\n         *   \"foo[bar][1][baz]\": 123,\n         *   \"foo[bar][1][blah]\": 321\n         *   \"foo[bar][1--1][ah]\": 456\n         * }\n         *\n         * to\n         * {\n         *   \"foo\": {\n         *     \"bar\": {\n         *       \"1\": {\n         *         \"baz\": 123,\n         *         \"blah\": 321\n         *       },\n         *       \"1--1\": {\n         *         \"ah\": 456\n         *       }\n         *     }\n         *   }\n         * }\n         */\n        normalize: function normalize(value) {\n            var el, _this = this;\n\n            this.pushes = {};\n            this.data = {};\n\n            _.each(value, function (e, i) {\n                el = {};\n                el[i] = e;\n\n                _this._addPair({\n                    name: i,\n                    value: e\n                });\n            });\n\n            return this.data;\n        },\n\n        /**\n         * @param {Object} base\n         * @param {String} key\n         * @param {String} value\n         * @return {Object}\n         * @private\n         */\n        _build: function build(base, key, value) {\n            base[key] = value;\n\n            return base;\n        },\n\n        /**\n         * @param {Object} root\n         * @param {String} value\n         * @return {*}\n         * @private\n         */\n        _makeObject: function makeObject(root, value) {\n            var keys = root.match(this.patterns.key),\n                k, idx; // nest, nest, ..., nest\n\n            while ((k = keys.pop()) !== undefined) {\n                // foo[]\n                if (this.patterns.push.test(k)) {\n                    idx = this._incrementPush(root.replace(/\\[\\]$/, ''));\n                    value = this._build([], idx, value);\n                } // foo[n]\n                else if (this.patterns.fixed.test(k)) {\n                    value = this._build({}, k, value);\n                } // foo; foo[bar]\n                else if (this.patterns.named.test(k)) {\n                    value = this._build({}, k, value);\n                }\n            }\n\n            return value;\n        },\n\n        /**\n         * @param {String} key\n         * @return {Number}\n         * @private\n         */\n        _incrementPush: function incrementPush(key) {\n            if (this.pushes[key] === undefined) {\n                this.pushes[key] = 0;\n            }\n\n            return this.pushes[key]++;\n        },\n\n        /**\n         * @param {Object} pair\n         * @return {Object}\n         * @private\n         */\n        _addPair: function addPair(pair) {\n            var obj = this._makeObject(pair.name, pair.value);\n\n            if (!this.patterns.validate.test(pair.name)) {\n                return this;\n            }\n\n            this.data = $.extend(true, this.data, obj);\n\n            return this;\n        }\n    };\n\n    return ConditionsDataNormalizer;\n});\n","Magento_Paypal/js/solutions.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'jquery',\n    'uiClass',\n    'Magento_Paypal/js/solution',\n    'underscore'\n], function ($, Class, Solution, _) {\n    'use strict';\n\n    return Class.extend({\n        defaults: {\n\n            /**\n             * Initialized solutions\n             */\n            solutions: {},\n\n            /**\n             * The elements of created solutions\n             */\n            solutionsElements: {},\n\n            /**\n             * The selector element responsible for configuration of payment method (CSS class)\n             */\n            buttonConfiguration: '.button.action-configure'\n        },\n\n        /**\n         * Constructor\n         *\n         * @param {Object} config\n         * @returns {exports.initialize}\n         */\n        initialize: function (config) {\n            this.initConfig(config)\n                .initSolutions();\n\n            return this;\n        },\n\n        /**\n         * Initialization and configuration solutions\n         *\n         * @returns {exports.initSolutions}\n         */\n        initSolutions: function () {\n            _.each(this.config.solutions, this.addSolution, this);\n            this.initializeSolutions()\n                .wipeButtonsConfiguration();\n            _.each(this.solutions, this.applicationRules);\n\n            return this;\n        },\n\n        /**\n         * The creation and addition of the solution according to the configuration\n         *\n         * @param {Object} solution\n         * @param {String} identifier\n         */\n        addSolution: function (solution, identifier) {\n            this.solutions[identifier] = new Solution({\n                config: solution,\n                buttonConfiguration: this.buttonConfiguration\n            }, identifier);\n            this.solutionsElements[identifier] = this.solutions[identifier].$self;\n        },\n\n        /**\n         * Wiping buttons configuration of the payment method\n         */\n        wipeButtonsConfiguration: function () {\n            $(this.buttonConfiguration).removeClass('disabled')\n                .removeAttr('disabled');\n        },\n\n        /**\n         * Application of the rules\n         *\n         * @param {Object} solution\n         */\n        applicationRules: function (solution) {\n            _.each(solution.afterLoadRules, function (rule) {\n                rule.apply();\n            });\n        },\n\n        /**\n         * Initialize solutions\n         *\n         * @returns {exports.initializeSolutions}\n         */\n        initializeSolutions: function () {\n            _.each(this.solutions, function (solution) {\n                solution.setSolutionsElements(this.solutionsElements)\n                    .initEvents()\n                    .addListeners();\n            }, this);\n\n            return this;\n        }\n    });\n});\n","Magento_Paypal/js/solution.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'jquery',\n    'uiClass',\n    'Magento_Paypal/js/rule',\n    'mageUtils',\n    'underscore'\n], function ($, Class, Rule, utils, _) {\n    'use strict';\n\n    return Class.extend({\n        defaults: {\n\n            /**\n             * The event corresponding to the state change\n             */\n            systemEvent: 'change',\n\n            /**\n             * The rules applied after the page is loaded\n             */\n            afterLoadRules: [],\n\n            /**\n             * An attribute of the element responsible for the activation of the payment method (data attribute)\n             */\n            enableButton:   '[data-enable=\"payment\"]',\n\n            /**\n             * An attribute of the element responsible for the activation of the Payflow Express (data attribute)\n             */\n            enableExpress:  '[data-enable=\"express\"]',\n\n            /**\n             * An attribute of the element responsible for the activation of the\n             * PayPal Express In-Context Checkout Experience (data attribute)\n             */\n            enableInContextPayPal: '[data-enable=\"in-context-api\"]',\n\n            /**\n             * An attribute of the element responsible for the activation of the Payflow Bml (data attribute)\n             */\n            enableBml:      '[data-enable=\"bml\"]',\n\n            /**\n             * An attribute of the element responsible for the activation of the PayPal Bml (data attribute)\n             */\n            enableBmlPayPal:      '[data-enable=\"bml-api\"]',\n\n            /**\n             * An attribute of the element responsible for the visibility of the PayPal Merchant Id (data attribute)\n             */\n            dependsMerchantId:  '[data-enable=\"merchant-id\"]',\n\n            /**\n             * An attribute of the element responsible for the visibility of the Payflow Bml Sort Order (data attribute)\n             */\n            dependsBmlSortOrder:    '[data-enable=\"bml-sort-order\"]',\n\n            /**\n             * An attribute of the element responsible for the visibility of the PayPal Bml Sort Order (data attribute)\n             */\n            dependsBmlApiSortOrder:    '[data-enable=\"bml-api-sort-order\"]',\n\n            /**\n             * An attribute of the element responsible for the visibility of the\n             * button Label credit option (data attribute)\n             */\n            dependsButtonLabel: '[data-enable=\"button-label\"]',\n\n            /**\n             * An attribute of the element responsible for the visibility of the\n             * button Label credit option on load (data attribute)\n             */\n            dependsDisableFundingOptions: '[data-enable=\"disable-funding-options\"]',\n\n            /**\n             * Templates element selectors\n             */\n            templates: {\n                elementSelector: 'div.section-config tr[id$=\"${ $.identifier }\"]:first'\n            }\n        },\n\n        /**\n         * Constructor\n         *\n         * @param {Object} config\n         * @param {String} identifier\n         * @returns {exports.initialize}\n         */\n        initialize: function (config, identifier) {\n            this.initConfig(config);\n            this.$self = this.createElement(identifier);\n\n            return this;\n        },\n\n        /**\n         * Initialization events\n         *\n         * @returns {exports.initEvents}\n         */\n        initEvents: function () {\n            _.each(this.config.events, function (elementEvents, selector) {\n\n                var solution = this,\n                    selectorButton = solution.$self.find(selector),\n                    $self = solution.$self,\n                    events = elementEvents;\n\n                selectorButton.on(solution.systemEvent, function () {\n                    _.each(events, function (elementEvent, name) {\n\n                        var predicate = elementEvent.predicate,\n                            result = true,\n\n                            /**\n                             * @param {Function} functionPredicate\n                             */\n                            predicateCallback = function (functionPredicate) {\n                                result = functionPredicate(solution, predicate.message, predicate.argument);\n\n                                if (result) {\n                                    $self.trigger(name);\n                                } else {\n                                    $self.trigger(predicate.event);\n                                }\n                            };\n\n                        if (solution.getValue($(this)) === elementEvent.value ||\n                            $(this).prop('multiple') && solution.checkMultiselectValue($(this), elementEvent)\n                        ) {\n                            if (predicate.name) {\n                                require([\n                                    'Magento_Paypal/js/predicate/' + predicate.name\n                                ], predicateCallback);\n                            } else {\n                                $self.trigger(name);\n                            }\n                        }\n                    }, this);\n                });\n            }, this);\n\n            return this;\n        },\n\n        /**\n         * @param {Object} $element\n         * @returns {*}\n         */\n        getValue: function ($element) {\n            if ($element.is(':checkbox')) {\n                return $element.prop('checked') ? '1' : '0';\n            }\n\n            return $element.val();\n        },\n\n        /**\n         * Check multiselect value based on include value\n         *\n         * @param {Object} $element\n         * @param {Object} elementEvent\n         * @returns {Boolean}\n         */\n        checkMultiselectValue: function ($element, elementEvent) {\n            var isValueSelected = $.inArray(elementEvent.value, $element.val()) >= 0;\n\n            if (elementEvent.include) {\n                isValueSelected = (isValueSelected ? 'true' : 'false') === elementEvent.include;\n            }\n\n            return isValueSelected;\n        },\n\n        /**\n         * Adding event listeners\n         *\n         * @returns {exports.addListeners}\n         */\n        addListeners: function () {\n\n            _.each(this.config.relations, function (rules, targetName) {\n\n                var $target = this.createElement(targetName);\n\n                _.each(rules, function (instances, instanceName) {\n\n                    _.each(instances, function (instance) {\n                        var handler = new Rule({\n                            name: instanceName,\n                            $target: $target,\n                            $owner: this.$self,\n                            data: {\n                                buttonConfiguration: this.buttonConfiguration,\n                                enableButton: this.enableButton,\n                                enableExpress: this.enableExpress,\n                                enableInContextPayPal: this.enableInContextPayPal,\n                                enableBml: this.enableBml,\n                                enableBmlPayPal: this.enableBmlPayPal,\n                                dependsMerchantId: this.dependsMerchantId,\n                                dependsBmlSortOrder: this.dependsBmlSortOrder,\n                                dependsBmlApiSortOrder: this.dependsBmlApiSortOrder,\n                                dependsButtonLabel: this.dependsButtonLabel,\n                                dependsDisableFundingOptions: this.dependsDisableFundingOptions,\n                                solutionsElements: this.solutionsElements,\n                                argument: instance.argument\n                            }\n                        });\n\n                        if (instance.event === ':load') {\n                            this.afterLoadRules.push(handler);\n\n                            return;\n                        }\n\n                        this.$self.on(instance.event, _.bind(handler.apply, handler));\n                    }, this);\n                }, this);\n            }, this);\n\n            return this;\n        },\n\n        /**\n         * Create a jQuery element according to selector\n         *\n         * @param {String} identifier\n         * @returns {*}\n         */\n        createElement: function (identifier) {\n            if (identifier === ':self') {\n                return this.$self;\n            }\n\n            return $(utils.template(this.templates.elementSelector, {\n                'identifier': identifier\n            }));\n        },\n\n        /**\n         * Assign solutions elements\n         *\n         * @param {Object} elements\n         * @returns {exports.setSolutionsElements}\n         */\n        setSolutionsElements: function (elements) {\n            this.solutionsElements = elements;\n\n            return this;\n        }\n    });\n});\n","Magento_Paypal/js/rules.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'uiClass',\n    'Magento_Ui/js/modal/alert'\n], function (Class, alert) {\n    'use strict';\n\n    /**\n     * Check is solution enabled\n     *\n     * @param {*} solution\n     * @param {String} enabler\n     * @returns {Boolean}\n     */\n    var isSolutionEnabled = function (solution, enabler) {\n            return solution.find(enabler).val() === '1';\n        },\n\n        /**\n         * Check is solution has related solutions enabled\n         *\n         * @param {Object} data\n         * @returns {Boolean}\n         */\n        hasRelationsEnabled = function (data) {\n            var name;\n\n            for (name in data.argument) {\n                if (\n                    data.solutionsElements[name] &&\n                    isSolutionEnabled(data.solutionsElements[name], data.enableButton)\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        /**\n         * Set solution select-enabler to certain option\n         *\n         * @param {*} solution\n         * @param {String} enabler\n         * @param {Boolean} enabled\n         */\n        setSolutionSelectEnabled = function (solution, enabler, enabled) {\n            enabled = !(enabled || typeof enabled === 'undefined') ? '0' : '1';\n\n            solution.find(enabler + ' option[value=' + enabled + ']')\n            .prop('selected', true);\n        },\n\n        /**\n         * Set solution property 'disabled' value\n         *\n         * @param {*} solution\n         * @param {String} enabler\n         * @param {Boolean} enabled\n         */\n        setSolutionPropEnabled = function (solution, enabler, enabled) {\n            enabled = !(enabled || typeof enabled === 'undefined');\n\n            solution.find(enabler).prop('disabled', enabled);\n        },\n\n        /**\n         * Set/unset solution select-enabler label\n         *\n         * @param {*} solution\n         * @param {String} enabler\n         * @param {Boolean} enabled\n         */\n        setSolutionMarkEnabled = function (solution, enabler, enabled) {\n            var solutionEnabler = solution.find('label[for=\"' + solution.find(enabler).attr('id') + '\"]');\n\n            enabled || typeof enabled === 'undefined' ?\n                solutionEnabler.addClass('enabled') :\n                solutionEnabler.removeClass('enabled');\n        },\n\n        /**\n         * Set/unset solution section label\n         *\n         * @param {*} solution\n         * @param {Boolean} enabled\n         */\n        setSolutionSectionMarkEnabled = function (solution, enabled) {\n            var solutionSection = solution.find('.section-config');\n\n            enabled || typeof enabled === 'undefined' ?\n                solutionSection.addClass('enabled') :\n                solutionSection.removeClass('enabled');\n        },\n\n        /**\n         * Set/unset solution section inner labels\n         *\n         * @param {*} solution\n         * @param {Boolean} enabled\n         */\n        setSolutionLabelsMarkEnabled = function (solution, enabled) {\n            var solutionLabels = solution.find('label.enabled');\n\n            enabled || typeof enabled === 'undefined' ?\n                solutionLabels.addClass('enabled') :\n                solutionLabels.removeClass('enabled');\n        },\n\n        /**\n         * Set/unset solution usedefault checkbox\n         *\n         * @param {*} solution\n         * @param {String} enabler\n         * @param {Boolean} checked\n         */\n        setSolutionUsedefaultEnabled = function (solution, enabler, checked) {\n            checked = !(checked || typeof checked === 'undefined');\n\n            solution.find('input[id=\"' + solution.find(enabler).attr('id') + '_inherit\"]')\n            .prop('checked', checked);\n        },\n\n        /**\n         * Set solution as disabled\n         *\n         * @param {*} solution\n         * @param {String} enabler\n         */\n        disableSolution = function (solution, enabler) {\n            setSolutionUsedefaultEnabled(solution, enabler);\n            setSolutionMarkEnabled(solution, enabler, false);\n            setSolutionSelectEnabled(solution, enabler, false);\n            setSolutionPropEnabled(solution, enabler, false);\n        },\n\n        /**\n         * Set solution as enabled\n         *\n         * @param {*} solution\n         * @param {String} enabler\n         */\n        enableSolution = function (solution, enabler) {\n            setSolutionUsedefaultEnabled(solution, enabler);\n            setSolutionPropEnabled(solution, enabler);\n            setSolutionSelectEnabled(solution, enabler);\n            setSolutionMarkEnabled(solution, enabler);\n        },\n\n        /**\n         * Lock/unlock solution configuration button\n         *\n         * @param {*} solution\n         * @param {String} buttonConfiguration\n         * @param {Boolean} unlock\n         */\n        setSolutionConfigurationUnlock = function (solution, buttonConfiguration, unlock) {\n            var solutionConfiguration = solution.find(buttonConfiguration);\n\n            unlock || typeof unlock === 'undefined' ?\n                solutionConfiguration.removeClass('disabled').removeAttr('disabled') :\n                solutionConfiguration.addClass('disabled').attr('disabled', 'disabled');\n        },\n\n        /**\n         * Forward solution select-enabler changes\n         *\n         * @param {*} solution\n         * @param {String} enabler\n         */\n        forwardSolutionChange = function (solution, enabler) {\n            solution.find(enabler).change();\n        },\n\n        /**\n         * Show/hide dependent fields\n         *\n         * @param {*} solution\n         * @param {String} identifier\n         * @param {Boolean} show\n         */\n        showDependsField = function (solution, identifier, show) {\n            show = show || typeof show === 'undefined';\n\n            solution.find(identifier).toggle(show);\n            solution.find(identifier).closest('tr').toggle(show);\n            solution.find(identifier).attr('disabled', !show);\n        };\n\n    return Class.extend({\n        defaults: {\n            /**\n             * Payment conflicts checker\n             */\n            executed: false\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        simpleDisable: function ($target, $owner, data) {\n            setSolutionSelectEnabled($target, data.enableButton, false);\n            setSolutionLabelsMarkEnabled($target, false);\n            setSolutionSectionMarkEnabled($target, false);\n        },\n\n        /**\n         * @param {*} $target\n         */\n        simpleMarkEnable: function ($target) {\n            setSolutionSectionMarkEnabled($target);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        disable: function ($target, $owner, data) {\n            this.simpleDisable($target, $owner, data);\n            forwardSolutionChange($target, data.enableButton);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalExpressDisable: function ($target, $owner, data) {\n            setSolutionSelectEnabled($target, data.enableButton, false);\n            setSolutionLabelsMarkEnabled($target, false);\n            forwardSolutionChange($target, data.enableButton);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalExpressLockConfiguration: function ($target, $owner, data) {\n            setSolutionConfigurationUnlock($target, data.buttonConfiguration, false);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalExpressLockConfigurationConditional: function ($target, $owner, data) {\n            if (\n                !isSolutionEnabled($target, data.enableInContextPayPal) &&\n                hasRelationsEnabled(data)\n            ) {\n                this.paypalExpressLockConfiguration($target, $owner, data);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalExpressMarkDisable: function ($target, $owner, data) {\n            if (!hasRelationsEnabled(data)) {\n                this.simpleDisable($target, $owner, data);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalExpressUnlockConfiguration: function ($target, $owner, data) {\n            if (!hasRelationsEnabled(data)) {\n                setSolutionConfigurationUnlock($target, data.buttonConfiguration);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalBmlDisable: function ($target, $owner, data) {\n            disableSolution($target, data.enableBmlPayPal);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalBmlDisableConditional: function ($target, $owner, data) {\n            if (!isSolutionEnabled($target, data.enableButton)) {\n                this.paypalBmlDisable($target, $owner, data);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalBmlEnable: function ($target, $owner, data) {\n            enableSolution($target, data.enableBmlPayPal);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowExpressDisable: function ($target, $owner, data) {\n            disableSolution($target, data.enableExpress);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowExpressDisableConditional: function ($target, $owner, data) {\n            if (\n                !isSolutionEnabled($target, data.enableButton) ||\n                hasRelationsEnabled(data)\n            ) {\n                this.payflowExpressDisable($target, $owner, data);\n                forwardSolutionChange($target, data.enableExpress);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowExpressEnable: function ($target, $owner, data) {\n            enableSolution($target, data.enableExpress);\n            forwardSolutionChange($target, data.enableExpress);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowExpressEnableConditional: function ($target, $owner, data) {\n            if (hasRelationsEnabled(data)) {\n                setSolutionPropEnabled($target, data.enableExpress, false);\n                setSolutionSelectEnabled($target, data.enableExpress);\n                setSolutionMarkEnabled($target, data.enableExpress);\n            } else {\n                disableSolution($target, data.enableExpress);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowExpressLockConditional: function ($target, $owner, data) {\n            if (!isSolutionEnabled($target, data.enableButton)) {\n                setSolutionPropEnabled($target, data.enableExpress, false);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowExpressUsedefaultDisable: function ($target, $owner, data) {\n            setSolutionUsedefaultEnabled($target, data.enableExpress, false);\n            this.payflowExpressEnable($target, $owner, data);\n            forwardSolutionChange($target, data.enableExpress);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowExpressUsedefaultEnable: function ($target, $owner, data) {\n            setSolutionUsedefaultEnabled($target, data.enableExpress);\n            this.payflowExpressDisable($target, $owner, data);\n            forwardSolutionChange($target, data.enableExpress);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowBmlDisable: function ($target, $owner, data) {\n            disableSolution($target, data.enableBml);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowBmlDisableConditional: function ($target, $owner, data) {\n            if (\n                !isSolutionEnabled($target, data.enableButton) ||\n                hasRelationsEnabled(data)\n            ) {\n                this.payflowBmlDisable($target, $owner, data);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowBmlDisableConditionalExpress: function ($target, $owner, data) {\n            if (!isSolutionEnabled($target, data.enableExpress)) {\n                this.payflowBmlDisable($target, $owner, data);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowBmlEnable: function ($target, $owner, data) {\n            enableSolution($target, data.enableBml);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowBmlEnableConditional: function ($target, $owner, data) {\n            if (hasRelationsEnabled(data)) {\n                setSolutionPropEnabled($target, data.enableBml, false);\n                setSolutionSelectEnabled($target, data.enableBml);\n                setSolutionMarkEnabled($target, data.enableBml);\n            } else {\n                disableSolution($target, data.enableBml);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowBmlLockConditional: function ($target, $owner, data) {\n            if (!isSolutionEnabled($target, data.enableButton)) {\n                setSolutionPropEnabled($target, data.enableBml, false);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        inContextEnable: function ($target, $owner, data) {\n            enableSolution($target, data.enableInContextPayPal);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        inContextDisable: function ($target, $owner, data) {\n            disableSolution($target, data.enableInContextPayPal);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        inContextShowMerchantId: function ($target, $owner, data) {\n            showDependsField($target, data.dependsMerchantId);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        inContextHideMerchantId: function ($target, $owner, data) {\n            showDependsField($target, data.dependsMerchantId, false);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowShowSortOrder: function ($target, $owner, data) {\n            showDependsField($target, data.dependsBmlSortOrder);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        payflowHideSortOrder: function ($target, $owner, data) {\n            showDependsField($target, data.dependsBmlSortOrder, false);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalShowSortOrder: function ($target, $owner, data) {\n            showDependsField($target, data.dependsBmlApiSortOrder);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        paypalHideSortOrder: function ($target, $owner, data) {\n            showDependsField($target, data.dependsBmlApiSortOrder, false);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        inContextActivate: function ($target, $owner, data) {\n            setSolutionMarkEnabled($target, data.enableInContextPayPal);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        inContextDeactivate: function ($target, $owner, data) {\n            setSolutionMarkEnabled($target, data.enableInContextPayPal, false);\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        inContextDisableConditional: function ($target, $owner, data) {\n            if (!isSolutionEnabled($target, data.enableButton)) {\n                this.inContextDisable($target, $owner, data);\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        conflict: function ($target, $owner, data) {\n            var newLine = String.fromCharCode(10, 13);\n\n            if (\n                isSolutionEnabled($owner, data.enableButton) &&\n                hasRelationsEnabled(data) &&\n                !this.executed\n            ) {\n                this.executed = true;\n                alert({\n                    content: 'The following error(s) occurred:' +\n                    newLine +\n                    'Some PayPal solutions conflict.' +\n                    newLine +\n                    'Please re-enable the previously enabled payment solutions.'\n                });\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        removeCreditOption: function ($target, $owner, data) {\n            if ($target.find(data.dependsButtonLabel + ' option[value=\"credit\"]').length > 0) {\n                $target.find(data.dependsButtonLabel + ' option[value=\"credit\"]').remove();\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        addCreditOption: function ($target, $owner, data) {\n            if ($target.find(data.dependsButtonLabel + ' option[value=\"credit\"]').length === 0) {\n                $target.find(data.dependsButtonLabel).append('<option value=\"credit\">Credit</option>');\n            }\n        },\n\n        /**\n         * @param {*} $target\n         * @param {*} $owner\n         * @param {Object} data\n         */\n        removeCreditOptionConditional: function ($target, $owner, data) {\n            if ($target.find(data.dependsDisableFundingOptions + ' option[value=\"CREDIT\"]').length === 0 ||\n                $target.find(data.dependsDisableFundingOptions + ' option[value=\"CREDIT\"]:selected').length > 0\n            ) {\n                this.removeCreditOption($target, $owner, data);\n            }\n        }\n    });\n});\n","Magento_Paypal/js/rule.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'uiClass',\n    'Magento_Paypal/js/rules'\n], function (Class, Rules) {\n    'use strict';\n\n    return Class.extend({\n\n        /**\n         * Constructor\n         *\n         * @param {Object} config\n         * @returns {exports.initialize}\n         */\n        initialize: function (config) {\n            this.rules = new Rules();\n            this.initConfig(config);\n\n            return this;\n        },\n\n        /**\n         * To apply the rule\n         */\n        apply: function () {\n            this.rules[this.name](this.$target, this.$owner, this.data);\n        }\n    });\n});\n","Magento_Paypal/js/predicate/confirm.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine(['underscore'], function (_) {\n    'use strict';\n\n    return function (solution, message, argument) {\n        var isConfirm = false;\n\n        _.every(argument, function (name) {\n            if (solution.solutionsElements[name] &&\n                solution.solutionsElements[name].find(solution.enableButton).val() == 1 //eslint-disable-line eqeqeq\n            ) {\n                isConfirm = true;\n\n                return !isConfirm;\n            }\n\n            return !isConfirm;\n        }, this);\n\n        if (isConfirm) {\n            return confirm(message); //eslint-disable-line no-alert\n        }\n\n        return true;\n    };\n});\n","Magento_Paypal/js/payflowpro/vault.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n/*browser:true*/\n/*global define*/\ndefine([\n    'jquery',\n    'uiComponent'\n], function ($, Class) {\n    'use strict';\n\n    return Class.extend({\n        defaults: {\n            $selector: null,\n            selector: 'edit_form'\n        },\n\n        /**\n         * Set list of observable attributes\n         * @returns {exports.initObservable}\n         */\n        initObservable: function () {\n            var self = this;\n\n            self.$selector = $('#' + self.selector);\n            this._super();\n\n            this.initEventHandlers();\n\n            return this;\n        },\n\n        /**\n         * Get payment code\n         * @returns {String}\n         */\n        getCode: function () {\n            return 'payflowpro';\n        },\n\n        /**\n         * Init event handlers\n         */\n        initEventHandlers: function () {\n            $('#' + this.container).find('[name=\"payment[token_switcher]\"]')\n                .on('click', this.setPaymentDetails.bind(this));\n        },\n\n        /**\n         * Store payment details\n         */\n        setPaymentDetails: function () {\n            this.$selector.find('[name=\"payment[public_hash]\"]').val(this.publicHash);\n        }\n    });\n});\n","Magento_User/app-config.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @deprecated since version 2.2.0\n */\nrequire.config({\n    'waitSeconds': 0,\n    'shim': {\n        'jquery/jstree/jquery.hotkeys': ['jquery'],\n        'jquery/hover-intent': ['jquery'],\n        'mage/adminhtml/backup': ['prototype'],\n        'mage/captcha': ['prototype'],\n        'mage/common': ['jquery'],\n        'mage/webapi': ['jquery'],\n        'ko': {\n            exports: 'ko'\n        },\n        'moment': {\n            exports: 'moment'\n        }\n    },\n    'paths': {\n        'jquery/ui': 'jquery/jquery-ui-1.9.2',\n        'jquery/validate': 'jquery/jquery.validate',\n        'jquery/hover-intent': 'jquery/jquery.hoverIntent',\n        'jquery/file-uploader': 'jquery/fileUploader/jquery.fileupload-fp',\n        'prototype': 'prototype/prototype-amd',\n        'text': 'requirejs/text',\n        'domReady': 'requirejs/domReady',\n        'ko': 'ko/ko'\n    }\n});\n\nrequire(['jquery'], function (jQuery) {\n    'use strict';\n\n    jQuery.noConflict();\n});\n","Magento_User/js/roles-tree.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\n/**\n * @api\n */\ndefine([\n    'jquery',\n    'jquery/ui',\n    'jquery/jstree/jquery.jstree'\n], function ($) {\n    'use strict';\n\n    $.widget('mage.rolesTree', {\n        options: {\n            treeInitData: {},\n            treeInitSelectedData: {}\n        },\n\n        /** @inheritdoc */\n        _create: function () {\n            this.element.jstree({\n                plugins: ['themes', 'json_data', 'ui', 'crrm', 'types', 'vcheckbox', 'hotkeys'],\n                vcheckbox: {\n                    'two_state': true,\n                    'real_checkboxes': true,\n\n                    /**\n                     * @param {*} n\n                     * @return {Array}\n                     */\n                    'real_checkboxes_names': function (n) {\n                        return ['resource[]', $(n).data('id')];\n                    }\n                },\n                'json_data': {\n                    data: this.options.treeInitData\n                },\n                ui: {\n                    'select_limit': 0\n                },\n                hotkeys: {\n                    space: this._changeState,\n                    'return': this._changeState\n                },\n                types: {\n                    'types': {\n                        'disabled': {\n                            'check_node': false,\n                            'uncheck_node': false\n                        }\n                    }\n                }\n            });\n            this._bind();\n        },\n\n        /**\n         * @private\n         */\n        _destroy: function () {\n            this.element.jstree('destroy');\n        },\n\n        /**\n         * @private\n         */\n        _bind: function () {\n            this.element.on('loaded.jstree', $.proxy(this._checkNodes, this));\n            this.element.on('click.jstree', 'a', $.proxy(this._checkNode, this));\n        },\n\n        /**\n         * @param {jQuery.Event} event\n         * @private\n         */\n        _checkNode: function (event) {\n            event.stopPropagation();\n            this.element.jstree(\n                'change_state',\n                event.currentTarget,\n                this.element.jstree('is_checked', event.currentTarget)\n            );\n        },\n\n        /**\n         * @private\n         */\n        _checkNodes: function () {\n            var $items = $('[data-id=\"' + this.options.treeInitSelectedData.join('\"],[data-id=\"') + '\"]');\n\n            $items.removeClass('jstree-unchecked').addClass('jstree-checked');\n            $items.children(':checkbox').prop('checked', true);\n        },\n\n        /**\n         * @return {Boolean}\n         * @private\n         */\n        _changeState: function () {\n            var element;\n\n            if (this.data.ui.hovered) {\n                element = this.data.ui.hovered;\n                this['change_state'](element, this['is_checked'](element));\n            }\n\n            return false;\n        }\n    });\n\n    return $.mage.rolesTree;\n});\n","Magento_User/js/delete-user-account.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\ndefine([\n    'jquery'\n], function ($) {\n    'use strict';\n\n    var postData;\n\n    return function (params, elem) {\n\n        elem.on('click', function () {\n\n            postData = {\n                'data': {\n                    'user_id': params.objId,\n                    'current_password': $('[name=\"current_password\"]').val()\n                }\n            };\n\n            if ($.validator.validateElement($('[name=\"current_password\"]'))) {\n                window.deleteConfirm(params.message, params.url, postData);\n            }\n        });\n    };\n});\n","Homescapes_Ordermanagers/js/export.js":"define([\n    \"jquery\",\n    \"jquery/ui\",\n    \"mage/translate\"\n], function ($) {\n\n    $.widget('mage.ktplExport', {\n        options: {},\n\n        _create: function () {\n           \n            if (this.options.type == 'export') {\n                $('#ktpl-export').click(function () {\n                        var startDownloadingUrl = this.options.importURL;\n                        this.runDownloading(startDownloadingUrl);\n                }.bind(this));\n            }\n          \n        },\n\n        error: function (error, processer) {\n            if (processer)\n                $(processer.parentNode).remove();\n\n        },\n\n        done: function (response) {\n            if (response.full_import_done == 1) {\n                location.reload();\n            }\n        },\n\n        runDownloading: function (startDownloadingUrl) {\n           console.log('call run downloading function')\n           console.log(startDownloadingUrl);\n           $(\"#expor-loader\").show();\n          \n            $.ajax({\n                url: startDownloadingUrl,\n                type: 'POST',\n                dataType: 'json',\n                data: {isAjax: true}\n            }).done($.proxy(function (response) {\n                if (response.success == 'done') {\n                   console.log(response.csv_file);\n                   var csvUrl=response.csv_file;\n                   $(\"#download-file\").attr(\"href\", csvUrl);\n                   $(\"#expor-loader\").hide();\n                   $(\"#download-file\").show();\n                } else if (response.error) {\n                    alert(response.message);\n                }\n            }));\n        },\n\n      \n    });\n    return $.mage.ktplExport;\n});\n","Magento_AdminAnalytics/js/release-notification/modal/component-mixin.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine(['jquery', 'analyticsPopupConfig'], function ($, analyticsPopupConfig) {\n    'use strict';\n\n    var deferred = $.Deferred(),\n\n        mixin = {\n        /**\n         * Initializes content only if its visible\n         */\n        initializeContent: function () {\n            var initializeContent = this._super.bind(this);\n\n            if (!analyticsPopupConfig.analyticsVisible) {\n                initializeContent();\n            } else {\n                deferred.then(function () {\n                    initializeContent();\n                });\n            }\n        },\n\n        /**\n         * Initializes release notification content after admin analytics\n         */\n        initializeContentAfterAnalytics: function () {\n            deferred.resolve();\n        }\n    };\n\n    return function (target) {\n        return target.extend(mixin);\n    };\n});\n\n","Magento_AdminAnalytics/js/modal/component.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'underscore',\n    'jquery',\n    'Magento_Ui/js/modal/modal-component',\n    'uiRegistry',\n    'analyticsPopupConfig'\n],\n    function (_, $, Modal, registry, analyticsPopupConfig) {\n        'use strict';\n\n        return Modal.extend(\n            {\n                defaults: {\n                    imports: {\n                        enableLogAction: '${ $.provider }:data.enableLogAction',\n                        disableLogAction: '${ $.provider }:data.disableLogAction'\n                    },\n                    options: {},\n                    notificationWindow: null\n                },\n\n                /**\n                 * Initializes modal on opened function\n                 */\n                initModal: function () {\n                    this.options.opened = this.onOpened.bind(this);\n                    this._super();\n                },\n\n                /**\n                 * Configure ESC and TAB so user can't leave modal\n                 * without selecting an option\n                 *\n                 * @returns {Object} Chainable.\n                 */\n                initModalEvents: function () {\n                    this._super();\n                    //Don't allow ESC key to close modal\n                    this.options.keyEventHandlers.escapeKey = this.handleEscKey.bind(this);\n                    //Restrict tab action to the modal\n                    this.options.keyEventHandlers.tabKey = this.handleTabKey.bind(this);\n\n                    return this;\n                },\n\n                /**\n                 * Once the modal is opened it hides the X\n                 */\n                onOpened: function () {\n                    $('.modal-header button.action-close').attr('disabled', true).hide();\n\n                    this.focusableElements = $(this.rootSelector).find('a[href], button:enabled');\n                    this.firstFocusableElement = this.focusableElements[0];\n                    this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];\n                    this.firstFocusableElement.focus();\n                },\n\n                /**\n                 * Changes admin usage setting to yes\n                 */\n                enableAdminUsage: function () {\n                    var data = {\n                        'form_key': window.FORM_KEY\n                    };\n\n                    $.ajax(\n                        {\n                            type: 'POST',\n                            url: this.enableLogAction,\n                            data: data,\n                            showLoader: true\n                        }\n                    ).done(\n                        function (xhr) {\n                            if (xhr.error) {\n                                self.onError(xhr);\n                            }\n                        }\n                    ).fail(this.onError);\n                    this.openReleasePopup();\n                    this.closeModal();\n                },\n\n                /**\n                 * Changes admin usage setting to no\n                 */\n                disableAdminUsage: function () {\n                    var data = {\n                        'form_key': window.FORM_KEY\n                    };\n\n                    $.ajax(\n                        {\n                            type: 'POST',\n                            url: this.disableLogAction,\n                            data: data,\n                            showLoader: true\n                        }\n                    ).done(\n                        function (xhr) {\n                            if (xhr.error) {\n                                self.onError(xhr);\n                            }\n                        }\n                    ).fail(this.onError);\n                    this.openReleasePopup();\n                    this.closeModal();\n                },\n\n                /**\n                 * Allows admin usage popup to be shown first and then new release notification\n                 */\n                openReleasePopup: function () {\n                    var notificationModalSelector = 'release_notification.release_notification.notification_modal_1';\n\n                    if (analyticsPopupConfig.releaseVisible) {\n                        registry.get(notificationModalSelector).initializeContentAfterAnalytics();\n                    }\n                },\n\n                /**\n                 * Handle Tab and Shift+Tab key event\n                 *\n                 * Keep the tab actions restricted to the popup modal\n                 * so the user must select an option to dismiss the modal\n                 */\n                handleTabKey: function (event) {\n                    var modal = this,\n                        KEY_TAB = 9;\n\n                    /**\n                     * Handle Shift+Tab to tab backwards\n                     */\n                    function handleBackwardTab() {\n                        if (document.activeElement === modal.firstFocusableElement ||\n                            document.activeElement === $(modal.rootSelector)[0]\n                        ) {\n                            event.preventDefault();\n                            modal.lastFocusableElement.focus();\n                        }\n                    }\n\n                    /**\n                     * Handle Tab forward\n                     */\n                    function handleForwardTab() {\n                        if (document.activeElement === modal.lastFocusableElement) {\n                            event.preventDefault();\n                            modal.firstFocusableElement.focus();\n                        }\n                    }\n\n                    switch (event.keyCode) {\n                        case KEY_TAB:\n                            if (modal.focusableElements.length === 1) {\n                                event.preventDefault();\n                                break;\n                            }\n\n                            if (event.shiftKey) {\n                                handleBackwardTab();\n                                break;\n                            }\n                            handleForwardTab();\n                            break;\n                        default:\n                            break;\n                    }\n                },\n\n                /**\n                 * Handle Esc key\n                 *\n                 * Esc key should not close modal\n                 */\n                handleEscKey: function (event) {\n                    event.preventDefault();\n                }\n            }\n        );\n    }\n);\n","Mirasvit_Report/js/chart.js":"define([\n    'jquery',\n    'underscore',\n    'ko',\n    'uiComponent',\n    './chart/column',\n    './chart/line',\n    './chart/pie',\n    './chart/geo'\n], function ($, _, ko, Component, ColumnChart, LineChart, PieChart, GeoChart) {\n    'use strict';\n    \n    return Component.extend({\n        defaults: {\n            template: 'report/chart',\n            \n            provider: '${ $.provider }:data',\n            \n            imports: {\n                rows:            '${ $.provider }:data.items',\n                columnsProvider: '${ $.columnsProvider }:elems',\n                dimensionColumn: '${ $.provider }:data.dimensionColumn',\n                params:          '${ $.provider }:params'\n                //pdata:           '${ $.provider }:data'\n            },\n            listens: {\n                rows:            'updateRows',\n                columnsProvider: 'updateColumns',\n                dimensionColumn: 'updateColumns'\n            },\n            tracks:  {\n                chartType: true\n            }\n        },\n        \n        chartType:    'empty',\n        typeInstance: null,\n        \n        primaryColors: [\n            '#97CC64',\n            '#FF5A3E',\n            '#77B6E7'\n        ],\n        \n        colors: [\n            '#FFD963',\n            '#A9B9B8',\n            '#DC9D6B',\n            '#8549ba',\n            '#00a950',\n            '#166a8f',\n            '#acc236',\n            '#537bc4',\n            '#f53794',\n            '#f67019',\n            '#4dc9f6'\n        ],\n        \n        initialize: function () {\n            this._super();\n            \n            _.bindAll(this, 'setChartType');\n            \n            this.setChartType(this.chartType);\n        },\n        \n        setChartType: function (type) {\n            this.set('chartType', type);\n            \n            if (this.typeInstance) {\n                this.typeInstance.destroy();\n            }\n            \n            switch (type) {\n                case 'column':\n                    this.typeInstance = new ColumnChart();\n                    break;\n                case 'line':\n                    this.typeInstance = new LineChart();\n                    break;\n                case 'pie':\n                    this.typeInstance = new PieChart();\n                    break;\n                case 'geo':\n                    this.typeInstance = new GeoChart();\n                    break;\n            }\n            \n            if (this.chartType === 'geo') {\n                this.typeSwitcher = ['geo'];\n            } else {\n                this.typeSwitcher = ['column', 'line', 'pie'];\n            }\n            \n            this.updateRows();\n            this.updateColumns();\n        },\n        \n        updateRows: function () {\n            if (this.typeInstance) {\n                this.typeInstance.setParams(this.params);\n                this.typeInstance.setRows(this.rows);\n            }\n        },\n        \n        updateColumns: function () {\n            var columns = [];\n            _.each(this.columnsProvider, function (column, idx) {\n                var isVisible = _.indexOf(this.defaultColumns, column.index) >= 0\n                    && column.index !== this.dimensionColumn;\n                \n                var data = {\n                    index:       column.index,\n                    label:       column.label,\n                    color:       this.getColor(idx, column),\n                    type:        column.valueType,\n                    isVisible:   isVisible,\n                    isDimension: column.index === this.dimensionColumn,\n                    isInternal:  column.index === this.dimensionColumn || column.isFilterOnly || !column.visible || column.index === 'actions',\n                    model:       column\n                };\n                \n                columns.push(data);\n            }, this);\n            \n            if (this.typeInstance) {\n                this.typeInstance.setColumns(columns);\n            }\n        },\n        \n        getColor: function (idx, column) {\n            // set of default columns\n            if (_.indexOf(this.defaultColumns, column.index) >= 0) {\n                idx = _.indexOf(this.defaultColumns, column.index);\n                \n                return this.primaryColors[idx];\n            } else {\n                \n                while (idx >= this.colors.length && this.colors.length > 0) {\n                    idx = idx - this.colors.length;\n                }\n            }\n            \n            return this.colors[idx];\n        }\n    });\n});","Mirasvit_Report/js/toolbar.js":"define([\n    'underscore',\n    'ko',\n    'uiComponent',\n    'uiLayout'\n], function (_, ko, Component, Layout) {\n    'use strict';\n\n    return Component.extend({\n        defaults: {\n            template: 'report/toolbar',\n\n            exports: {\n                dimension: '${ $.provider }:params.dimension',\n                rand:      '${ $.provider }:params.rand'\n            },\n\n            listens: {}\n        },\n\n        initialize: function () {\n            this._super();\n\n            _.bindAll(this, 'onGroupBy');\n\n            _.each(this.fastFilters, function (filter) {\n                filter.provider = this.provider;\n                filter.parent = this.name;\n                filter.name = filter.column;\n\n                Layout([filter]);\n            }.bind(this));\n\n            _.each(this.groupBy, function (group) {\n                group.provider = this.provider;\n                group.parent = this.name;\n\n                Layout([group]);\n            }.bind(this));\n\n            return this;\n        },\n\n        initObservable: function () {\n            this._super();\n\n            this.observe('dimension');\n            this.observe('dimensionLabel');\n            this.observe('rand');\n\n            return this;\n        },\n\n        onGroupBy: function (group) {\n            this.dimensionLabel(': ' + group.label);\n            this.dimension(group.column);\n            this.rand(new Date().toLocaleString());\n        }\n    });\n});\n","Mirasvit_Report/js/lib/chart.js":"/*!\n * Chart.js\n * http://chartjs.org/\n * Version: 2.6.0\n *\n * Copyright 2017 Nick Downie\n * Released under the MIT license\n * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md\n */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n    /**\n     * @namespace Chart\n     */\n    var Chart = require(22)();\n    \n    require(20)(Chart);\n    require(34)(Chart);\n    require(16)(Chart);\n    require(19)(Chart);\n    require(24)(Chart);\n    require(15)(Chart);\n    require(17)(Chart);\n    require(18)(Chart);\n    require(23)(Chart);\n    require(26)(Chart);\n    require(27)(Chart);\n    require(25)(Chart);\n    require(21)(Chart);\n    require(28)(Chart);\n    \n    require(29)(Chart);\n    require(30)(Chart);\n    require(31)(Chart);\n    require(32)(Chart);\n    \n    require(40)(Chart);\n    require(38)(Chart);\n    require(39)(Chart);\n    require(41)(Chart);\n    require(42)(Chart);\n    require(43)(Chart);\n\n// Controllers must be loaded after elements\n// See Chart.core.datasetController.dataElementType\n    require(9)(Chart);\n    require(10)(Chart);\n    require(11)(Chart);\n    require(12)(Chart);\n    require(13)(Chart);\n    require(14)(Chart);\n    \n    require(2)(Chart);\n    require(3)(Chart);\n    require(4)(Chart);\n    require(5)(Chart);\n    require(6)(Chart);\n    require(7)(Chart);\n    require(8)(Chart);\n\n// Loading built-it plugins\n    var plugins = [];\n    \n    plugins.push(\n        require(35)(Chart),\n        require(36)(Chart),\n        require(37)(Chart)\n    );\n    \n    Chart.plugins.register(plugins);\n    \n    module.exports = Chart;\n    if (typeof window !== 'undefined') {\n        window.Chart = Chart;\n    }\n    \n},{\"10\":10,\"11\":11,\"12\":12,\"13\":13,\"14\":14,\"15\":15,\"16\":16,\"17\":17,\"18\":18,\"19\":19,\"2\":2,\"20\":20,\"21\":21,\"22\":22,\"23\":23,\"24\":24,\"25\":25,\"26\":26,\"27\":27,\"28\":28,\"29\":29,\"3\":3,\"30\":30,\"31\":31,\"32\":32,\"34\":34,\"35\":35,\"36\":36,\"37\":37,\"38\":38,\"39\":39,\"4\":4,\"40\":40,\"41\":41,\"42\":42,\"43\":43,\"5\":5,\"6\":6,\"7\":7,\"8\":8,\"9\":9}],2:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        Chart.Bar = function(context, config) {\n            config.type = 'bar';\n            \n            return new Chart(context, config);\n        };\n        \n    };\n    \n},{}],3:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        Chart.Bubble = function(context, config) {\n            config.type = 'bubble';\n            return new Chart(context, config);\n        };\n        \n    };\n    \n},{}],4:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        Chart.Doughnut = function(context, config) {\n            config.type = 'doughnut';\n            \n            return new Chart(context, config);\n        };\n        \n    };\n    \n},{}],5:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        Chart.Line = function(context, config) {\n            config.type = 'line';\n            \n            return new Chart(context, config);\n        };\n        \n    };\n    \n},{}],6:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        Chart.PolarArea = function(context, config) {\n            config.type = 'polarArea';\n            \n            return new Chart(context, config);\n        };\n        \n    };\n    \n},{}],7:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        Chart.Radar = function(context, config) {\n            config.type = 'radar';\n            \n            return new Chart(context, config);\n        };\n        \n    };\n    \n},{}],8:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var defaultConfig = {\n            hover: {\n                mode: 'single'\n            },\n            \n            scales: {\n                xAxes: [{\n                    type: 'linear', // scatter should not use a category axis\n                    position: 'bottom',\n                    id: 'x-axis-1' // need an ID so datasets can reference the scale\n                }],\n                yAxes: [{\n                    type: 'linear',\n                    position: 'left',\n                    id: 'y-axis-1'\n                }]\n            },\n            \n            tooltips: {\n                callbacks: {\n                    title: function() {\n                        // Title doesn't make sense for scatter since we format the data as a point\n                        return '';\n                    },\n                    label: function(tooltipItem) {\n                        return '(' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ')';\n                    }\n                }\n            }\n        };\n        \n        // Register the default config for this type\n        Chart.defaults.scatter = defaultConfig;\n        \n        // Scatter charts use line controllers\n        Chart.controllers.scatter = Chart.controllers.line;\n        \n        Chart.Scatter = function(context, config) {\n            config.type = 'scatter';\n            return new Chart(context, config);\n        };\n        \n    };\n    \n},{}],9:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function (Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.bar = {\n            hover: {\n                mode: 'label'\n            },\n            \n            scales: {\n                xAxes: [{\n                    type: 'category',\n                    \n                    // Specific to Bar Controller\n                    categoryPercentage: 0.8,\n                    barPercentage:      0.9,\n                    \n                    // grid line settings\n                    gridLines: {\n                        offsetGridLines: true\n                    }\n                }],\n                yAxes: [{\n                    type: 'linear'\n                }]\n            }\n        };\n        \n        Chart.controllers.bar = Chart.DatasetController.extend({\n            \n            dataElementType: Chart.elements.Rectangle,\n            \n            initialize: function () {\n                var me = this;\n                var meta;\n                \n                Chart.DatasetController.prototype.initialize.apply(me, arguments);\n                \n                meta = me.getMeta();\n                meta.stack = me.getDataset().stack;\n                meta.bar = true;\n            },\n            \n            update: function (reset) {\n                var me = this;\n                var elements = me.getMeta().data;\n                var i, ilen;\n                \n                me._ruler = me.getRuler();\n                \n                for (i = 0, ilen = elements.length; i < ilen; ++i) {\n                    me.updateElement(elements[i], i, reset);\n                }\n            },\n            \n            updateElement: function (rectangle, index, reset) {\n                var me = this;\n                var chart = me.chart;\n                var meta = me.getMeta();\n                var dataset = me.getDataset();\n                var custom = rectangle.custom || {};\n                var rectangleOptions = chart.options.elements.rectangle;\n                \n                rectangle._xScale = me.getScaleForId(meta.xAxisID);\n                rectangle._yScale = me.getScaleForId(meta.yAxisID);\n                rectangle._datasetIndex = me.index;\n                rectangle._index = index;\n                \n                rectangle._model = {\n                    datasetLabel:    dataset.label,\n                    label:           chart.data.labels[index],\n                    borderSkipped:   custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,\n                    backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),\n                    borderColor:     custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),\n                    borderWidth:     custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)\n                };\n                \n                me.updateElementGeometry(rectangle, index, reset);\n                \n                rectangle.pivot();\n            },\n            \n            /**\n             * @private\n             */\n            updateElementGeometry: function (rectangle, index, reset) {\n                var me = this;\n                var model = rectangle._model;\n                var vscale = me.getValueScale();\n                var base = vscale.getBasePixel();\n                var horizontal = vscale.isHorizontal();\n                var ruler = me._ruler || me.getRuler();\n                var vpixels = me.calculateBarValuePixels(me.index, index);\n                var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n                \n                model.horizontal = horizontal;\n                model.base = reset ? base : vpixels.base;\n                model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n                model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n                model.height = horizontal ? ipixels.size : undefined;\n                model.width = horizontal ? undefined : ipixels.size;\n            },\n            \n            /**\n             * @private\n             */\n            getValueScaleId: function () {\n                return this.getMeta().yAxisID;\n            },\n            \n            /**\n             * @private\n             */\n            getIndexScaleId: function () {\n                return this.getMeta().xAxisID;\n            },\n            \n            /**\n             * @private\n             */\n            getValueScale: function () {\n                return this.getScaleForId(this.getValueScaleId());\n            },\n            \n            /**\n             * @private\n             */\n            getIndexScale: function () {\n                return this.getScaleForId(this.getIndexScaleId());\n            },\n            \n            /**\n             * Returns the effective number of stacks based on groups and bar visibility.\n             * @private\n             */\n            getStackCount: function (last) {\n                var me = this;\n                var chart = me.chart;\n                var scale = me.getIndexScale();\n                var stacked = scale.options.stacked;\n                var ilen = last === undefined ? chart.data.datasets.length : last + 1;\n                var stacks = [];\n                var i, meta;\n                \n                for (i = 0; i < ilen; ++i) {\n                    meta = chart.getDatasetMeta(i);\n                    if (meta.bar && chart.isDatasetVisible(i) &&\n                        (stacked === false ||\n                        (stacked === true && stacks.indexOf(meta.stack) === -1) ||\n                        (stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n                        stacks.push(meta.stack);\n                    }\n                }\n                \n                return stacks.length;\n            },\n            \n            /**\n             * Returns the stack index for the given dataset based on groups and bar visibility.\n             * @private\n             */\n            getStackIndex: function (datasetIndex) {\n                return this.getStackCount(datasetIndex) - 1;\n            },\n            \n            /**\n             * @private\n             */\n            getRuler: function () {\n                var me = this;\n                var scale = me.getIndexScale();\n                var options = scale.options;\n                var stackCount = me.getStackCount();\n                var fullSize = scale.isHorizontal() ? scale.width : scale.height;\n                var tickSize = fullSize / scale.ticks.length;\n                var categorySize = tickSize * options.categoryPercentage;\n                var fullBarSize = categorySize / stackCount;\n                var barSize = fullBarSize * options.barPercentage;\n                \n                \n                barSize = Math.min(\n                    helpers.getValueOrDefault(options.barThickness, barSize),\n                    helpers.getValueOrDefault(options.maxBarThickness, Infinity));\n                \n                var barSpacing = fullBarSize - barSize;\n                \n                if (options.inside === true) {\n                    barSize = barSize + 5;\n                    barSpacing = (fullBarSize - barSize) - fullBarSize * 2;\n                }\n                \n                return {\n                    stackCount:      stackCount,\n                    tickSize:        tickSize,\n                    categorySize:    categorySize,\n                    categorySpacing: tickSize - categorySize,\n                    fullBarSize:     fullBarSize,\n                    barSize:         barSize,\n                    barSpacing:      barSpacing,\n                    scale:           scale\n                };\n            },\n            \n            /**\n             * Note: pixel values are not clamped to the scale area.\n             * @private\n             */\n            calculateBarValuePixels: function (datasetIndex, index) {\n                var me = this;\n                var chart = me.chart;\n                var meta = me.getMeta();\n                var scale = me.getValueScale();\n                var datasets = chart.data.datasets;\n                var value = Number(datasets[datasetIndex].data[index]);\n                var stacked = scale.options.stacked;\n                var stack = meta.stack;\n                var start = 0;\n                var i, imeta, ivalue, base, head, size;\n                \n                if (stacked || (stacked === undefined && stack !== undefined)) {\n                    for (i = 0; i < datasetIndex; ++i) {\n                        imeta = chart.getDatasetMeta(i);\n                        \n                        if (imeta.bar &&\n                            imeta.stack === stack &&\n                            imeta.controller.getValueScaleId() === scale.id &&\n                            chart.isDatasetVisible(i)) {\n                            \n                            ivalue = Number(datasets[i].data[index]);\n                            if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n                                start += ivalue;\n                            }\n                        }\n                    }\n                }\n                \n                base = scale.getPixelForValue(start);\n                head = scale.getPixelForValue(start + value);\n                size = (head - base) / 2;\n                \n                return {\n                    size:   size,\n                    base:   base,\n                    head:   head,\n                    center: head + size / 2\n                };\n            },\n            \n            /**\n             * @private\n             */\n            calculateBarIndexPixels: function (datasetIndex, index, ruler) {\n                var me = this;\n                var scale = ruler.scale;\n                var isCombo = me.chart.isCombo;\n                var stackIndex = me.getStackIndex(datasetIndex);\n                var base = scale.getPixelForValue(null, index, datasetIndex, isCombo);\n                var size = ruler.barSize;\n                \n                base -= isCombo ? ruler.tickSize / 2 : 0;\n                base += ruler.fullBarSize * stackIndex;\n                base += ruler.categorySpacing / 2;\n                base += ruler.barSpacing / 2;\n                \n                return {\n                    size:   size,\n                    base:   base,\n                    head:   base + size,\n                    center: base + size / 2\n                };\n            },\n            \n            draw: function () {\n                var me = this;\n                var chart = me.chart;\n                var elements = me.getMeta().data;\n                var dataset = me.getDataset();\n                var ilen = elements.length;\n                var i = 0;\n                var d;\n                \n                helpers.canvas.clipArea(chart.ctx, chart.chartArea);\n                \n                for (; i < ilen; ++i) {\n                    d = dataset.data[i];\n                    if (d !== null && d !== undefined && !isNaN(d)) {\n                        elements[i].draw();\n                    }\n                }\n                \n                helpers.canvas.unclipArea(chart.ctx);\n            },\n            \n            setHoverStyle: function (rectangle) {\n                var dataset = this.chart.data.datasets[rectangle._datasetIndex];\n                var index = rectangle._index;\n                var custom = rectangle.custom || {};\n                var model = rectangle._model;\n                \n                model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n                model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n                model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n            },\n            \n            removeHoverStyle: function (rectangle) {\n                var dataset = this.chart.data.datasets[rectangle._datasetIndex];\n                var index = rectangle._index;\n                var custom = rectangle.custom || {};\n                var model = rectangle._model;\n                var rectangleElementOptions = this.chart.options.elements.rectangle;\n                \n                model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);\n                model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);\n                model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);\n            }\n        });\n        \n        \n        // including horizontalBar in the bar file, instead of a file of its own\n        // it extends bar (like pie extends doughnut)\n        Chart.defaults.horizontalBar = {\n            hover: {\n                mode: 'label'\n            },\n            \n            scales:   {\n                xAxes: [{\n                    type:     'linear',\n                    position: 'bottom'\n                }],\n                yAxes: [{\n                    position: 'left',\n                    type:     'category',\n                    \n                    // Specific to Horizontal Bar Controller\n                    categoryPercentage: 0.8,\n                    barPercentage:      0.9,\n                    \n                    // grid line settings\n                    gridLines: {\n                        offsetGridLines: true\n                    }\n                }]\n            },\n            elements: {\n                rectangle: {\n                    borderSkipped: 'left'\n                }\n            },\n            tooltips: {\n                callbacks: {\n                    title: function (tooltipItems, data) {\n                        // Pick first xLabel for now\n                        var title = '';\n                        \n                        if (tooltipItems.length > 0) {\n                            if (tooltipItems[0].yLabel) {\n                                title = tooltipItems[0].yLabel;\n                            } else if (data.labels.length > 0 && tooltipItems[0].index < data.labels.length) {\n                                title = data.labels[tooltipItems[0].index];\n                            }\n                        }\n                        \n                        return title;\n                    },\n                    label: function (tooltipItem, data) {\n                        var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n                        return datasetLabel + ': ' + tooltipItem.xLabel;\n                    }\n                }\n            }\n        };\n        \n        Chart.controllers.horizontalBar = Chart.controllers.bar.extend({\n            /**\n             * @private\n             */\n            getValueScaleId: function () {\n                return this.getMeta().xAxisID;\n            },\n            \n            /**\n             * @private\n             */\n            getIndexScaleId: function () {\n                return this.getMeta().yAxisID;\n            }\n        });\n    };\n    \n},{}],10:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.bubble = {\n            hover: {\n                mode: 'single'\n            },\n            \n            scales: {\n                xAxes: [{\n                    type: 'linear', // bubble should probably use a linear scale by default\n                    position: 'bottom',\n                    id: 'x-axis-0' // need an ID so datasets can reference the scale\n                }],\n                yAxes: [{\n                    type: 'linear',\n                    position: 'left',\n                    id: 'y-axis-0'\n                }]\n            },\n            \n            tooltips: {\n                callbacks: {\n                    title: function() {\n                        // Title doesn't make sense for scatter since we format the data as a point\n                        return '';\n                    },\n                    label: function(tooltipItem, data) {\n                        var datasetLabel = data.datasets[tooltipItem.datasetIndex].label || '';\n                        var dataPoint = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n                        return datasetLabel + ': (' + tooltipItem.xLabel + ', ' + tooltipItem.yLabel + ', ' + dataPoint.r + ')';\n                    }\n                }\n            }\n        };\n        \n        Chart.controllers.bubble = Chart.DatasetController.extend({\n            \n            dataElementType: Chart.elements.Point,\n            \n            update: function(reset) {\n                var me = this;\n                var meta = me.getMeta();\n                var points = meta.data;\n                \n                // Update Points\n                helpers.each(points, function(point, index) {\n                    me.updateElement(point, index, reset);\n                });\n            },\n            \n            updateElement: function(point, index, reset) {\n                var me = this;\n                var meta = me.getMeta();\n                var xScale = me.getScaleForId(meta.xAxisID);\n                var yScale = me.getScaleForId(meta.yAxisID);\n                \n                var custom = point.custom || {};\n                var dataset = me.getDataset();\n                var data = dataset.data[index];\n                var pointElementOptions = me.chart.options.elements.point;\n                var dsIndex = me.index;\n                \n                helpers.extend(point, {\n                    // Utility\n                    _xScale: xScale,\n                    _yScale: yScale,\n                    _datasetIndex: dsIndex,\n                    _index: index,\n                    \n                    // Desired view properties\n                    _model: {\n                        x: reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex, me.chart.isCombo),\n                        y: reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex),\n                        // Appearance\n                        radius: reset ? 0 : custom.radius ? custom.radius : me.getRadius(data),\n                        \n                        // Tooltip\n                        hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.hitRadius, index, pointElementOptions.hitRadius)\n                    }\n                });\n                \n                // Trick to reset the styles of the point\n                Chart.DatasetController.prototype.removeHoverStyle.call(me, point, pointElementOptions);\n                \n                var model = point._model;\n                model.skip = custom.skip ? custom.skip : (isNaN(model.x) || isNaN(model.y));\n                \n                point.pivot();\n            },\n            \n            getRadius: function(value) {\n                return value.r || this.chart.options.elements.point.radius;\n            },\n            \n            setHoverStyle: function(point) {\n                var me = this;\n                Chart.DatasetController.prototype.setHoverStyle.call(me, point);\n                \n                // Radius\n                var dataset = me.chart.data.datasets[point._datasetIndex];\n                var index = point._index;\n                var custom = point.custom || {};\n                var model = point._model;\n                model.radius = custom.hoverRadius ? custom.hoverRadius : (helpers.getValueAtIndexOrDefault(dataset.hoverRadius, index, me.chart.options.elements.point.hoverRadius)) + me.getRadius(dataset.data[index]);\n            },\n            \n            removeHoverStyle: function(point) {\n                var me = this;\n                Chart.DatasetController.prototype.removeHoverStyle.call(me, point, me.chart.options.elements.point);\n                \n                var dataVal = me.chart.data.datasets[point._datasetIndex].data[point._index];\n                var custom = point.custom || {};\n                var model = point._model;\n                \n                model.radius = custom.radius ? custom.radius : me.getRadius(dataVal);\n            }\n        });\n    };\n    \n},{}],11:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers,\n            defaults = Chart.defaults;\n        \n        defaults.doughnut = {\n            animation: {\n                // Boolean - Whether we animate the rotation of the Doughnut\n                animateRotate: true,\n                // Boolean - Whether we animate scaling the Doughnut from the centre\n                animateScale: false\n            },\n            aspectRatio: 1,\n            hover: {\n                mode: 'single'\n            },\n            legendCallback: function(chart) {\n                var text = [];\n                text.push('<ul class=\"' + chart.id + '-legend\">');\n                \n                var data = chart.data;\n                var datasets = data.datasets;\n                var labels = data.labels;\n                \n                if (datasets.length) {\n                    for (var i = 0; i < datasets[0].data.length; ++i) {\n                        text.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n                        if (labels[i]) {\n                            text.push(labels[i]);\n                        }\n                        text.push('</li>');\n                    }\n                }\n                \n                text.push('</ul>');\n                return text.join('');\n            },\n            legend: {\n                labels: {\n                    generateLabels: function(chart) {\n                        var data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            return data.labels.map(function(label, i) {\n                                var meta = chart.getDatasetMeta(0);\n                                var ds = data.datasets[0];\n                                var arc = meta.data[i];\n                                var custom = arc && arc.custom || {};\n                                var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n                                var arcOpts = chart.options.elements.arc;\n                                var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n                                var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n                                var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n                                \n                                return {\n                                    text: label,\n                                    fillStyle: fill,\n                                    strokeStyle: stroke,\n                                    lineWidth: bw,\n                                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n                                    \n                                    // Extra data used for toggling the correct item\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                \n                onClick: function(e, legendItem) {\n                    var index = legendItem.index;\n                    var chart = this.chart;\n                    var i, ilen, meta;\n                    \n                    for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n                        meta = chart.getDatasetMeta(i);\n                        // toggle visibility of index if exists\n                        if (meta.data[index]) {\n                            meta.data[index].hidden = !meta.data[index].hidden;\n                        }\n                    }\n                    \n                    chart.update();\n                }\n            },\n            \n            // The percentage of the chart that we cut out of the middle.\n            cutoutPercentage: 50,\n            \n            // The rotation of the chart, where the first data arc begins.\n            rotation: Math.PI * -0.5,\n            \n            // The total circumference of the chart.\n            circumference: Math.PI * 2.0,\n            \n            // Need to override these to give a nice default\n            tooltips: {\n                callbacks: {\n                    title: function() {\n                        return '';\n                    },\n                    label: function(tooltipItem, data) {\n                        var dataLabel = data.labels[tooltipItem.index];\n                        var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n                        \n                        if (helpers.isArray(dataLabel)) {\n                            // show value on first line of multiline label\n                            // need to clone because we are changing the value\n                            dataLabel = dataLabel.slice();\n                            dataLabel[0] += value;\n                        } else {\n                            dataLabel += value;\n                        }\n                        \n                        return dataLabel;\n                    }\n                }\n            }\n        };\n        \n        defaults.pie = helpers.clone(defaults.doughnut);\n        helpers.extend(defaults.pie, {\n            cutoutPercentage: 0\n        });\n        \n        \n        Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({\n            \n            dataElementType: Chart.elements.Arc,\n            \n            linkScales: helpers.noop,\n            \n            // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n            getRingIndex: function(datasetIndex) {\n                var ringIndex = 0;\n                \n                for (var j = 0; j < datasetIndex; ++j) {\n                    if (this.chart.isDatasetVisible(j)) {\n                        ++ringIndex;\n                    }\n                }\n                \n                return ringIndex;\n            },\n            \n            update: function(reset) {\n                var me = this;\n                var chart = me.chart,\n                    chartArea = chart.chartArea,\n                    opts = chart.options,\n                    arcOpts = opts.elements.arc,\n                    availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth,\n                    availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth,\n                    minSize = Math.min(availableWidth, availableHeight),\n                    offset = {\n                        x: 0,\n                        y: 0\n                    },\n                    meta = me.getMeta(),\n                    cutoutPercentage = opts.cutoutPercentage,\n                    circumference = opts.circumference;\n                \n                // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n                if (circumference < Math.PI * 2.0) {\n                    var startAngle = opts.rotation % (Math.PI * 2.0);\n                    startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n                    var endAngle = startAngle + circumference;\n                    var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n                    var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n                    var contains0 = (startAngle <= 0 && 0 <= endAngle) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n                    var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n                    var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n                    var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n                    var cutout = cutoutPercentage / 100.0;\n                    var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n                    var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n                    var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n                    minSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n                    offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n                }\n                \n                chart.borderWidth = me.getMaxBorderWidth(meta.data);\n                chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n                chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n                chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n                chart.offsetX = offset.x * chart.outerRadius;\n                chart.offsetY = offset.y * chart.outerRadius;\n                \n                meta.total = me.calculateTotal();\n                \n                me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));\n                me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);\n                \n                helpers.each(meta.data, function(arc, index) {\n                    me.updateElement(arc, index, reset);\n                });\n            },\n            \n            updateElement: function(arc, index, reset) {\n                var me = this;\n                var chart = me.chart,\n                    chartArea = chart.chartArea,\n                    opts = chart.options,\n                    animationOpts = opts.animation,\n                    centerX = (chartArea.left + chartArea.right) / 2,\n                    centerY = (chartArea.top + chartArea.bottom) / 2,\n                    startAngle = opts.rotation, // non reset case handled later\n                    endAngle = opts.rotation, // non reset case handled later\n                    dataset = me.getDataset(),\n                    circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),\n                    innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius,\n                    outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius,\n                    valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n                \n                helpers.extend(arc, {\n                    // Utility\n                    _datasetIndex: me.index,\n                    _index: index,\n                    \n                    // Desired view properties\n                    _model: {\n                        x: centerX + chart.offsetX,\n                        y: centerY + chart.offsetY,\n                        startAngle: startAngle,\n                        endAngle: endAngle,\n                        circumference: circumference,\n                        outerRadius: outerRadius,\n                        innerRadius: innerRadius,\n                        label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n                    }\n                });\n                \n                var model = arc._model;\n                // Resets the visual styles\n                this.removeHoverStyle(arc);\n                \n                // Set correct angles if not resetting\n                if (!reset || !animationOpts.animateRotate) {\n                    if (index === 0) {\n                        model.startAngle = opts.rotation;\n                    } else {\n                        model.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n                    }\n                    \n                    model.endAngle = model.startAngle + model.circumference;\n                }\n                \n                arc.pivot();\n            },\n            \n            removeHoverStyle: function(arc) {\n                Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n            },\n            \n            calculateTotal: function() {\n                var dataset = this.getDataset();\n                var meta = this.getMeta();\n                var total = 0;\n                var value;\n                \n                helpers.each(meta.data, function(element, index) {\n                    value = dataset.data[index];\n                    if (!isNaN(value) && !element.hidden) {\n                        total += Math.abs(value);\n                    }\n                });\n                \n                /* if (total === 0) {\n                 total = NaN;\n                 }*/\n                \n                return total;\n            },\n            \n            calculateCircumference: function(value) {\n                var total = this.getMeta().total;\n                if (total > 0 && !isNaN(value)) {\n                    return (Math.PI * 2.0) * (value / total);\n                }\n                return 0;\n            },\n            \n            // gets the max border or hover width to properly scale pie charts\n            getMaxBorderWidth: function(elements) {\n                var max = 0,\n                    index = this.index,\n                    length = elements.length,\n                    borderWidth,\n                    hoverWidth;\n                \n                for (var i = 0; i < length; i++) {\n                    borderWidth = elements[i]._model ? elements[i]._model.borderWidth : 0;\n                    hoverWidth = elements[i]._chart ? elements[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;\n                    \n                    max = borderWidth > max ? borderWidth : max;\n                    max = hoverWidth > max ? hoverWidth : max;\n                }\n                return max;\n            }\n        });\n    };\n    \n},{}],12:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.line = {\n            showLines: true,\n            spanGaps: false,\n            \n            hover: {\n                mode: 'label'\n            },\n            \n            scales: {\n                xAxes: [{\n                    type: 'category',\n                    id: 'x-axis-0'\n                }],\n                yAxes: [{\n                    type: 'linear',\n                    id: 'y-axis-0'\n                }]\n            }\n        };\n        \n        function lineEnabled(dataset, options) {\n            return helpers.getValueOrDefault(dataset.showLine, options.showLines);\n        }\n        \n        Chart.controllers.line = Chart.DatasetController.extend({\n            \n            datasetElementType: Chart.elements.Line,\n            \n            dataElementType: Chart.elements.Point,\n            \n            update: function(reset) {\n                var me = this;\n                var meta = me.getMeta();\n                var line = meta.dataset;\n                var points = meta.data || [];\n                var options = me.chart.options;\n                var lineElementOptions = options.elements.line;\n                var scale = me.getScaleForId(meta.yAxisID);\n                var i, ilen, custom;\n                var dataset = me.getDataset();\n                var showLine = lineEnabled(dataset, options);\n                \n                // Update Line\n                if (showLine) {\n                    custom = line.custom || {};\n                    \n                    // Compatibility: If the properties are defined with only the old name, use those values\n                    if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n                        dataset.lineTension = dataset.tension;\n                    }\n                    \n                    // Utility\n                    line._scale = scale;\n                    line._datasetIndex = me.index;\n                    // Data\n                    line._children = points;\n                    // Model\n                    line._model = {\n                        // Appearance\n                        // The default behavior of lines is to break at null values, according\n                        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n                        // This option gives lines the ability to span gaps\n                        spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n                        tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n                        backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n                        borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n                        borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n                        borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n                        borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n                        borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n                        borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n                        fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n                        steppedLine: custom.steppedLine ? custom.steppedLine : helpers.getValueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n                        cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.getValueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n                    };\n                    \n                    line.pivot();\n                }\n                \n                // Update Points\n                for (i=0, ilen=points.length; i<ilen; ++i) {\n                    me.updateElement(points[i], i, reset);\n                }\n                \n                if (showLine && line._model.tension !== 0) {\n                    me.updateBezierControlPoints();\n                }\n                \n                // Now pivot the point for animation\n                for (i=0, ilen=points.length; i<ilen; ++i) {\n                    points[i].pivot();\n                }\n            },\n            \n            getPointBackgroundColor: function(point, index) {\n                var backgroundColor = this.chart.options.elements.point.backgroundColor;\n                var dataset = this.getDataset();\n                var custom = point.custom || {};\n                \n                if (custom.backgroundColor) {\n                    backgroundColor = custom.backgroundColor;\n                } else if (dataset.pointBackgroundColor) {\n                    backgroundColor = helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n                } else if (dataset.backgroundColor) {\n                    backgroundColor = dataset.backgroundColor;\n                }\n                \n                return backgroundColor;\n            },\n            \n            getPointBorderColor: function(point, index) {\n                var borderColor = this.chart.options.elements.point.borderColor;\n                var dataset = this.getDataset();\n                var custom = point.custom || {};\n                \n                if (custom.borderColor) {\n                    borderColor = custom.borderColor;\n                } else if (dataset.pointBorderColor) {\n                    borderColor = helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n                } else if (dataset.borderColor) {\n                    borderColor = dataset.borderColor;\n                }\n                \n                return borderColor;\n            },\n            \n            getPointBorderWidth: function(point, index) {\n                var borderWidth = this.chart.options.elements.point.borderWidth;\n                var dataset = this.getDataset();\n                var custom = point.custom || {};\n                \n                if (!isNaN(custom.borderWidth)) {\n                    borderWidth = custom.borderWidth;\n                } else if (!isNaN(dataset.pointBorderWidth)) {\n                    borderWidth = helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n                } else if (!isNaN(dataset.borderWidth)) {\n                    borderWidth = dataset.borderWidth;\n                }\n                \n                return borderWidth;\n            },\n            \n            updateElement: function(point, index, reset) {\n                var me = this;\n                var meta = me.getMeta();\n                var custom = point.custom || {};\n                var dataset = me.getDataset();\n                var datasetIndex = me.index;\n                var value = dataset.data[index];\n                var yScale = me.getScaleForId(meta.yAxisID);\n                var xScale = me.getScaleForId(meta.xAxisID);\n                var pointOptions = me.chart.options.elements.point;\n                var x, y;\n                var labels = me.chart.data.labels || [];\n                var includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;\n                \n                // Compatibility: If the properties are defined with only the old name, use those values\n                if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n                    dataset.pointRadius = dataset.radius;\n                }\n                if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n                    dataset.pointHitRadius = dataset.hitRadius;\n                }\n                \n                x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);\n                y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n                \n                // Utility\n                point._xScale = xScale;\n                point._yScale = yScale;\n                point._datasetIndex = datasetIndex;\n                point._index = index;\n                \n                // Desired view properties\n                point._model = {\n                    x: x,\n                    y: y,\n                    skip: custom.skip || isNaN(x) || isNaN(y),\n                    // Appearance\n                    radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n                    pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n                    backgroundColor: me.getPointBackgroundColor(point, index),\n                    borderColor: me.getPointBorderColor(point, index),\n                    borderWidth: me.getPointBorderWidth(point, index),\n                    tension: meta.dataset._model ? meta.dataset._model.tension : 0,\n                    steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n                    // Tooltip\n                    hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n                };\n            },\n            \n            calculatePointY: function(value, index, datasetIndex) {\n                var me = this;\n                var chart = me.chart;\n                var meta = me.getMeta();\n                var yScale = me.getScaleForId(meta.yAxisID);\n                var sumPos = 0;\n                var sumNeg = 0;\n                var i, ds, dsMeta;\n                \n                if (yScale.options.stacked) {\n                    for (i = 0; i < datasetIndex; i++) {\n                        ds = chart.data.datasets[i];\n                        dsMeta = chart.getDatasetMeta(i);\n                        if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n                            var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n                            if (stackedRightValue < 0) {\n                                sumNeg += stackedRightValue || 0;\n                            } else {\n                                sumPos += stackedRightValue || 0;\n                            }\n                        }\n                    }\n                    \n                    var rightValue = Number(yScale.getRightValue(value));\n                    if (rightValue < 0) {\n                        return yScale.getPixelForValue(sumNeg + rightValue);\n                    }\n                    return yScale.getPixelForValue(sumPos + rightValue);\n                }\n                \n                return yScale.getPixelForValue(value);\n            },\n            \n            updateBezierControlPoints: function() {\n                var me = this;\n                var meta = me.getMeta();\n                var area = me.chart.chartArea;\n                var points = (meta.data || []);\n                var i, ilen, point, model, controlPoints;\n                \n                // Only consider points that are drawn in case the spanGaps option is used\n                if (meta.dataset._model.spanGaps) {\n                    points = points.filter(function(pt) {\n                        return !pt._model.skip;\n                    });\n                }\n                \n                function capControlPoint(pt, min, max) {\n                    return Math.max(Math.min(pt, max), min);\n                }\n                \n                if (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n                    helpers.splineCurveMonotone(points);\n                } else {\n                    for (i = 0, ilen = points.length; i < ilen; ++i) {\n                        point = points[i];\n                        model = point._model;\n                        controlPoints = helpers.splineCurve(\n                            helpers.previousItem(points, i)._model,\n                            model,\n                            helpers.nextItem(points, i)._model,\n                            meta.dataset._model.tension\n                        );\n                        model.controlPointPreviousX = controlPoints.previous.x;\n                        model.controlPointPreviousY = controlPoints.previous.y;\n                        model.controlPointNextX = controlPoints.next.x;\n                        model.controlPointNextY = controlPoints.next.y;\n                    }\n                }\n                \n                if (me.chart.options.elements.line.capBezierPoints) {\n                    for (i = 0, ilen = points.length; i < ilen; ++i) {\n                        model = points[i]._model;\n                        model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n                        model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n                        model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n                        model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n                    }\n                }\n            },\n            \n            draw: function() {\n                var me = this;\n                var chart = me.chart;\n                var meta = me.getMeta();\n                var points = meta.data || [];\n                var area = chart.chartArea;\n                var ilen = points.length;\n                var i = 0;\n                \n                Chart.canvasHelpers.clipArea(chart.ctx, area);\n                \n                if (lineEnabled(me.getDataset(), chart.options)) {\n                    meta.dataset.draw();\n                }\n                \n                Chart.canvasHelpers.unclipArea(chart.ctx);\n                \n                // Draw the points\n                for (; i<ilen; ++i) {\n                    points[i].draw(area);\n                }\n            },\n            \n            setHoverStyle: function(point) {\n                // Point\n                var dataset = this.chart.data.datasets[point._datasetIndex];\n                var index = point._index;\n                var custom = point.custom || {};\n                var model = point._model;\n                \n                model.radius = custom.hoverRadius || helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n                model.backgroundColor = custom.hoverBackgroundColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n                model.borderColor = custom.hoverBorderColor || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n                model.borderWidth = custom.hoverBorderWidth || helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n            },\n            \n            removeHoverStyle: function(point) {\n                var me = this;\n                var dataset = me.chart.data.datasets[point._datasetIndex];\n                var index = point._index;\n                var custom = point.custom || {};\n                var model = point._model;\n                \n                // Compatibility: If the properties are defined with only the old name, use those values\n                if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n                    dataset.pointRadius = dataset.radius;\n                }\n                \n                model.radius = custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n                model.backgroundColor = me.getPointBackgroundColor(point, index);\n                model.borderColor = me.getPointBorderColor(point, index);\n                model.borderWidth = me.getPointBorderWidth(point, index);\n            }\n        });\n    };\n    \n},{}],13:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.polarArea = {\n            \n            scale: {\n                type: 'radialLinear',\n                angleLines: {\n                    display: false\n                },\n                gridLines: {\n                    circular: true\n                },\n                pointLabels: {\n                    display: false\n                },\n                ticks: {\n                    beginAtZero: true\n                }\n            },\n            \n            // Boolean - Whether to animate the rotation of the chart\n            animation: {\n                animateRotate: true,\n                animateScale: true\n            },\n            \n            startAngle: -0.5 * Math.PI,\n            aspectRatio: 1,\n            legendCallback: function(chart) {\n                var text = [];\n                text.push('<ul class=\"' + chart.id + '-legend\">');\n                \n                var data = chart.data;\n                var datasets = data.datasets;\n                var labels = data.labels;\n                \n                if (datasets.length) {\n                    for (var i = 0; i < datasets[0].data.length; ++i) {\n                        text.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n                        if (labels[i]) {\n                            text.push(labels[i]);\n                        }\n                        text.push('</li>');\n                    }\n                }\n                \n                text.push('</ul>');\n                return text.join('');\n            },\n            legend: {\n                labels: {\n                    generateLabels: function(chart) {\n                        var data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            return data.labels.map(function(label, i) {\n                                var meta = chart.getDatasetMeta(0);\n                                var ds = data.datasets[0];\n                                var arc = meta.data[i];\n                                var custom = arc.custom || {};\n                                var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n                                var arcOpts = chart.options.elements.arc;\n                                var fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);\n                                var stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);\n                                var bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);\n                                \n                                return {\n                                    text: label,\n                                    fillStyle: fill,\n                                    strokeStyle: stroke,\n                                    lineWidth: bw,\n                                    hidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n                                    \n                                    // Extra data used for toggling the correct item\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                \n                onClick: function(e, legendItem) {\n                    var index = legendItem.index;\n                    var chart = this.chart;\n                    var i, ilen, meta;\n                    \n                    for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n                        meta = chart.getDatasetMeta(i);\n                        meta.data[index].hidden = !meta.data[index].hidden;\n                    }\n                    \n                    chart.update();\n                }\n            },\n            \n            // Need to override these to give a nice default\n            tooltips: {\n                callbacks: {\n                    title: function() {\n                        return '';\n                    },\n                    label: function(tooltipItem, data) {\n                        return data.labels[tooltipItem.index] + ': ' + tooltipItem.yLabel;\n                    }\n                }\n            }\n        };\n        \n        Chart.controllers.polarArea = Chart.DatasetController.extend({\n            \n            dataElementType: Chart.elements.Arc,\n            \n            linkScales: helpers.noop,\n            \n            update: function(reset) {\n                var me = this;\n                var chart = me.chart;\n                var chartArea = chart.chartArea;\n                var meta = me.getMeta();\n                var opts = chart.options;\n                var arcOpts = opts.elements.arc;\n                var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n                chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);\n                chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n                chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n                \n                me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n                me.innerRadius = me.outerRadius - chart.radiusLength;\n                \n                meta.count = me.countVisibleElements();\n                \n                helpers.each(meta.data, function(arc, index) {\n                    me.updateElement(arc, index, reset);\n                });\n            },\n            \n            updateElement: function(arc, index, reset) {\n                var me = this;\n                var chart = me.chart;\n                var dataset = me.getDataset();\n                var opts = chart.options;\n                var animationOpts = opts.animation;\n                var scale = chart.scale;\n                var getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;\n                var labels = chart.data.labels;\n                \n                var circumference = me.calculateCircumference(dataset.data[index]);\n                var centerX = scale.xCenter;\n                var centerY = scale.yCenter;\n                \n                // If there is NaN data before us, we need to calculate the starting angle correctly.\n                // We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data\n                var visibleCount = 0;\n                var meta = me.getMeta();\n                for (var i = 0; i < index; ++i) {\n                    if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {\n                        ++visibleCount;\n                    }\n                }\n                \n                // var negHalfPI = -0.5 * Math.PI;\n                var datasetStartAngle = opts.startAngle;\n                var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n                var startAngle = datasetStartAngle + (circumference * visibleCount);\n                var endAngle = startAngle + (arc.hidden ? 0 : circumference);\n                \n                var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n                \n                helpers.extend(arc, {\n                    // Utility\n                    _datasetIndex: me.index,\n                    _index: index,\n                    _scale: scale,\n                    \n                    // Desired view properties\n                    _model: {\n                        x: centerX,\n                        y: centerY,\n                        innerRadius: 0,\n                        outerRadius: reset ? resetRadius : distance,\n                        startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n                        endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n                        label: getValueAtIndexOrDefault(labels, index, labels[index])\n                    }\n                });\n                \n                // Apply border and fill style\n                me.removeHoverStyle(arc);\n                \n                arc.pivot();\n            },\n            \n            removeHoverStyle: function(arc) {\n                Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);\n            },\n            \n            countVisibleElements: function() {\n                var dataset = this.getDataset();\n                var meta = this.getMeta();\n                var count = 0;\n                \n                helpers.each(meta.data, function(element, index) {\n                    if (!isNaN(dataset.data[index]) && !element.hidden) {\n                        count++;\n                    }\n                });\n                \n                return count;\n            },\n            \n            calculateCircumference: function(value) {\n                var count = this.getMeta().count;\n                if (count > 0 && !isNaN(value)) {\n                    return (2 * Math.PI) / count;\n                }\n                return 0;\n            }\n        });\n    };\n    \n},{}],14:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.radar = {\n            aspectRatio: 1,\n            scale: {\n                type: 'radialLinear'\n            },\n            elements: {\n                line: {\n                    tension: 0 // no bezier in radar\n                }\n            }\n        };\n        \n        Chart.controllers.radar = Chart.DatasetController.extend({\n            \n            datasetElementType: Chart.elements.Line,\n            \n            dataElementType: Chart.elements.Point,\n            \n            linkScales: helpers.noop,\n            \n            update: function(reset) {\n                var me = this;\n                var meta = me.getMeta();\n                var line = meta.dataset;\n                var points = meta.data;\n                var custom = line.custom || {};\n                var dataset = me.getDataset();\n                var lineElementOptions = me.chart.options.elements.line;\n                var scale = me.chart.scale;\n                \n                // Compatibility: If the properties are defined with only the old name, use those values\n                if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n                    dataset.lineTension = dataset.tension;\n                }\n                \n                helpers.extend(meta.dataset, {\n                    // Utility\n                    _datasetIndex: me.index,\n                    _scale: scale,\n                    // Data\n                    _children: points,\n                    _loop: true,\n                    // Model\n                    _model: {\n                        // Appearance\n                        tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, lineElementOptions.tension),\n                        backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n                        borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n                        borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n                        fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n                        borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n                        borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n                        borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n                        borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n                    }\n                });\n                \n                meta.dataset.pivot();\n                \n                // Update Points\n                helpers.each(points, function(point, index) {\n                    me.updateElement(point, index, reset);\n                }, me);\n                \n                // Update bezier control points\n                me.updateBezierControlPoints();\n            },\n            updateElement: function(point, index, reset) {\n                var me = this;\n                var custom = point.custom || {};\n                var dataset = me.getDataset();\n                var scale = me.chart.scale;\n                var pointElementOptions = me.chart.options.elements.point;\n                var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n                \n                // Compatibility: If the properties are defined with only the old name, use those values\n                if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n                    dataset.pointRadius = dataset.radius;\n                }\n                if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n                    dataset.pointHitRadius = dataset.hitRadius;\n                }\n                \n                helpers.extend(point, {\n                    // Utility\n                    _datasetIndex: me.index,\n                    _index: index,\n                    _scale: scale,\n                    \n                    // Desired view properties\n                    _model: {\n                        x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales\n                        y: reset ? scale.yCenter : pointPosition.y,\n                        \n                        // Appearance\n                        tension: custom.tension ? custom.tension : helpers.getValueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),\n                        radius: custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),\n                        backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),\n                        borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),\n                        borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),\n                        pointStyle: custom.pointStyle ? custom.pointStyle : helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),\n                        \n                        // Tooltip\n                        hitRadius: custom.hitRadius ? custom.hitRadius : helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)\n                    }\n                });\n                \n                point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));\n            },\n            updateBezierControlPoints: function() {\n                var chartArea = this.chart.chartArea;\n                var meta = this.getMeta();\n                \n                helpers.each(meta.data, function(point, index) {\n                    var model = point._model;\n                    var controlPoints = helpers.splineCurve(\n                        helpers.previousItem(meta.data, index, true)._model,\n                        model,\n                        helpers.nextItem(meta.data, index, true)._model,\n                        model.tension\n                    );\n                    \n                    // Prevent the bezier going outside of the bounds of the graph\n                    model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);\n                    model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);\n                    \n                    model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);\n                    model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);\n                    \n                    // Now pivot the point for animation\n                    point.pivot();\n                });\n            },\n            \n            setHoverStyle: function(point) {\n                // Point\n                var dataset = this.chart.data.datasets[point._datasetIndex];\n                var custom = point.custom || {};\n                var index = point._index;\n                var model = point._model;\n                \n                model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.getValueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n                model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n                model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n                model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n            },\n            \n            removeHoverStyle: function(point) {\n                var dataset = this.chart.data.datasets[point._datasetIndex];\n                var custom = point.custom || {};\n                var index = point._index;\n                var model = point._model;\n                var pointElementOptions = this.chart.options.elements.point;\n                \n                model.radius = custom.radius ? custom.radius : helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);\n                model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);\n                model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);\n                model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);\n            }\n        });\n    };\n    \n},{}],15:[function(require,module,exports){\n    /* global window: false */\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.global.animation = {\n            duration: 1000,\n            easing: 'easeOutQuart',\n            onProgress: helpers.noop,\n            onComplete: helpers.noop\n        };\n        \n        Chart.Animation = Chart.Element.extend({\n            chart: null, // the animation associated chart instance\n            currentStep: 0, // the current animation step\n            numSteps: 60, // default number of steps\n            easing: '', // the easing to use for this animation\n            render: null, // render function used by the animation service\n            \n            onAnimationProgress: null, // user specified callback to fire on each step of the animation\n            onAnimationComplete: null, // user specified callback to fire when the animation finishes\n        });\n        \n        Chart.animationService = {\n            frameDuration: 17,\n            animations: [],\n            dropFrames: 0,\n            request: null,\n            \n            /**\n             * @param {Chart} chart - The chart to animate.\n             * @param {Chart.Animation} animation - The animation that we will animate.\n             * @param {Number} duration - The animation duration in ms.\n             * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n             */\n            addAnimation: function(chart, animation, duration, lazy) {\n                var animations = this.animations;\n                var i, ilen;\n                \n                animation.chart = chart;\n                \n                if (!lazy) {\n                    chart.animating = true;\n                }\n                \n                for (i=0, ilen=animations.length; i < ilen; ++i) {\n                    if (animations[i].chart === chart) {\n                        animations[i] = animation;\n                        return;\n                    }\n                }\n                \n                animations.push(animation);\n                \n                // If there are no animations queued, manually kickstart a digest, for lack of a better word\n                if (animations.length === 1) {\n                    this.requestAnimationFrame();\n                }\n            },\n            \n            cancelAnimation: function(chart) {\n                var index = helpers.findIndex(this.animations, function(animation) {\n                    return animation.chart === chart;\n                });\n                \n                if (index !== -1) {\n                    this.animations.splice(index, 1);\n                    chart.animating = false;\n                }\n            },\n            \n            requestAnimationFrame: function() {\n                var me = this;\n                if (me.request === null) {\n                    // Skip animation frame requests until the active one is executed.\n                    // This can happen when processing mouse events, e.g. 'mousemove'\n                    // and 'mouseout' events will trigger multiple renders.\n                    me.request = helpers.requestAnimFrame.call(window, function() {\n                        me.request = null;\n                        me.startDigest();\n                    });\n                }\n            },\n            \n            /**\n             * @private\n             */\n            startDigest: function() {\n                var me = this;\n                var startTime = Date.now();\n                var framesToDrop = 0;\n                \n                if (me.dropFrames > 1) {\n                    framesToDrop = Math.floor(me.dropFrames);\n                    me.dropFrames = me.dropFrames % 1;\n                }\n                \n                me.advance(1 + framesToDrop);\n                \n                var endTime = Date.now();\n                \n                me.dropFrames += (endTime - startTime) / me.frameDuration;\n                \n                // Do we have more stuff to animate?\n                if (me.animations.length > 0) {\n                    me.requestAnimationFrame();\n                }\n            },\n            \n            /**\n             * @private\n             */\n            advance: function(count) {\n                var animations = this.animations;\n                var animation, chart;\n                var i = 0;\n                \n                while (i < animations.length) {\n                    animation = animations[i];\n                    chart = animation.chart;\n                    \n                    animation.currentStep = (animation.currentStep || 0) + count;\n                    animation.currentStep = Math.min(animation.currentStep, animation.numSteps);\n                    \n                    helpers.callback(animation.render, [chart, animation], chart);\n                    helpers.callback(animation.onAnimationProgress, [animation], chart);\n                    \n                    if (animation.currentStep >= animation.numSteps) {\n                        helpers.callback(animation.onAnimationComplete, [animation], chart);\n                        chart.animating = false;\n                        animations.splice(i, 1);\n                    } else {\n                        ++i;\n                    }\n                }\n            }\n        };\n        \n        /**\n         * Provided for backward compatibility, use Chart.Animation instead\n         * @prop Chart.Animation#animationObject\n         * @deprecated since version 2.6.0\n         * @todo remove at version 3\n         */\n        Object.defineProperty(Chart.Animation.prototype, 'animationObject', {\n            get: function() {\n                return this;\n            }\n        });\n        \n        /**\n         * Provided for backward compatibility, use Chart.Animation#chart instead\n         * @prop Chart.Animation#chartInstance\n         * @deprecated since version 2.6.0\n         * @todo remove at version 3\n         */\n        Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {\n            get: function() {\n                return this.chart;\n            },\n            set: function(value) {\n                this.chart = value;\n            }\n        });\n        \n    };\n    \n},{}],16:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        // Global Chart canvas helpers object for drawing items to canvas\n        var helpers = Chart.canvasHelpers = {};\n        \n        helpers.drawPoint = function(ctx, pointStyle, radius, x, y) {\n            var type, edgeLength, xOffset, yOffset, height, size;\n            \n            if (typeof pointStyle === 'object') {\n                type = pointStyle.toString();\n                if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n                    ctx.drawImage(pointStyle, x - pointStyle.width / 2, y - pointStyle.height / 2, pointStyle.width, pointStyle.height);\n                    return;\n                }\n            }\n            \n            if (isNaN(radius) || radius <= 0) {\n                return;\n            }\n            \n            switch (pointStyle) {\n                // Default includes circle\n                default:\n                    ctx.beginPath();\n                    ctx.arc(x, y, radius, 0, Math.PI * 2);\n                    ctx.closePath();\n                    ctx.fill();\n                    break;\n                case 'triangle':\n                    ctx.beginPath();\n                    edgeLength = 3 * radius / Math.sqrt(3);\n                    height = edgeLength * Math.sqrt(3) / 2;\n                    ctx.moveTo(x - edgeLength / 2, y + height / 3);\n                    ctx.lineTo(x + edgeLength / 2, y + height / 3);\n                    ctx.lineTo(x, y - 2 * height / 3);\n                    ctx.closePath();\n                    ctx.fill();\n                    break;\n                case 'rect':\n                    size = 1 / Math.SQRT2 * radius;\n                    ctx.beginPath();\n                    ctx.fillRect(x - size, y - size, 2 * size, 2 * size);\n                    ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);\n                    break;\n                case 'rectRounded':\n                    var offset = radius / Math.SQRT2;\n                    var leftX = x - offset;\n                    var topY = y - offset;\n                    var sideSize = Math.SQRT2 * radius;\n                    Chart.helpers.drawRoundedRectangle(ctx, leftX, topY, sideSize, sideSize, radius / 2);\n                    ctx.fill();\n                    break;\n                case 'rectRot':\n                    size = 1 / Math.SQRT2 * radius;\n                    ctx.beginPath();\n                    ctx.moveTo(x - size, y);\n                    ctx.lineTo(x, y + size);\n                    ctx.lineTo(x + size, y);\n                    ctx.lineTo(x, y - size);\n                    ctx.closePath();\n                    ctx.fill();\n                    break;\n                case 'cross':\n                    ctx.beginPath();\n                    ctx.moveTo(x, y + radius);\n                    ctx.lineTo(x, y - radius);\n                    ctx.moveTo(x - radius, y);\n                    ctx.lineTo(x + radius, y);\n                    ctx.closePath();\n                    break;\n                case 'crossRot':\n                    ctx.beginPath();\n                    xOffset = Math.cos(Math.PI / 4) * radius;\n                    yOffset = Math.sin(Math.PI / 4) * radius;\n                    ctx.moveTo(x - xOffset, y - yOffset);\n                    ctx.lineTo(x + xOffset, y + yOffset);\n                    ctx.moveTo(x - xOffset, y + yOffset);\n                    ctx.lineTo(x + xOffset, y - yOffset);\n                    ctx.closePath();\n                    break;\n                case 'star':\n                    ctx.beginPath();\n                    ctx.moveTo(x, y + radius);\n                    ctx.lineTo(x, y - radius);\n                    ctx.moveTo(x - radius, y);\n                    ctx.lineTo(x + radius, y);\n                    xOffset = Math.cos(Math.PI / 4) * radius;\n                    yOffset = Math.sin(Math.PI / 4) * radius;\n                    ctx.moveTo(x - xOffset, y - yOffset);\n                    ctx.lineTo(x + xOffset, y + yOffset);\n                    ctx.moveTo(x - xOffset, y + yOffset);\n                    ctx.lineTo(x + xOffset, y - yOffset);\n                    ctx.closePath();\n                    break;\n                case 'line':\n                    ctx.beginPath();\n                    ctx.moveTo(x - radius, y);\n                    ctx.lineTo(x + radius, y);\n                    ctx.closePath();\n                    break;\n                case 'dash':\n                    ctx.beginPath();\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + radius, y);\n                    ctx.closePath();\n                    break;\n            }\n            \n            ctx.stroke();\n        };\n        \n        helpers.clipArea = function(ctx, clipArea) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(clipArea.left, clipArea.top, clipArea.right - clipArea.left, clipArea.bottom - clipArea.top);\n            ctx.clip();\n        };\n        \n        helpers.unclipArea = function(ctx) {\n            ctx.restore();\n        };\n        \n        helpers.lineTo = function(ctx, previous, target, flip) {\n            if (target.steppedLine) {\n                if (target.steppedLine === 'after') {\n                    ctx.lineTo(previous.x, target.y);\n                } else {\n                    ctx.lineTo(target.x, previous.y);\n                }\n                ctx.lineTo(target.x, target.y);\n                return;\n            }\n            \n            if (!target.tension) {\n                ctx.lineTo(target.x, target.y);\n                return;\n            }\n            \n            ctx.bezierCurveTo(\n                flip? previous.controlPointPreviousX : previous.controlPointNextX,\n                flip? previous.controlPointPreviousY : previous.controlPointNextY,\n                flip? target.controlPointNextX : target.controlPointPreviousX,\n                flip? target.controlPointNextY : target.controlPointPreviousY,\n                target.x,\n                target.y);\n        };\n        \n        Chart.helpers.canvas = helpers;\n    };\n    \n},{}],17:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function (Chart) {\n        \n        var helpers = Chart.helpers;\n        var plugins = Chart.plugins;\n        var platform = Chart.platform;\n        \n        // Create a dictionary of chart types, to allow for extension of existing types\n        Chart.types = {};\n        \n        // Store a reference to each instance - allowing us to globally resize chart instances on window resize.\n        // Destroy method on the chart will remove the instance of the chart from this reference.\n        Chart.instances = {};\n        \n        // Controllers available for dataset visualization eg. bar, line, slice, etc.\n        Chart.controllers = {};\n        \n        /**\n         * Initializes the given config with global and chart default values.\n         */\n        function initConfig(config) {\n            config = config || {};\n            \n            // Do NOT use configMerge() for the data object because this method merges arrays\n            // and so would change references to labels and datasets, preventing data updates.\n            var data = config.data = config.data || {};\n            data.datasets = data.datasets || [];\n            data.labels = data.labels || [];\n            \n            config.options = helpers.configMerge(\n                Chart.defaults.global,\n                Chart.defaults[config.type],\n                config.options || {});\n            \n            return config;\n        }\n        \n        /**\n         * Updates the config of the chart\n         * @param chart {Chart} chart to update the options for\n         */\n        function updateConfig(chart) {\n            var newOptions = chart.options;\n            \n            // Update Scale(s) with options\n            if (newOptions.scale) {\n                chart.scale.options = newOptions.scale;\n            } else if (newOptions.scales) {\n                newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function (scaleOptions) {\n                    chart.scales[scaleOptions.id].options = scaleOptions;\n                });\n            }\n            \n            // Tooltip\n            chart.tooltip._options = newOptions.tooltips;\n        }\n        \n        function positionIsHorizontal(position) {\n            return position === 'top' || position === 'bottom';\n        }\n        \n        helpers.extend(Chart.prototype, /** @lends Chart */ {\n            /**\n             * @private\n             */\n            construct: function (item, config) {\n                var me = this;\n                \n                config = initConfig(config);\n                \n                var context = platform.acquireContext(item, config);\n                var canvas = context && context.canvas;\n                var height = canvas && canvas.height;\n                var width = canvas && canvas.width;\n                \n                me.id = helpers.uid();\n                me.ctx = context;\n                me.canvas = canvas;\n                me.config = config;\n                me.width = width;\n                me.height = height;\n                me.aspectRatio = height ? width / height : null;\n                me.options = config.options;\n                me._bufferedRender = false;\n                \n                /**\n                 * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n                 * the \"instance\" still need to be defined since it might be called from plugins.\n                 * @prop Chart#chart\n                 * @deprecated since version 2.6.0\n                 * @todo remove at version 3\n                 * @private\n                 */\n                me.chart = me;\n                me.controller = me;  // chart.chart.controller #inception\n                \n                // Add the chart instance to the global namespace\n                Chart.instances[me.id] = me;\n                \n                // Define alias to the config data: `chart.data === chart.config.data`\n                Object.defineProperty(me, 'data', {\n                    get: function () {\n                        return me.config.data;\n                    },\n                    set: function (value) {\n                        me.config.data = value;\n                    }\n                });\n                \n                if (!context || !canvas) {\n                    // The given item is not a compatible context2d element, let's return before finalizing\n                    // the chart initialization but after setting basic chart / controller properties that\n                    // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n                    // https://github.com/chartjs/Chart.js/issues/2807\n                    console.error(\"Failed to create chart: can't acquire context from the given item\");\n                    return;\n                }\n                \n                me.initialize();\n                me.update();\n            },\n            \n            /**\n             * @private\n             */\n            initialize: function () {\n                var me = this;\n                \n                // Before init plugin notification\n                plugins.notify(me, 'beforeInit');\n                \n                helpers.retinaScale(me);\n                \n                me.bindEvents();\n                \n                if (me.options.responsive) {\n                    // Initial resize before chart draws (must be silent to preserve initial animations).\n                    me.resize(true);\n                }\n                \n                // Make sure scales have IDs and are built before we build any controllers.\n                me.ensureScalesHaveIDs();\n                me.buildScales();\n                me.initToolTip();\n                \n                // After init plugin notification\n                plugins.notify(me, 'afterInit');\n                \n                return me;\n            },\n            \n            clear: function () {\n                helpers.clear(this);\n                return this;\n            },\n            \n            stop: function () {\n                // Stops any current animation loop occurring\n                Chart.animationService.cancelAnimation(this);\n                return this;\n            },\n            \n            resize: function (silent) {\n                var me = this;\n                var options = me.options;\n                var canvas = me.canvas;\n                var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n                \n                // the canvas render width and height will be casted to integers so make sure that\n                // the canvas display style uses the same integer values to avoid blurring effect.\n                var newWidth = Math.floor(helpers.getMaximumWidth(canvas));\n                var newHeight = Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas));\n                \n                if (me.width === newWidth && me.height === newHeight) {\n                    return;\n                }\n                \n                canvas.width = me.width = newWidth;\n                canvas.height = me.height = newHeight;\n                canvas.style.width = newWidth + 'px';\n                canvas.style.height = newHeight + 'px';\n                \n                helpers.retinaScale(me);\n                \n                if (!silent) {\n                    // Notify any plugins about the resize\n                    var newSize = {width: newWidth, height: newHeight};\n                    plugins.notify(me, 'resize', [newSize]);\n                    \n                    // Notify of resize\n                    if (me.options.onResize) {\n                        me.options.onResize(me, newSize);\n                    }\n                    \n                    me.stop();\n                    me.update(me.options.responsiveAnimationDuration);\n                }\n            },\n            \n            ensureScalesHaveIDs: function () {\n                var options = this.options;\n                var scalesOptions = options.scales || {};\n                var scaleOptions = options.scale;\n                \n                helpers.each(scalesOptions.xAxes, function (xAxisOptions, index) {\n                    xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n                });\n                \n                helpers.each(scalesOptions.yAxes, function (yAxisOptions, index) {\n                    yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n                });\n                \n                if (scaleOptions) {\n                    scaleOptions.id = scaleOptions.id || 'scale';\n                }\n            },\n            \n            /**\n             * Builds a map of scale ID to scale object for future lookup.\n             */\n            buildScales: function () {\n                var me = this;\n                var options = me.options;\n                var scales = me.scales = {};\n                var items = [];\n                \n                if (options.scales) {\n                    items = items.concat(\n                        (options.scales.xAxes || []).map(function (xAxisOptions) {\n                            return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n                        }),\n                        (options.scales.yAxes || []).map(function (yAxisOptions) {\n                            return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n                        })\n                    );\n                }\n                \n                if (options.scale) {\n                    items.push({\n                        options:   options.scale,\n                        dtype:     'radialLinear',\n                        isDefault: true,\n                        dposition: 'chartArea'\n                    });\n                }\n                \n                helpers.each(items, function (item) {\n                    var scaleOptions = item.options;\n                    var scaleType = helpers.getValueOrDefault(scaleOptions.type, item.dtype);\n                    var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);\n                    if (!scaleClass) {\n                        return;\n                    }\n                    \n                    if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n                        scaleOptions.position = item.dposition;\n                    }\n                    \n                    var scale = new scaleClass({\n                        id:      scaleOptions.id,\n                        options: scaleOptions,\n                        ctx:     me.ctx,\n                        chart:   me\n                    });\n                    \n                    scales[scale.id] = scale;\n                    \n                    // TODO(SB): I think we should be able to remove this custom case (options.scale)\n                    // and consider it as a regular scale part of the \"scales\"\" map only! This would\n                    // make the logic easier and remove some useless? custom code.\n                    if (item.isDefault) {\n                        me.scale = scale;\n                    }\n                });\n                \n                Chart.scaleService.addScalesToLayout(this);\n            },\n            \n            buildOrUpdateControllers: function () {\n                var me = this;\n                var types = [];\n                var newControllers = [];\n                \n                helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n                    var meta = me.getDatasetMeta(datasetIndex);\n                    if (!meta.type) {\n                        meta.type = dataset.type || me.config.type;\n                    }\n                    \n                    types.push(meta.type);\n                    \n                    if (meta.controller) {\n                        meta.controller.updateIndex(datasetIndex);\n                    } else {\n                        var ControllerClass = Chart.controllers[meta.type];\n                        if (ControllerClass === undefined) {\n                            throw new Error('\"' + meta.type + '\" is not a chart type.');\n                        }\n                        \n                        meta.controller = new ControllerClass(me, datasetIndex);\n                        newControllers.push(meta.controller);\n                    }\n                }, me);\n                \n                if (types.length > 1) {\n                    for (var i = 1; i < types.length; i++) {\n                        if (types[i] !== types[i - 1]) {\n                            me.isCombo = true;\n                            break;\n                        }\n                    }\n                }\n                \n                return newControllers;\n            },\n            \n            /**\n             * Reset the elements of all datasets\n             * @private\n             */\n            resetElements: function () {\n                var me = this;\n                helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n                    me.getDatasetMeta(datasetIndex).controller.reset();\n                }, me);\n            },\n            \n            /**\n             * Resets the chart back to it's state before the initial animation\n             */\n            reset: function () {\n                this.resetElements();\n                this.tooltip.initialize();\n            },\n            \n            update: function (animationDuration, lazy) {\n                var me = this;\n                \n                updateConfig(me);\n                \n                if (plugins.notify(me, 'beforeUpdate') === false) {\n                    return;\n                }\n                \n                // In case the entire data object changed\n                me.tooltip._data = me.data;\n                \n                // Make sure dataset controllers are updated and new controllers are reset\n                var newControllers = me.buildOrUpdateControllers();\n                \n                // Make sure all dataset controllers have correct meta data counts\n                helpers.each(me.data.datasets, function (dataset, datasetIndex) {\n                    me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n                }, me);\n                \n                me.updateLayout();\n                \n                // Can only reset the new controllers after the scales have been updated\n                helpers.each(newControllers, function (controller) {\n                    controller.reset();\n                });\n                \n                me.updateDatasets();\n                \n                // Do this before render so that any plugins that need final scale updates can use it\n                plugins.notify(me, 'afterUpdate');\n                \n                if (me._bufferedRender) {\n                    me._bufferedRequest = {\n                        lazy:     lazy,\n                        duration: animationDuration\n                    };\n                } else {\n                    me.render(animationDuration, lazy);\n                }\n            },\n            \n            /**\n             * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n             * hook, in which case, plugins will not be called on `afterLayout`.\n             * @private\n             */\n            updateLayout: function () {\n                var me = this;\n                \n                if (plugins.notify(me, 'beforeLayout') === false) {\n                    return;\n                }\n                \n                Chart.layoutService.update(this, this.width, this.height);\n                \n                /**\n                 * Provided for backward compatibility, use `afterLayout` instead.\n                 * @method IPlugin#afterScaleUpdate\n                 * @deprecated since version 2.5.0\n                 * @todo remove at version 3\n                 * @private\n                 */\n                plugins.notify(me, 'afterScaleUpdate');\n                plugins.notify(me, 'afterLayout');\n            },\n            \n            /**\n             * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n             * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n             * @private\n             */\n            updateDatasets: function () {\n                var me = this;\n                \n                if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n                    return;\n                }\n                \n                for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n                    me.updateDataset(i);\n                }\n                \n                plugins.notify(me, 'afterDatasetsUpdate');\n            },\n            \n            /**\n             * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n             * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n             * @private\n             */\n            updateDataset: function (index) {\n                var me = this;\n                var meta = me.getDatasetMeta(index);\n                var args = {\n                    meta:  meta,\n                    index: index\n                };\n                \n                if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n                    return;\n                }\n                \n                meta.controller.update();\n                \n                plugins.notify(me, 'afterDatasetUpdate', [args]);\n            },\n            \n            render: function (duration, lazy) {\n                var me = this;\n                \n                if (plugins.notify(me, 'beforeRender') === false) {\n                    return;\n                }\n                \n                var animationOptions = me.options.animation;\n                var onComplete = function (animation) {\n                    plugins.notify(me, 'afterRender');\n                    helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);\n                };\n                \n                if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {\n                    var animation = new Chart.Animation({\n                        numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps\n                        easing:   animationOptions.easing,\n                        \n                        render: function (chart, animationObject) {\n                            var easingFunction = helpers.easingEffects[animationObject.easing];\n                            var currentStep = animationObject.currentStep;\n                            var stepDecimal = currentStep / animationObject.numSteps;\n                            \n                            chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n                        },\n                        \n                        onAnimationProgress: animationOptions.onProgress,\n                        onAnimationComplete: onComplete\n                    });\n                    \n                    Chart.animationService.addAnimation(me, animation, duration, lazy);\n                } else {\n                    me.draw();\n                    \n                    // See https://github.com/chartjs/Chart.js/issues/3781\n                    onComplete(new Chart.Animation({numSteps: 0, chart: me}));\n                }\n                \n                return me;\n            },\n            \n            draw: function (easingValue) {\n                var me = this;\n                \n                me.clear();\n                \n                if (easingValue === undefined || easingValue === null) {\n                    easingValue = 1;\n                }\n                \n                me.transition(easingValue);\n                \n                if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n                    return;\n                }\n                \n                // Draw all the scales\n                helpers.each(me.boxes, function (box) {\n                    box.draw(me.chartArea);\n                }, me);\n                \n                if (me.scale) {\n                    me.scale.draw();\n                }\n                \n                me.drawDatasets(easingValue);\n                \n                // Finally draw the tooltip\n                me.tooltip.draw();\n                \n                plugins.notify(me, 'afterDraw', [easingValue]);\n            },\n            \n            /**\n             * @private\n             */\n            transition: function (easingValue) {\n                var me = this;\n                \n                for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n                    if (me.isDatasetVisible(i)) {\n                        me.getDatasetMeta(i).controller.transition(easingValue);\n                    }\n                }\n                \n                me.tooltip.transition(easingValue);\n            },\n            \n            /**\n             * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n             * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n             * @private\n             */\n            drawDatasets: function (easingValue) {\n                var me = this;\n                \n                if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n                    return;\n                }\n                \n                // Draw datasets reversed to support proper line stacking\n                for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n                    if (me.isDatasetVisible(i)) {\n                        me.drawDataset(i, easingValue);\n                    }\n                }\n                \n                plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n            },\n            \n            /**\n             * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n             * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n             * @private\n             */\n            drawDataset: function (index, easingValue) {\n                var me = this;\n                var meta = me.getDatasetMeta(index);\n                var args = {\n                    meta:        meta,\n                    index:       index,\n                    easingValue: easingValue\n                };\n                \n                if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n                    return;\n                }\n                \n                meta.controller.draw(easingValue);\n                \n                plugins.notify(me, 'afterDatasetDraw', [args]);\n            },\n            \n            // Get the single element that was clicked on\n            // @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n            getElementAtEvent: function (e) {\n                return Chart.Interaction.modes.single(this, e);\n            },\n            \n            getElementsAtEvent: function (e) {\n                return Chart.Interaction.modes.label(this, e, {intersect: true});\n            },\n            \n            getElementsAtXAxis: function (e) {\n                return Chart.Interaction.modes['x-axis'](this, e, {intersect: true});\n            },\n            \n            getElementsAtEventForMode: function (e, mode, options) {\n                var method = Chart.Interaction.modes[mode];\n                if (typeof method === 'function') {\n                    return method(this, e, options);\n                }\n                \n                return [];\n            },\n            \n            getDatasetAtEvent: function (e) {\n                return Chart.Interaction.modes.dataset(this, e, {intersect: true});\n            },\n            \n            getDatasets: function () {\n                var me = this;\n                return me.data.datasets;\n            },\n            getDatasetMeta: function (datasetIndex) {\n                var me = this;\n                var dataset = me.data.datasets[datasetIndex];\n                if (!dataset._meta) {\n                    dataset._meta = {};\n                }\n                \n                var meta = dataset._meta[me.id];\n                if (!meta) {\n                    meta = dataset._meta[me.id] = {\n                        type:       null,\n                        data:       [],\n                        dataset:    null,\n                        controller: null,\n                        hidden:     null,\t\t\t// See isDatasetVisible() comment\n                        xAxisID:    null,\n                        yAxisID:    null\n                    };\n                }\n                \n                return meta;\n            },\n            \n            getVisibleDatasetCount: function () {\n                var count = 0;\n                for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n                    if (this.isDatasetVisible(i)) {\n                        count++;\n                    }\n                }\n                return count;\n            },\n            \n            isDatasetVisible: function (datasetIndex) {\n                var meta = this.getDatasetMeta(datasetIndex);\n                \n                // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n                // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n                return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n            },\n            \n            generateLegend: function () {\n                return this.options.legendCallback(this);\n            },\n            \n            destroy: function () {\n                var me = this;\n                var canvas = me.canvas;\n                var meta, i, ilen;\n                \n                me.stop();\n                \n                // dataset controllers need to cleanup associated data\n                for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n                    meta = me.getDatasetMeta(i);\n                    if (meta.controller) {\n                        meta.controller.destroy();\n                        meta.controller = null;\n                    }\n                }\n                \n                if (canvas) {\n                    me.unbindEvents();\n                    helpers.clear(me);\n                    platform.releaseContext(me.ctx);\n                    me.canvas = null;\n                    me.ctx = null;\n                }\n                \n                plugins.notify(me, 'destroy');\n                \n                delete Chart.instances[me.id];\n            },\n            \n            toBase64Image: function () {\n                return this.canvas.toDataURL.apply(this.canvas, arguments);\n            },\n            \n            initToolTip: function () {\n                var me = this;\n                me.tooltip = new Chart.Tooltip({\n                    _chart:         me,\n                    _chartInstance: me,            // deprecated, backward compatibility\n                    _data:          me.data,\n                    _options:       me.options.tooltips\n                }, me);\n                me.tooltip.initialize();\n            },\n            \n            /**\n             * @private\n             */\n            bindEvents: function () {\n                var me = this;\n                var listeners = me._listeners = {};\n                var listener = function () {\n                    me.eventHandler.apply(me, arguments);\n                };\n                \n                helpers.each(me.options.events, function (type) {\n                    platform.addEventListener(me, type, listener);\n                    listeners[type] = listener;\n                });\n                \n                // Responsiveness is currently based on the use of an iframe, however this method causes\n                // performance issues and could be troublesome when used with ad blockers. So make sure\n                // that the user is still able to create a chart without iframe when responsive is false.\n                // See https://github.com/chartjs/Chart.js/issues/2210\n                if (me.options.responsive) {\n                    listener = function () {\n                        me.resize();\n                    };\n                    \n                    platform.addEventListener(me, 'resize', listener);\n                    listeners.resize = listener;\n                }\n            },\n            \n            /**\n             * @private\n             */\n            unbindEvents: function () {\n                var me = this;\n                var listeners = me._listeners;\n                if (!listeners) {\n                    return;\n                }\n                \n                delete me._listeners;\n                helpers.each(listeners, function (listener, type) {\n                    platform.removeEventListener(me, type, listener);\n                });\n            },\n            \n            updateHoverStyle: function (elements, mode, enabled) {\n                var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n                var element, i, ilen;\n                \n                for (i = 0, ilen = elements.length; i < ilen; ++i) {\n                    element = elements[i];\n                    if (element) {\n                        this.getDatasetMeta(element._datasetIndex).controller[method](element);\n                    }\n                }\n            },\n            \n            /**\n             * @private\n             */\n            eventHandler: function (e) {\n                var me = this;\n                var tooltip = me.tooltip;\n                \n                if (plugins.notify(me, 'beforeEvent', [e]) === false) {\n                    return;\n                }\n                \n                // Buffer any update calls so that renders do not occur\n                me._bufferedRender = true;\n                me._bufferedRequest = null;\n                \n                var changed = me.handleEvent(e);\n                changed |= tooltip && tooltip.handleEvent(e);\n                \n                plugins.notify(me, 'afterEvent', [e]);\n                \n                var bufferedRequest = me._bufferedRequest;\n                if (bufferedRequest) {\n                    // If we have an update that was triggered, we need to do a normal render\n                    me.render(bufferedRequest.duration, bufferedRequest.lazy);\n                } else if (changed && !me.animating) {\n                    // If entering, leaving, or changing elements, animate the change via pivot\n                    me.stop();\n                    \n                    // We only need to render at this point. Updating will cause scales to be\n                    // recomputed generating flicker & using more memory than necessary.\n                    me.render(me.options.hover.animationDuration, true);\n                }\n                \n                me._bufferedRender = false;\n                me._bufferedRequest = null;\n                \n                return me;\n            },\n            \n            /**\n             * Handle an event\n             * @private\n             * @param {IEvent} event the event to handle\n             * @return {Boolean} true if the chart needs to re-render\n             */\n            handleEvent: function (e) {\n                var me = this;\n                var options = me.options || {};\n                var hoverOptions = options.hover;\n                var changed = false;\n                \n                me.lastActive = me.lastActive || [];\n                \n                // Find Active Elements for hover and tooltips\n                if (e.type === 'mouseout') {\n                    me.active = [];\n                } else {\n                    me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n                }\n                \n                // On Hover hook\n                if (hoverOptions.onHover) {\n                    // Need to call with native event here to not break backwards compatibility\n                    hoverOptions.onHover.call(me, e.native, me.active);\n                }\n                \n                if (e.type === 'mouseup' || e.type === 'click') {\n                    if (options.onClick) {\n                        // Use e.native here for backwards compatibility\n                        options.onClick.call(me, e.native, me.active);\n                    }\n                }\n                \n                // Remove styling for last active (even if it may still be active)\n                if (me.lastActive.length) {\n                    me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n                }\n                \n                // Built in hover styling\n                if (me.active.length && hoverOptions.mode) {\n                    me.updateHoverStyle(me.active, hoverOptions.mode, true);\n                }\n                \n                changed = !helpers.arrayEquals(me.active, me.lastActive);\n                \n                // Remember Last Actives\n                me.lastActive = me.active;\n                \n                return changed;\n            }\n        });\n        \n        /**\n         * Provided for backward compatibility, use Chart instead.\n         * @class Chart.Controller\n         * @deprecated since version 2.6.0\n         * @todo remove at version 3\n         * @private\n         */\n        Chart.Controller = Chart;\n    };\n    \n},{}],18:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n        \n        /**\n         * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n         * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n         * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n         */\n        function listenArrayEvents(array, listener) {\n            if (array._chartjs) {\n                array._chartjs.listeners.push(listener);\n                return;\n            }\n            \n            Object.defineProperty(array, '_chartjs', {\n                configurable: true,\n                enumerable: false,\n                value: {\n                    listeners: [listener]\n                }\n            });\n            \n            arrayEvents.forEach(function(key) {\n                var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n                var base = array[key];\n                \n                Object.defineProperty(array, key, {\n                    configurable: true,\n                    enumerable: false,\n                    value: function() {\n                        var args = Array.prototype.slice.call(arguments);\n                        var res = base.apply(this, args);\n                        \n                        helpers.each(array._chartjs.listeners, function(object) {\n                            if (typeof object[method] === 'function') {\n                                object[method].apply(object, args);\n                            }\n                        });\n                        \n                        return res;\n                    }\n                });\n            });\n        }\n        \n        /**\n         * Removes the given array event listener and cleanup extra attached properties (such as\n         * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n         */\n        function unlistenArrayEvents(array, listener) {\n            var stub = array._chartjs;\n            if (!stub) {\n                return;\n            }\n            \n            var listeners = stub.listeners;\n            var index = listeners.indexOf(listener);\n            if (index !== -1) {\n                listeners.splice(index, 1);\n            }\n            \n            if (listeners.length > 0) {\n                return;\n            }\n            \n            arrayEvents.forEach(function(key) {\n                delete array[key];\n            });\n            \n            delete array._chartjs;\n        }\n        \n        // Base class for all dataset controllers (line, bar, etc)\n        Chart.DatasetController = function(chart, datasetIndex) {\n            this.initialize(chart, datasetIndex);\n        };\n        \n        helpers.extend(Chart.DatasetController.prototype, {\n            \n            /**\n             * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n             * @type {Chart.core.element}\n             */\n            datasetElementType: null,\n            \n            /**\n             * Element type used to generate a meta data (e.g. Chart.element.Point).\n             * @type {Chart.core.element}\n             */\n            dataElementType: null,\n            \n            initialize: function(chart, datasetIndex) {\n                var me = this;\n                me.chart = chart;\n                me.index = datasetIndex;\n                me.linkScales();\n                me.addElements();\n            },\n            \n            updateIndex: function(datasetIndex) {\n                this.index = datasetIndex;\n            },\n            \n            linkScales: function() {\n                var me = this;\n                var meta = me.getMeta();\n                var dataset = me.getDataset();\n                \n                if (meta.xAxisID === null) {\n                    meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n                }\n                if (meta.yAxisID === null) {\n                    meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n                }\n            },\n            \n            getDataset: function() {\n                return this.chart.data.datasets[this.index];\n            },\n            \n            getMeta: function() {\n                return this.chart.getDatasetMeta(this.index);\n            },\n            \n            getScaleForId: function(scaleID) {\n                return this.chart.scales[scaleID];\n            },\n            \n            reset: function() {\n                this.update(true);\n            },\n            \n            /**\n             * @private\n             */\n            destroy: function() {\n                if (this._data) {\n                    unlistenArrayEvents(this._data, this);\n                }\n            },\n            \n            createMetaDataset: function() {\n                var me = this;\n                var type = me.datasetElementType;\n                return type && new type({\n                        _chart: me.chart,\n                        _datasetIndex: me.index\n                    });\n            },\n            \n            createMetaData: function(index) {\n                var me = this;\n                var type = me.dataElementType;\n                return type && new type({\n                        _chart: me.chart,\n                        _datasetIndex: me.index,\n                        _index: index\n                    });\n            },\n            \n            addElements: function() {\n                var me = this;\n                var meta = me.getMeta();\n                var data = me.getDataset().data || [];\n                var metaData = meta.data;\n                var i, ilen;\n                \n                for (i=0, ilen=data.length; i<ilen; ++i) {\n                    metaData[i] = metaData[i] || me.createMetaData(i);\n                }\n                \n                meta.dataset = meta.dataset || me.createMetaDataset();\n            },\n            \n            addElementAndReset: function(index) {\n                var element = this.createMetaData(index);\n                this.getMeta().data.splice(index, 0, element);\n                this.updateElement(element, index, true);\n            },\n            \n            buildOrUpdateElements: function() {\n                var me = this;\n                var dataset = me.getDataset();\n                var data = dataset.data || (dataset.data = []);\n                \n                // In order to correctly handle data addition/deletion animation (an thus simulate\n                // real-time charts), we need to monitor these data modifications and synchronize\n                // the internal meta data accordingly.\n                if (me._data !== data) {\n                    if (me._data) {\n                        // This case happens when the user replaced the data array instance.\n                        unlistenArrayEvents(me._data, me);\n                    }\n                    \n                    listenArrayEvents(data, me);\n                    me._data = data;\n                }\n                \n                // Re-sync meta data in case the user replaced the data array or if we missed\n                // any updates and so make sure that we handle number of datapoints changing.\n                me.resyncElements();\n            },\n            \n            update: helpers.noop,\n            \n            transition: function(easingValue) {\n                var meta = this.getMeta();\n                var elements = meta.data || [];\n                var ilen = elements.length;\n                var i = 0;\n                \n                for (; i<ilen; ++i) {\n                    elements[i].transition(easingValue);\n                }\n                \n                if (meta.dataset) {\n                    meta.dataset.transition(easingValue);\n                }\n            },\n            \n            draw: function() {\n                var meta = this.getMeta();\n                var elements = meta.data || [];\n                var ilen = elements.length;\n                var i = 0;\n                \n                if (meta.dataset) {\n                    meta.dataset.draw();\n                }\n                \n                for (; i<ilen; ++i) {\n                    elements[i].draw();\n                }\n            },\n            \n            removeHoverStyle: function(element, elementOpts) {\n                var dataset = this.chart.data.datasets[element._datasetIndex],\n                    index = element._index,\n                    custom = element.custom || {},\n                    valueOrDefault = helpers.getValueAtIndexOrDefault,\n                    model = element._model;\n                \n                model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);\n                model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);\n                model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);\n            },\n            \n            setHoverStyle: function(element) {\n                var dataset = this.chart.data.datasets[element._datasetIndex],\n                    index = element._index,\n                    custom = element.custom || {},\n                    valueOrDefault = helpers.getValueAtIndexOrDefault,\n                    getHoverColor = helpers.getHoverColor,\n                    model = element._model;\n                \n                model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));\n                model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));\n                model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);\n            },\n            \n            /**\n             * @private\n             */\n            resyncElements: function() {\n                var me = this;\n                var meta = me.getMeta();\n                var data = me.getDataset().data;\n                var numMeta = meta.data.length;\n                var numData = data.length;\n                \n                if (numData < numMeta) {\n                    meta.data.splice(numData, numMeta - numData);\n                } else if (numData > numMeta) {\n                    me.insertElements(numMeta, numData - numMeta);\n                }\n            },\n            \n            /**\n             * @private\n             */\n            insertElements: function(start, count) {\n                for (var i=0; i<count; ++i) {\n                    this.addElementAndReset(start + i);\n                }\n            },\n            \n            /**\n             * @private\n             */\n            onDataPush: function() {\n                this.insertElements(this.getDataset().data.length-1, arguments.length);\n            },\n            \n            /**\n             * @private\n             */\n            onDataPop: function() {\n                this.getMeta().data.pop();\n            },\n            \n            /**\n             * @private\n             */\n            onDataShift: function() {\n                this.getMeta().data.shift();\n            },\n            \n            /**\n             * @private\n             */\n            onDataSplice: function(start, count) {\n                this.getMeta().data.splice(start, count);\n                this.insertElements(start, arguments.length - 2);\n            },\n            \n            /**\n             * @private\n             */\n            onDataUnshift: function() {\n                this.insertElements(0, arguments.length);\n            }\n        });\n        \n        Chart.DatasetController.extend = helpers.inherits;\n    };\n    \n},{}],19:[function(require,module,exports){\n    'use strict';\n    \n    var color = require(46);\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        function interpolate(start, view, model, ease) {\n            var keys = Object.keys(model);\n            var i, ilen, key, actual, origin, target, type, c0, c1;\n            \n            for (i=0, ilen=keys.length; i<ilen; ++i) {\n                key = keys[i];\n                \n                target = model[key];\n                \n                // if a value is added to the model after pivot() has been called, the view\n                // doesn't contain it, so let's initialize the view to the target value.\n                if (!view.hasOwnProperty(key)) {\n                    view[key] = target;\n                }\n                \n                actual = view[key];\n                \n                if (actual === target || key[0] === '_') {\n                    continue;\n                }\n                \n                if (!start.hasOwnProperty(key)) {\n                    start[key] = actual;\n                }\n                \n                origin = start[key];\n                \n                type = typeof(target);\n                \n                if (type === typeof(origin)) {\n                    if (type === 'string') {\n                        c0 = color(origin);\n                        if (c0.valid) {\n                            c1 = color(target);\n                            if (c1.valid) {\n                                view[key] = c1.mix(c0, ease).rgbString();\n                                continue;\n                            }\n                        }\n                    } else if (type === 'number' && isFinite(origin) && isFinite(target)) {\n                        view[key] = origin + (target - origin) * ease;\n                        continue;\n                    }\n                }\n                \n                view[key] = target;\n            }\n        }\n        \n        Chart.elements = {};\n        \n        Chart.Element = function(configuration) {\n            helpers.extend(this, configuration);\n            this.initialize.apply(this, arguments);\n        };\n        \n        helpers.extend(Chart.Element.prototype, {\n            \n            initialize: function() {\n                this.hidden = false;\n            },\n            \n            pivot: function() {\n                var me = this;\n                if (!me._view) {\n                    me._view = helpers.clone(me._model);\n                }\n                me._start = {};\n                return me;\n            },\n            \n            transition: function(ease) {\n                var me = this;\n                var model = me._model;\n                var start = me._start;\n                var view = me._view;\n                \n                // No animation -> No Transition\n                if (!model || ease === 1) {\n                    me._view = model;\n                    me._start = null;\n                    return me;\n                }\n                \n                if (!view) {\n                    view = me._view = {};\n                }\n                \n                if (!start) {\n                    start = me._start = {};\n                }\n                \n                interpolate(start, view, model, ease);\n                \n                return me;\n            },\n            \n            tooltipPosition: function() {\n                return {\n                    x: this._model.x,\n                    y: this._model.y\n                };\n            },\n            \n            hasValue: function() {\n                return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);\n            }\n        });\n        \n        Chart.Element.extend = helpers.inherits;\n    };\n    \n},{\"46\":46}],20:[function(require,module,exports){\n    /* global window: false */\n    /* global document: false */\n    'use strict';\n    \n    var color = require(46);\n    \n    module.exports = function(Chart) {\n        // Global Chart helpers object for utility methods and classes\n        var helpers = Chart.helpers = {};\n        \n        // -- Basic js utility methods\n        helpers.each = function(loopable, callback, self, reverse) {\n            // Check to see if null or undefined firstly.\n            var i, len;\n            if (helpers.isArray(loopable)) {\n                len = loopable.length;\n                if (reverse) {\n                    for (i = len - 1; i >= 0; i--) {\n                        callback.call(self, loopable[i], i);\n                    }\n                } else {\n                    for (i = 0; i < len; i++) {\n                        callback.call(self, loopable[i], i);\n                    }\n                }\n            } else if (typeof loopable === 'object') {\n                var keys = Object.keys(loopable);\n                len = keys.length;\n                for (i = 0; i < len; i++) {\n                    callback.call(self, loopable[keys[i]], keys[i]);\n                }\n            }\n        };\n        helpers.clone = function(obj) {\n            var objClone = {};\n            helpers.each(obj, function(value, key) {\n                if (helpers.isArray(value)) {\n                    objClone[key] = value.slice(0);\n                } else if (typeof value === 'object' && value !== null) {\n                    objClone[key] = helpers.clone(value);\n                } else {\n                    objClone[key] = value;\n                }\n            });\n            return objClone;\n        };\n        helpers.extend = function(base) {\n            var setFn = function(value, key) {\n                base[key] = value;\n            };\n            for (var i = 1, ilen = arguments.length; i < ilen; i++) {\n                helpers.each(arguments[i], setFn);\n            }\n            return base;\n        };\n        // Need a special merge function to chart configs since they are now grouped\n        helpers.configMerge = function(_base) {\n            var base = helpers.clone(_base);\n            helpers.each(Array.prototype.slice.call(arguments, 1), function(extension) {\n                helpers.each(extension, function(value, key) {\n                    var baseHasProperty = base.hasOwnProperty(key);\n                    var baseVal = baseHasProperty ? base[key] : {};\n                    \n                    if (key === 'scales') {\n                        // Scale config merging is complex. Add our own function here for that\n                        base[key] = helpers.scaleMerge(baseVal, value);\n                    } else if (key === 'scale') {\n                        // Used in polar area & radar charts since there is only one scale\n                        base[key] = helpers.configMerge(baseVal, Chart.scaleService.getScaleDefaults(value.type), value);\n                    } else if (baseHasProperty\n                        && typeof baseVal === 'object'\n                        && !helpers.isArray(baseVal)\n                        && baseVal !== null\n                        && typeof value === 'object'\n                        && !helpers.isArray(value)) {\n                        // If we are overwriting an object with an object, do a merge of the properties.\n                        base[key] = helpers.configMerge(baseVal, value);\n                    } else {\n                        // can just overwrite the value in this case\n                        base[key] = value;\n                    }\n                });\n            });\n            \n            return base;\n        };\n        helpers.scaleMerge = function(_base, extension) {\n            var base = helpers.clone(_base);\n            \n            helpers.each(extension, function(value, key) {\n                if (key === 'xAxes' || key === 'yAxes') {\n                    // These properties are arrays of items\n                    if (base.hasOwnProperty(key)) {\n                        helpers.each(value, function(valueObj, index) {\n                            var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n                            var axisDefaults = Chart.scaleService.getScaleDefaults(axisType);\n                            if (index >= base[key].length || !base[key][index].type) {\n                                base[key].push(helpers.configMerge(axisDefaults, valueObj));\n                            } else if (valueObj.type && valueObj.type !== base[key][index].type) {\n                                // Type changed. Bring in the new defaults before we bring in valueObj so that valueObj can override the correct scale defaults\n                                base[key][index] = helpers.configMerge(base[key][index], axisDefaults, valueObj);\n                            } else {\n                                // Type is the same\n                                base[key][index] = helpers.configMerge(base[key][index], valueObj);\n                            }\n                        });\n                    } else {\n                        base[key] = [];\n                        helpers.each(value, function(valueObj) {\n                            var axisType = helpers.getValueOrDefault(valueObj.type, key === 'xAxes' ? 'category' : 'linear');\n                            base[key].push(helpers.configMerge(Chart.scaleService.getScaleDefaults(axisType), valueObj));\n                        });\n                    }\n                } else if (base.hasOwnProperty(key) && typeof base[key] === 'object' && base[key] !== null && typeof value === 'object') {\n                    // If we are overwriting an object with an object, do a merge of the properties.\n                    base[key] = helpers.configMerge(base[key], value);\n                    \n                } else {\n                    // can just overwrite the value in this case\n                    base[key] = value;\n                }\n            });\n            \n            return base;\n        };\n        helpers.getValueAtIndexOrDefault = function(value, index, defaultValue) {\n            if (value === undefined || value === null) {\n                return defaultValue;\n            }\n            \n            if (helpers.isArray(value)) {\n                return index < value.length ? value[index] : defaultValue;\n            }\n            \n            return value;\n        };\n        helpers.getValueOrDefault = function(value, defaultValue) {\n            return value === undefined ? defaultValue : value;\n        };\n        helpers.indexOf = Array.prototype.indexOf?\n            function(array, item) {\n                return array.indexOf(item);\n            }:\n            function(array, item) {\n                for (var i = 0, ilen = array.length; i < ilen; ++i) {\n                    if (array[i] === item) {\n                        return i;\n                    }\n                }\n                return -1;\n            };\n        helpers.where = function(collection, filterCallback) {\n            if (helpers.isArray(collection) && Array.prototype.filter) {\n                return collection.filter(filterCallback);\n            }\n            var filtered = [];\n            \n            helpers.each(collection, function(item) {\n                if (filterCallback(item)) {\n                    filtered.push(item);\n                }\n            });\n            \n            return filtered;\n        };\n        helpers.findIndex = Array.prototype.findIndex?\n            function(array, callback, scope) {\n                return array.findIndex(callback, scope);\n            } :\n            function(array, callback, scope) {\n                scope = scope === undefined? array : scope;\n                for (var i = 0, ilen = array.length; i < ilen; ++i) {\n                    if (callback.call(scope, array[i], i, array)) {\n                        return i;\n                    }\n                }\n                return -1;\n            };\n        helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n            // Default to start of the array\n            if (startIndex === undefined || startIndex === null) {\n                startIndex = -1;\n            }\n            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n                var currentItem = arrayToSearch[i];\n                if (filterCallback(currentItem)) {\n                    return currentItem;\n                }\n            }\n        };\n        helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n            // Default to end of the array\n            if (startIndex === undefined || startIndex === null) {\n                startIndex = arrayToSearch.length;\n            }\n            for (var i = startIndex - 1; i >= 0; i--) {\n                var currentItem = arrayToSearch[i];\n                if (filterCallback(currentItem)) {\n                    return currentItem;\n                }\n            }\n        };\n        helpers.inherits = function(extensions) {\n            // Basic javascript inheritance based on the model created in Backbone.js\n            var me = this;\n            var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n                return me.apply(this, arguments);\n            };\n            \n            var Surrogate = function() {\n                this.constructor = ChartElement;\n            };\n            Surrogate.prototype = me.prototype;\n            ChartElement.prototype = new Surrogate();\n            \n            ChartElement.extend = helpers.inherits;\n            \n            if (extensions) {\n                helpers.extend(ChartElement.prototype, extensions);\n            }\n            \n            ChartElement.__super__ = me.prototype;\n            \n            return ChartElement;\n        };\n        helpers.noop = function() {};\n        helpers.uid = (function() {\n            var id = 0;\n            return function() {\n                return id++;\n            };\n        }());\n        // -- Math methods\n        helpers.isNumber = function(n) {\n            return !isNaN(parseFloat(n)) && isFinite(n);\n        };\n        helpers.almostEquals = function(x, y, epsilon) {\n            return Math.abs(x - y) < epsilon;\n        };\n        helpers.almostWhole = function(x, epsilon) {\n            var rounded = Math.round(x);\n            return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n        };\n        helpers.max = function(array) {\n            return array.reduce(function(max, value) {\n                if (!isNaN(value)) {\n                    return Math.max(max, value);\n                }\n                return max;\n            }, Number.NEGATIVE_INFINITY);\n        };\n        helpers.min = function(array) {\n            return array.reduce(function(min, value) {\n                if (!isNaN(value)) {\n                    return Math.min(min, value);\n                }\n                return min;\n            }, Number.POSITIVE_INFINITY);\n        };\n        helpers.sign = Math.sign?\n            function(x) {\n                return Math.sign(x);\n            } :\n            function(x) {\n                x = +x; // convert to a number\n                if (x === 0 || isNaN(x)) {\n                    return x;\n                }\n                return x > 0 ? 1 : -1;\n            };\n        helpers.log10 = Math.log10?\n            function(x) {\n                return Math.log10(x);\n            } :\n            function(x) {\n                return Math.log(x) / Math.LN10;\n            };\n        helpers.toRadians = function(degrees) {\n            return degrees * (Math.PI / 180);\n        };\n        helpers.toDegrees = function(radians) {\n            return radians * (180 / Math.PI);\n        };\n        // Gets the angle from vertical upright to the point about a centre.\n        helpers.getAngleFromPoint = function(centrePoint, anglePoint) {\n            var distanceFromXCenter = anglePoint.x - centrePoint.x,\n                distanceFromYCenter = anglePoint.y - centrePoint.y,\n                radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n            \n            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n            \n            if (angle < (-0.5 * Math.PI)) {\n                angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n            }\n            \n            return {\n                angle: angle,\n                distance: radialDistanceFromCenter\n            };\n        };\n        helpers.distanceBetweenPoints = function(pt1, pt2) {\n            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n        };\n        helpers.aliasPixel = function(pixelWidth) {\n            return (pixelWidth % 2 === 0) ? 0 : 0.5;\n        };\n        helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n            // Props to Rob Spencer at scaled innovation for his post on splining between points\n            // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n            \n            // This function must also respect \"skipped\" points\n            \n            var previous = firstPoint.skip ? middlePoint : firstPoint,\n                current = middlePoint,\n                next = afterPoint.skip ? middlePoint : afterPoint;\n            \n            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n            \n            var s01 = d01 / (d01 + d12);\n            var s12 = d12 / (d01 + d12);\n            \n            // If all points are the same, s01 & s02 will be inf\n            s01 = isNaN(s01) ? 0 : s01;\n            s12 = isNaN(s12) ? 0 : s12;\n            \n            var fa = t * s01; // scaling factor for triangle Ta\n            var fb = t * s12;\n            \n            return {\n                previous: {\n                    x: current.x - fa * (next.x - previous.x),\n                    y: current.y - fa * (next.y - previous.y)\n                },\n                next: {\n                    x: current.x + fb * (next.x - previous.x),\n                    y: current.y + fb * (next.y - previous.y)\n                }\n            };\n        };\n        helpers.EPSILON = Number.EPSILON || 1e-14;\n        helpers.splineCurveMonotone = function(points) {\n            // This function calculates B\u00e9zier control points in a similar way than |splineCurve|,\n            // but preserves monotonicity of the provided data and ensures no local extremums are added\n            // between the dataset discrete points due to the interpolation.\n            // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n            \n            var pointsWithTangents = (points || []).map(function(point) {\n                return {\n                    model: point._model,\n                    deltaK: 0,\n                    mK: 0\n                };\n            });\n            \n            // Calculate slopes (deltaK) and initialize tangents (mK)\n            var pointsLen = pointsWithTangents.length;\n            var i, pointBefore, pointCurrent, pointAfter;\n            for (i = 0; i < pointsLen; ++i) {\n                pointCurrent = pointsWithTangents[i];\n                if (pointCurrent.model.skip) {\n                    continue;\n                }\n                \n                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n                if (pointAfter && !pointAfter.model.skip) {\n                    var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n                    \n                    // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n                    pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n                }\n                \n                if (!pointBefore || pointBefore.model.skip) {\n                    pointCurrent.mK = pointCurrent.deltaK;\n                } else if (!pointAfter || pointAfter.model.skip) {\n                    pointCurrent.mK = pointBefore.deltaK;\n                } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n                    pointCurrent.mK = 0;\n                } else {\n                    pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n                }\n            }\n            \n            // Adjust tangents to ensure monotonic properties\n            var alphaK, betaK, tauK, squaredMagnitude;\n            for (i = 0; i < pointsLen - 1; ++i) {\n                pointCurrent = pointsWithTangents[i];\n                pointAfter = pointsWithTangents[i + 1];\n                if (pointCurrent.model.skip || pointAfter.model.skip) {\n                    continue;\n                }\n                \n                if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n                    pointCurrent.mK = pointAfter.mK = 0;\n                    continue;\n                }\n                \n                alphaK = pointCurrent.mK / pointCurrent.deltaK;\n                betaK = pointAfter.mK / pointCurrent.deltaK;\n                squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n                if (squaredMagnitude <= 9) {\n                    continue;\n                }\n                \n                tauK = 3 / Math.sqrt(squaredMagnitude);\n                pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n                pointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n            }\n            \n            // Compute control points\n            var deltaX;\n            for (i = 0; i < pointsLen; ++i) {\n                pointCurrent = pointsWithTangents[i];\n                if (pointCurrent.model.skip) {\n                    continue;\n                }\n                \n                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n                if (pointBefore && !pointBefore.model.skip) {\n                    deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n                    pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n                    pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n                }\n                if (pointAfter && !pointAfter.model.skip) {\n                    deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n                    pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n                    pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n                }\n            }\n        };\n        helpers.nextItem = function(collection, index, loop) {\n            if (loop) {\n                return index >= collection.length - 1 ? collection[0] : collection[index + 1];\n            }\n            return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n        };\n        helpers.previousItem = function(collection, index, loop) {\n            if (loop) {\n                return index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n            }\n            return index <= 0 ? collection[0] : collection[index - 1];\n        };\n        // Implementation of the nice number algorithm used in determining where axis labels will go\n        helpers.niceNum = function(range, round) {\n            var exponent = Math.floor(helpers.log10(range));\n            var fraction = range / Math.pow(10, exponent);\n            var niceFraction;\n            \n            if (round) {\n                if (fraction < 1.5) {\n                    niceFraction = 1;\n                } else if (fraction < 3) {\n                    niceFraction = 2;\n                } else if (fraction < 7) {\n                    niceFraction = 5;\n                } else {\n                    niceFraction = 10;\n                }\n            } else if (fraction <= 1.0) {\n                niceFraction = 1;\n            } else if (fraction <= 2) {\n                niceFraction = 2;\n            } else if (fraction <= 5) {\n                niceFraction = 5;\n            } else {\n                niceFraction = 10;\n            }\n            \n            return niceFraction * Math.pow(10, exponent);\n        };\n        // Easing functions adapted from Robert Penner's easing equations\n        // http://www.robertpenner.com/easing/\n        var easingEffects = helpers.easingEffects = {\n            linear: function(t) {\n                return t;\n            },\n            easeInQuad: function(t) {\n                return t * t;\n            },\n            easeOutQuad: function(t) {\n                return -1 * t * (t - 2);\n            },\n            easeInOutQuad: function(t) {\n                if ((t /= 1 / 2) < 1) {\n                    return 1 / 2 * t * t;\n                }\n                return -1 / 2 * ((--t) * (t - 2) - 1);\n            },\n            easeInCubic: function(t) {\n                return t * t * t;\n            },\n            easeOutCubic: function(t) {\n                return 1 * ((t = t / 1 - 1) * t * t + 1);\n            },\n            easeInOutCubic: function(t) {\n                if ((t /= 1 / 2) < 1) {\n                    return 1 / 2 * t * t * t;\n                }\n                return 1 / 2 * ((t -= 2) * t * t + 2);\n            },\n            easeInQuart: function(t) {\n                return t * t * t * t;\n            },\n            easeOutQuart: function(t) {\n                return -1 * ((t = t / 1 - 1) * t * t * t - 1);\n            },\n            easeInOutQuart: function(t) {\n                if ((t /= 1 / 2) < 1) {\n                    return 1 / 2 * t * t * t * t;\n                }\n                return -1 / 2 * ((t -= 2) * t * t * t - 2);\n            },\n            easeInQuint: function(t) {\n                return 1 * (t /= 1) * t * t * t * t;\n            },\n            easeOutQuint: function(t) {\n                return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);\n            },\n            easeInOutQuint: function(t) {\n                if ((t /= 1 / 2) < 1) {\n                    return 1 / 2 * t * t * t * t * t;\n                }\n                return 1 / 2 * ((t -= 2) * t * t * t * t + 2);\n            },\n            easeInSine: function(t) {\n                return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;\n            },\n            easeOutSine: function(t) {\n                return 1 * Math.sin(t / 1 * (Math.PI / 2));\n            },\n            easeInOutSine: function(t) {\n                return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);\n            },\n            easeInExpo: function(t) {\n                return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));\n            },\n            easeOutExpo: function(t) {\n                return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);\n            },\n            easeInOutExpo: function(t) {\n                if (t === 0) {\n                    return 0;\n                }\n                if (t === 1) {\n                    return 1;\n                }\n                if ((t /= 1 / 2) < 1) {\n                    return 1 / 2 * Math.pow(2, 10 * (t - 1));\n                }\n                return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);\n            },\n            easeInCirc: function(t) {\n                if (t >= 1) {\n                    return t;\n                }\n                return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);\n            },\n            easeOutCirc: function(t) {\n                return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);\n            },\n            easeInOutCirc: function(t) {\n                if ((t /= 1 / 2) < 1) {\n                    return -1 / 2 * (Math.sqrt(1 - t * t) - 1);\n                }\n                return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n            },\n            easeInElastic: function(t) {\n                var s = 1.70158;\n                var p = 0;\n                var a = 1;\n                if (t === 0) {\n                    return 0;\n                }\n                if ((t /= 1) === 1) {\n                    return 1;\n                }\n                if (!p) {\n                    p = 1 * 0.3;\n                }\n                if (a < Math.abs(1)) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p / (2 * Math.PI) * Math.asin(1 / a);\n                }\n                return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n            },\n            easeOutElastic: function(t) {\n                var s = 1.70158;\n                var p = 0;\n                var a = 1;\n                if (t === 0) {\n                    return 0;\n                }\n                if ((t /= 1) === 1) {\n                    return 1;\n                }\n                if (!p) {\n                    p = 1 * 0.3;\n                }\n                if (a < Math.abs(1)) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p / (2 * Math.PI) * Math.asin(1 / a);\n                }\n                return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;\n            },\n            easeInOutElastic: function(t) {\n                var s = 1.70158;\n                var p = 0;\n                var a = 1;\n                if (t === 0) {\n                    return 0;\n                }\n                if ((t /= 1 / 2) === 2) {\n                    return 1;\n                }\n                if (!p) {\n                    p = 1 * (0.3 * 1.5);\n                }\n                if (a < Math.abs(1)) {\n                    a = 1;\n                    s = p / 4;\n                } else {\n                    s = p / (2 * Math.PI) * Math.asin(1 / a);\n                }\n                if (t < 1) {\n                    return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));\n                }\n                return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;\n            },\n            easeInBack: function(t) {\n                var s = 1.70158;\n                return 1 * (t /= 1) * t * ((s + 1) * t - s);\n            },\n            easeOutBack: function(t) {\n                var s = 1.70158;\n                return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);\n            },\n            easeInOutBack: function(t) {\n                var s = 1.70158;\n                if ((t /= 1 / 2) < 1) {\n                    return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));\n                }\n                return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n            },\n            easeInBounce: function(t) {\n                return 1 - easingEffects.easeOutBounce(1 - t);\n            },\n            easeOutBounce: function(t) {\n                if ((t /= 1) < (1 / 2.75)) {\n                    return 1 * (7.5625 * t * t);\n                } else if (t < (2 / 2.75)) {\n                    return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);\n                } else if (t < (2.5 / 2.75)) {\n                    return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);\n                }\n                return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);\n            },\n            easeInOutBounce: function(t) {\n                if (t < 1 / 2) {\n                    return easingEffects.easeInBounce(t * 2) * 0.5;\n                }\n                return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;\n            }\n        };\n        // Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n        helpers.requestAnimFrame = (function() {\n            if (typeof window === 'undefined') {\n                return function(callback) {\n                    callback();\n                };\n            }\n            return window.requestAnimationFrame ||\n                window.webkitRequestAnimationFrame ||\n                window.mozRequestAnimationFrame ||\n                window.oRequestAnimationFrame ||\n                window.msRequestAnimationFrame ||\n                function(callback) {\n                    return window.setTimeout(callback, 1000 / 60);\n                };\n        }());\n        // -- DOM methods\n        helpers.getRelativePosition = function(evt, chart) {\n            var mouseX, mouseY;\n            var e = evt.originalEvent || evt,\n                canvas = evt.currentTarget || evt.srcElement,\n                boundingRect = canvas.getBoundingClientRect();\n            \n            var touches = e.touches;\n            if (touches && touches.length > 0) {\n                mouseX = touches[0].clientX;\n                mouseY = touches[0].clientY;\n                \n            } else {\n                mouseX = e.clientX;\n                mouseY = e.clientY;\n            }\n            \n            // Scale mouse coordinates into canvas coordinates\n            // by following the pattern laid out by 'jerryj' in the comments of\n            // http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n            var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));\n            var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));\n            var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));\n            var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));\n            var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n            var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n            \n            // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n            // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n            mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n            mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n            \n            return {\n                x: mouseX,\n                y: mouseY\n            };\n            \n        };\n        helpers.addEvent = function(node, eventType, method) {\n            if (node.addEventListener) {\n                node.addEventListener(eventType, method);\n            } else if (node.attachEvent) {\n                node.attachEvent('on' + eventType, method);\n            } else {\n                node['on' + eventType] = method;\n            }\n        };\n        helpers.removeEvent = function(node, eventType, handler) {\n            if (node.removeEventListener) {\n                node.removeEventListener(eventType, handler, false);\n            } else if (node.detachEvent) {\n                node.detachEvent('on' + eventType, handler);\n            } else {\n                node['on' + eventType] = helpers.noop;\n            }\n        };\n        \n        // Private helper function to convert max-width/max-height values that may be percentages into a number\n        function parseMaxStyle(styleValue, node, parentProperty) {\n            var valueInPixels;\n            if (typeof(styleValue) === 'string') {\n                valueInPixels = parseInt(styleValue, 10);\n                \n                if (styleValue.indexOf('%') !== -1) {\n                    // percentage * size in dimension\n                    valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n                }\n            } else {\n                valueInPixels = styleValue;\n            }\n            \n            return valueInPixels;\n        }\n        \n        /**\n         * Returns if the given value contains an effective constraint.\n         * @private\n         */\n        function isConstrainedValue(value) {\n            return value !== undefined && value !== null && value !== 'none';\n        }\n        \n        // Private helper to get a constraint dimension\n        // @param domNode : the node to check the constraint on\n        // @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)\n        // @param percentageProperty : property of parent to use when calculating width as a percentage\n        // @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser\n        function getConstraintDimension(domNode, maxStyle, percentageProperty) {\n            var view = document.defaultView;\n            var parentNode = domNode.parentNode;\n            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n            var hasCNode = isConstrainedValue(constrainedNode);\n            var hasCContainer = isConstrainedValue(constrainedContainer);\n            var infinity = Number.POSITIVE_INFINITY;\n            \n            if (hasCNode || hasCContainer) {\n                return Math.min(\n                    hasCNode? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n                    hasCContainer? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n            }\n            \n            return 'none';\n        }\n        // returns Number or undefined if no constraint\n        helpers.getConstraintWidth = function(domNode) {\n            return getConstraintDimension(domNode, 'max-width', 'clientWidth');\n        };\n        // returns Number or undefined if no constraint\n        helpers.getConstraintHeight = function(domNode) {\n            return getConstraintDimension(domNode, 'max-height', 'clientHeight');\n        };\n        helpers.getMaximumWidth = function(domNode) {\n            var container = domNode.parentNode;\n            var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);\n            var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);\n            var w = container.clientWidth - paddingLeft - paddingRight;\n            var cw = helpers.getConstraintWidth(domNode);\n            return isNaN(cw)? w : Math.min(w, cw);\n        };\n        helpers.getMaximumHeight = function(domNode) {\n            var container = domNode.parentNode;\n            var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);\n            var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);\n            var h = container.clientHeight - paddingTop - paddingBottom;\n            var ch = helpers.getConstraintHeight(domNode);\n            return isNaN(ch)? h : Math.min(h, ch);\n        };\n        helpers.getStyle = function(el, property) {\n            return el.currentStyle ?\n                el.currentStyle[property] :\n                document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n        };\n        helpers.retinaScale = function(chart) {\n            var pixelRatio = chart.currentDevicePixelRatio = window.devicePixelRatio || 1;\n            if (pixelRatio === 1) {\n                return;\n            }\n            \n            var canvas = chart.canvas;\n            var height = chart.height;\n            var width = chart.width;\n            \n            canvas.height = height * pixelRatio;\n            canvas.width = width * pixelRatio;\n            chart.ctx.scale(pixelRatio, pixelRatio);\n            \n            // If no style has been set on the canvas, the render size is used as display size,\n            // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n            // See https://github.com/chartjs/Chart.js/issues/3575\n            canvas.style.height = height + 'px';\n            canvas.style.width = width + 'px';\n        };\n        // -- Canvas methods\n        helpers.clear = function(chart) {\n            chart.ctx.clearRect(0, 0, chart.width, chart.height);\n        };\n        helpers.fontString = function(pixelSize, fontStyle, fontFamily) {\n            return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n        };\n        helpers.longestText = function(ctx, font, arrayOfThings, cache) {\n            cache = cache || {};\n            var data = cache.data = cache.data || {};\n            var gc = cache.garbageCollect = cache.garbageCollect || [];\n            \n            if (cache.font !== font) {\n                data = cache.data = {};\n                gc = cache.garbageCollect = [];\n                cache.font = font;\n            }\n            \n            ctx.font = font;\n            var longest = 0;\n            helpers.each(arrayOfThings, function(thing) {\n                // Undefined strings and arrays should not be measured\n                if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {\n                    longest = helpers.measureText(ctx, data, gc, longest, thing);\n                } else if (helpers.isArray(thing)) {\n                    // if it is an array lets measure each element\n                    // to do maybe simplify this function a bit so we can do this more recursively?\n                    helpers.each(thing, function(nestedThing) {\n                        // Undefined strings and arrays should not be measured\n                        if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {\n                            longest = helpers.measureText(ctx, data, gc, longest, nestedThing);\n                        }\n                    });\n                }\n            });\n            \n            var gcLen = gc.length / 2;\n            if (gcLen > arrayOfThings.length) {\n                for (var i = 0; i < gcLen; i++) {\n                    delete data[gc[i]];\n                }\n                gc.splice(0, gcLen);\n            }\n            return longest;\n        };\n        helpers.measureText = function(ctx, data, gc, longest, string) {\n            var textWidth = data[string];\n            if (!textWidth) {\n                textWidth = data[string] = ctx.measureText(string).width;\n                gc.push(string);\n            }\n            if (textWidth > longest) {\n                longest = textWidth;\n            }\n            return longest;\n        };\n        helpers.numberOfLabelLines = function(arrayOfThings) {\n            var numberOfLines = 1;\n            helpers.each(arrayOfThings, function(thing) {\n                if (helpers.isArray(thing)) {\n                    if (thing.length > numberOfLines) {\n                        numberOfLines = thing.length;\n                    }\n                }\n            });\n            return numberOfLines;\n        };\n        helpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {\n            ctx.beginPath();\n            ctx.moveTo(x + radius, y);\n            ctx.lineTo(x + width - radius, y);\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n            ctx.lineTo(x + width, y + height - radius);\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n            ctx.lineTo(x + radius, y + height);\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n            ctx.lineTo(x, y + radius);\n            ctx.quadraticCurveTo(x, y, x + radius, y);\n            ctx.closePath();\n        };\n        \n        helpers.color = !color?\n            function(value) {\n                console.error('Color.js not found!');\n                return value;\n            } :\n            function(value) {\n                /* global CanvasGradient */\n                if (value instanceof CanvasGradient) {\n                    value = Chart.defaults.global.defaultColor;\n                }\n                \n                return color(value);\n            };\n        \n        helpers.isArray = Array.isArray?\n            function(obj) {\n                return Array.isArray(obj);\n            } :\n            function(obj) {\n                return Object.prototype.toString.call(obj) === '[object Array]';\n            };\n        // ! @see http://stackoverflow.com/a/14853974\n        helpers.arrayEquals = function(a0, a1) {\n            var i, ilen, v0, v1;\n            \n            if (!a0 || !a1 || a0.length !== a1.length) {\n                return false;\n            }\n            \n            for (i = 0, ilen=a0.length; i < ilen; ++i) {\n                v0 = a0[i];\n                v1 = a1[i];\n                \n                if (v0 instanceof Array && v1 instanceof Array) {\n                    if (!helpers.arrayEquals(v0, v1)) {\n                        return false;\n                    }\n                } else if (v0 !== v1) {\n                    // NOTE: two different object instances will never be equal: {x:20} != {x:20}\n                    return false;\n                }\n            }\n            \n            return true;\n        };\n        helpers.callback = function(fn, args, thisArg) {\n            if (fn && typeof fn.call === 'function') {\n                fn.apply(thisArg, args);\n            }\n        };\n        helpers.getHoverColor = function(colorValue) {\n            /* global CanvasPattern */\n            return (colorValue instanceof CanvasPattern) ?\n                colorValue :\n                helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n        };\n        \n        /**\n         * Provided for backward compatibility, use Chart.helpers#callback instead.\n         * @function Chart.helpers#callCallback\n         * @deprecated since version 2.6.0\n         * @todo remove at version 3\n         */\n        helpers.callCallback = helpers.callback;\n    };\n    \n},{\"46\":46}],21:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        var helpers = Chart.helpers;\n        \n        /**\n         * Helper function to get relative position for an event\n         * @param {Event|IEvent} event - The event to get the position for\n         * @param {Chart} chart - The chart\n         * @returns {Point} the event position\n         */\n        function getRelativePosition(e, chart) {\n            if (e.native) {\n                return {\n                    x: e.x,\n                    y: e.y\n                };\n            }\n            \n            return helpers.getRelativePosition(e, chart);\n        }\n        \n        /**\n         * Helper function to traverse all of the visible elements in the chart\n         * @param chart {chart} the chart\n         * @param handler {Function} the callback to execute for each visible item\n         */\n        function parseVisibleItems(chart, handler) {\n            var datasets = chart.data.datasets;\n            var meta, i, j, ilen, jlen;\n            \n            for (i = 0, ilen = datasets.length; i < ilen; ++i) {\n                if (!chart.isDatasetVisible(i)) {\n                    continue;\n                }\n                \n                meta = chart.getDatasetMeta(i);\n                for (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n                    var element = meta.data[j];\n                    if (!element._view.skip) {\n                        handler(element);\n                    }\n                }\n            }\n        }\n        \n        /**\n         * Helper function to get the items that intersect the event position\n         * @param items {ChartElement[]} elements to filter\n         * @param position {Point} the point to be nearest to\n         * @return {ChartElement[]} the nearest items\n         */\n        function getIntersectItems(chart, position) {\n            var elements = [];\n            \n            parseVisibleItems(chart, function(element) {\n                if (element.inRange(position.x, position.y)) {\n                    elements.push(element);\n                }\n            });\n            \n            return elements;\n        }\n        \n        /**\n         * Helper function to get the items nearest to the event position considering all visible items in teh chart\n         * @param chart {Chart} the chart to look at elements from\n         * @param position {Point} the point to be nearest to\n         * @param intersect {Boolean} if true, only consider items that intersect the position\n         * @param distanceMetric {Function} Optional function to provide the distance between\n         * @return {ChartElement[]} the nearest items\n         */\n        function getNearestItems(chart, position, intersect, distanceMetric) {\n            var minDistance = Number.POSITIVE_INFINITY;\n            var nearestItems = [];\n            \n            if (!distanceMetric) {\n                distanceMetric = helpers.distanceBetweenPoints;\n            }\n            \n            parseVisibleItems(chart, function(element) {\n                if (intersect && !element.inRange(position.x, position.y)) {\n                    return;\n                }\n                \n                var center = element.getCenterPoint();\n                var distance = distanceMetric(position, center);\n                \n                if (distance < minDistance) {\n                    nearestItems = [element];\n                    minDistance = distance;\n                } else if (distance === minDistance) {\n                    // Can have multiple items at the same distance in which case we sort by size\n                    nearestItems.push(element);\n                }\n            });\n            \n            return nearestItems;\n        }\n        \n        function indexMode(chart, e, options) {\n            var position = getRelativePosition(e, chart);\n            var distanceMetric = function(pt1, pt2) {\n                return Math.abs(pt1.x - pt2.x);\n            };\n            var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n            var elements = [];\n            \n            if (!items.length) {\n                return [];\n            }\n            \n            chart.data.datasets.forEach(function(dataset, datasetIndex) {\n                if (chart.isDatasetVisible(datasetIndex)) {\n                    var meta = chart.getDatasetMeta(datasetIndex),\n                        element = meta.data[items[0]._index];\n                    \n                    // don't count items that are skipped (null data)\n                    if (element && !element._view.skip) {\n                        elements.push(element);\n                    }\n                }\n            });\n            \n            return elements;\n        }\n        \n        /**\n         * @interface IInteractionOptions\n         */\n        /**\n         * If true, only consider items that intersect the point\n         * @name IInterfaceOptions#boolean\n         * @type Boolean\n         */\n        \n        /**\n         * Contains interaction related functions\n         * @namespace Chart.Interaction\n         */\n        Chart.Interaction = {\n            // Helper function for different modes\n            modes: {\n                single: function(chart, e) {\n                    var position = getRelativePosition(e, chart);\n                    var elements = [];\n                    \n                    parseVisibleItems(chart, function(element) {\n                        if (element.inRange(position.x, position.y)) {\n                            elements.push(element);\n                            return elements;\n                        }\n                    });\n                    \n                    return elements.slice(0, 1);\n                },\n                \n                /**\n                 * @function Chart.Interaction.modes.label\n                 * @deprecated since version 2.4.0\n                 * @todo remove at version 3\n                 * @private\n                 */\n                label: indexMode,\n                \n                /**\n                 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n                 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n                 * @function Chart.Interaction.modes.index\n                 * @since v2.4.0\n                 * @param chart {chart} the chart we are returning items from\n                 * @param e {Event} the event we are find things at\n                 * @param options {IInteractionOptions} options to use during interaction\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n                 */\n                index: indexMode,\n                \n                /**\n                 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n                 * If the options.intersect is false, we find the nearest item and return the items in that dataset\n                 * @function Chart.Interaction.modes.dataset\n                 * @param chart {chart} the chart we are returning items from\n                 * @param e {Event} the event we are find things at\n                 * @param options {IInteractionOptions} options to use during interaction\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n                 */\n                dataset: function(chart, e, options) {\n                    var position = getRelativePosition(e, chart);\n                    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false);\n                    \n                    if (items.length > 0) {\n                        items = chart.getDatasetMeta(items[0]._datasetIndex).data;\n                    }\n                    \n                    return items;\n                },\n                \n                /**\n                 * @function Chart.Interaction.modes.x-axis\n                 * @deprecated since version 2.4.0. Use index mode and intersect == true\n                 * @todo remove at version 3\n                 * @private\n                 */\n                'x-axis': function(chart, e) {\n                    return indexMode(chart, e, true);\n                },\n                \n                /**\n                 * Point mode returns all elements that hit test based on the event position\n                 * of the event\n                 * @function Chart.Interaction.modes.intersect\n                 * @param chart {chart} the chart we are returning items from\n                 * @param e {Event} the event we are find things at\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n                 */\n                point: function(chart, e) {\n                    var position = getRelativePosition(e, chart);\n                    return getIntersectItems(chart, position);\n                },\n                \n                /**\n                 * nearest mode returns the element closest to the point\n                 * @function Chart.Interaction.modes.intersect\n                 * @param chart {chart} the chart we are returning items from\n                 * @param e {Event} the event we are find things at\n                 * @param options {IInteractionOptions} options to use\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n                 */\n                nearest: function(chart, e, options) {\n                    var position = getRelativePosition(e, chart);\n                    var nearestItems = getNearestItems(chart, position, options.intersect);\n                    \n                    // We have multiple items at the same distance from the event. Now sort by smallest\n                    if (nearestItems.length > 1) {\n                        nearestItems.sort(function(a, b) {\n                            var sizeA = a.getArea();\n                            var sizeB = b.getArea();\n                            var ret = sizeA - sizeB;\n                            \n                            if (ret === 0) {\n                                // if equal sort by dataset index\n                                ret = a._datasetIndex - b._datasetIndex;\n                            }\n                            \n                            return ret;\n                        });\n                    }\n                    \n                    // Return only 1 item\n                    return nearestItems.slice(0, 1);\n                },\n                \n                /**\n                 * x mode returns the elements that hit-test at the current x coordinate\n                 * @function Chart.Interaction.modes.x\n                 * @param chart {chart} the chart we are returning items from\n                 * @param e {Event} the event we are find things at\n                 * @param options {IInteractionOptions} options to use\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n                 */\n                x: function(chart, e, options) {\n                    var position = getRelativePosition(e, chart);\n                    var items = [];\n                    var intersectsItem = false;\n                    \n                    parseVisibleItems(chart, function(element) {\n                        if (element.inXRange(position.x)) {\n                            items.push(element);\n                        }\n                        \n                        if (element.inRange(position.x, position.y)) {\n                            intersectsItem = true;\n                        }\n                    });\n                    \n                    // If we want to trigger on an intersect and we don't have any items\n                    // that intersect the position, return nothing\n                    if (options.intersect && !intersectsItem) {\n                        items = [];\n                    }\n                    return items;\n                },\n                \n                /**\n                 * y mode returns the elements that hit-test at the current y coordinate\n                 * @function Chart.Interaction.modes.y\n                 * @param chart {chart} the chart we are returning items from\n                 * @param e {Event} the event we are find things at\n                 * @param options {IInteractionOptions} options to use\n                 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n                 */\n                y: function(chart, e, options) {\n                    var position = getRelativePosition(e, chart);\n                    var items = [];\n                    var intersectsItem = false;\n                    \n                    parseVisibleItems(chart, function(element) {\n                        if (element.inYRange(position.y)) {\n                            items.push(element);\n                        }\n                        \n                        if (element.inRange(position.x, position.y)) {\n                            intersectsItem = true;\n                        }\n                    });\n                    \n                    // If we want to trigger on an intersect and we don't have any items\n                    // that intersect the position, return nothing\n                    if (options.intersect && !intersectsItem) {\n                        items = [];\n                    }\n                    return items;\n                }\n            }\n        };\n    };\n    \n},{}],22:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function () {\n        \n        // Occupy the global variable of Chart, and create a simple base class\n        var Chart = function (item, config) {\n            this.construct(item, config);\n            return this;\n        };\n        \n        // Globally expose the defaults to allow for user updating/changing\n        Chart.defaults = {\n            global: {\n                responsive:                  true,\n                responsiveAnimationDuration: 0,\n                maintainAspectRatio:         true,\n                events:                      ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],\n                hover:                       {\n                    onHover:           null,\n                    mode:              'nearest',\n                    intersect:         true,\n                    animationDuration: 400\n                },\n                onClick:                     null,\n                defaultColor:                'rgba(0,0,0,0.1)',\n                defaultFontColor:            '#666',\n                defaultFontFamily:           \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n                defaultFontSize:             12,\n                defaultFontStyle:            'normal',\n                showLines:                   true,\n                \n                // Element defaults defined in element extensions\n                elements: {},\n                \n                // Legend callback string\n                legendCallback: function (chart) {\n                    var text = [];\n                    text.push('<ul class=\"' + chart.id + '-legend\">');\n                    for (var i = 0; i < chart.data.datasets.length; i++) {\n                        if (chart.data.datasets[i].label) {\n                            text.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n                            text.push(chart.data.datasets[i].label);\n                            text.push('</li>');\n                        }\n                    }\n                    text.push('</ul>');\n                    \n                    return text.join('');\n                }\n            }\n        };\n        \n        Chart.Chart = Chart;\n        \n        return Chart;\n    };\n    \n},{}],23:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        function filterByPosition(array, position) {\n            return helpers.where(array, function(v) {\n                return v.position === position;\n            });\n        }\n        \n        function sortByWeight(array, reverse) {\n            array.forEach(function(v, i) {\n                v._tmpIndex_ = i;\n                return v;\n            });\n            array.sort(function(a, b) {\n                var v0 = reverse ? b : a;\n                var v1 = reverse ? a : b;\n                return v0.weight === v1.weight ?\n                    v0._tmpIndex_ - v1._tmpIndex_ :\n                    v0.weight - v1.weight;\n            });\n            array.forEach(function(v) {\n                delete v._tmpIndex_;\n            });\n        }\n        \n        /**\n         * @interface ILayoutItem\n         * @prop {String} position - The position of the item in the chart layout. Possible values are\n         * 'left', 'top', 'right', 'bottom', and 'chartArea'\n         * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n         * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n         * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n         * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n         * @prop {Function} getPadding -  Returns an object with padding on the edges\n         * @prop {Number} width - Width of item. Must be valid after update()\n         * @prop {Number} height - Height of item. Must be valid after update()\n         * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n         * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n         * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n         * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n         */\n        \n        // The layout service is very self explanatory.  It's responsible for the layout within a chart.\n        // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n        // It is this service's responsibility of carrying out that layout.\n        Chart.layoutService = {\n            defaults: {},\n            \n            /**\n             * Register a box to a chart.\n             * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n             * @param {Chart} chart - the chart to use\n             * @param {ILayoutItem} item - the item to add to be layed out\n             */\n            addBox: function(chart, item) {\n                if (!chart.boxes) {\n                    chart.boxes = [];\n                }\n                \n                // initialize item with default values\n                item.fullWidth = item.fullWidth || false;\n                item.position = item.position || 'top';\n                item.weight = item.weight || 0;\n                \n                chart.boxes.push(item);\n            },\n            \n            /**\n             * Remove a layoutItem from a chart\n             * @param {Chart} chart - the chart to remove the box from\n             * @param {Object} layoutItem - the item to remove from the layout\n             */\n            removeBox: function(chart, layoutItem) {\n                var index = chart.boxes? chart.boxes.indexOf(layoutItem) : -1;\n                if (index !== -1) {\n                    chart.boxes.splice(index, 1);\n                }\n            },\n            \n            /**\n             * Sets (or updates) options on the given `item`.\n             * @param {Chart} chart - the chart in which the item lives (or will be added to)\n             * @param {Object} item - the item to configure with the given options\n             * @param {Object} options - the new item options.\n             */\n            configure: function(chart, item, options) {\n                var props = ['fullWidth', 'position', 'weight'];\n                var ilen = props.length;\n                var i = 0;\n                var prop;\n                \n                for (; i<ilen; ++i) {\n                    prop = props[i];\n                    if (options.hasOwnProperty(prop)) {\n                        item[prop] = options[prop];\n                    }\n                }\n            },\n            \n            /**\n             * Fits boxes of the given chart into the given size by having each box measure itself\n             * then running a fitting algorithm\n             * @param {Chart} chart - the chart\n             * @param {Number} width - the width to fit into\n             * @param {Number} height - the height to fit into\n             */\n            update: function(chart, width, height) {\n                if (!chart) {\n                    return;\n                }\n                \n                var layoutOptions = chart.options.layout;\n                var padding = layoutOptions ? layoutOptions.padding : null;\n                \n                var leftPadding = 0;\n                var rightPadding = 0;\n                var topPadding = 0;\n                var bottomPadding = 0;\n                \n                if (!isNaN(padding)) {\n                    // options.layout.padding is a number. assign to all\n                    leftPadding = padding;\n                    rightPadding = padding;\n                    topPadding = padding;\n                    bottomPadding = padding;\n                } else {\n                    leftPadding = padding.left || 0;\n                    rightPadding = padding.right || 0;\n                    topPadding = padding.top || 0;\n                    bottomPadding = padding.bottom || 0;\n                }\n                \n                var leftBoxes = filterByPosition(chart.boxes, 'left');\n                var rightBoxes = filterByPosition(chart.boxes, 'right');\n                var topBoxes = filterByPosition(chart.boxes, 'top');\n                var bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n                var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n                \n                // Sort boxes by weight. A higher weight is further away from the chart area\n                sortByWeight(leftBoxes, true);\n                sortByWeight(rightBoxes, false);\n                sortByWeight(topBoxes, true);\n                sortByWeight(bottomBoxes, false);\n                \n                // Essentially we now have any number of boxes on each of the 4 sides.\n                // Our canvas looks like the following.\n                // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n                // B1 is the bottom axis\n                // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n                // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n                // an error will be thrown.\n                //\n                // |----------------------------------------------------|\n                // |                  T1 (Full Width)                   |\n                // |----------------------------------------------------|\n                // |    |    |                 T2                  |    |\n                // |    |----|-------------------------------------|----|\n                // |    |    | C1 |                           | C2 |    |\n                // |    |    |----|                           |----|    |\n                // |    |    |                                     |    |\n                // | L1 | L2 |           ChartArea (C0)            | R1 |\n                // |    |    |                                     |    |\n                // |    |    |----|                           |----|    |\n                // |    |    | C3 |                           | C4 |    |\n                // |    |----|-------------------------------------|----|\n                // |    |    |                 B1                  |    |\n                // |----------------------------------------------------|\n                // |                  B2 (Full Width)                   |\n                // |----------------------------------------------------|\n                //\n                // What we do to find the best sizing, we do the following\n                // 1. Determine the minimum size of the chart area.\n                // 2. Split the remaining width equally between each vertical axis\n                // 3. Split the remaining height equally between each horizontal axis\n                // 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n                // 5. Adjust the sizes of each axis based on it's minimum reported size.\n                // 6. Refit each axis\n                // 7. Position each axis in the final location\n                // 8. Tell the chart the final location of the chart area\n                // 9. Tell any axes that overlay the chart area the positions of the chart area\n                \n                // Step 1\n                var chartWidth = width - leftPadding - rightPadding;\n                var chartHeight = height - topPadding - bottomPadding;\n                var chartAreaWidth = chartWidth / 2; // min 50%\n                var chartAreaHeight = chartHeight / 2; // min 50%\n                \n                // Step 2\n                var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n                \n                // Step 3\n                var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n                \n                // Step 4\n                var maxChartAreaWidth = chartWidth;\n                var maxChartAreaHeight = chartHeight;\n                var minBoxSizes = [];\n                \n                function getMinimumBoxSize(box) {\n                    var minSize;\n                    var isHorizontal = box.isHorizontal();\n                    \n                    if (isHorizontal) {\n                        minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n                        maxChartAreaHeight -= minSize.height;\n                    } else {\n                        minSize = box.update(verticalBoxWidth, chartAreaHeight);\n                        maxChartAreaWidth -= minSize.width;\n                    }\n                    \n                    minBoxSizes.push({\n                        horizontal: isHorizontal,\n                        minSize: minSize,\n                        box: box,\n                    });\n                }\n                \n                helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n                \n                // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n                var maxHorizontalLeftPadding = 0;\n                var maxHorizontalRightPadding = 0;\n                var maxVerticalTopPadding = 0;\n                var maxVerticalBottomPadding = 0;\n                \n                helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n                    if (horizontalBox.getPadding) {\n                        var boxPadding = horizontalBox.getPadding();\n                        maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n                        maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n                    }\n                });\n                \n                helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n                    if (verticalBox.getPadding) {\n                        var boxPadding = verticalBox.getPadding();\n                        maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n                        maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n                    }\n                });\n                \n                // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n                // be if the axes are drawn at their minimum sizes.\n                // Steps 5 & 6\n                var totalLeftBoxesWidth = leftPadding;\n                var totalRightBoxesWidth = rightPadding;\n                var totalTopBoxesHeight = topPadding;\n                var totalBottomBoxesHeight = bottomPadding;\n                \n                // Function to fit a box\n                function fitBox(box) {\n                    var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n                        return minBox.box === box;\n                    });\n                    \n                    if (minBoxSize) {\n                        if (box.isHorizontal()) {\n                            var scaleMargin = {\n                                left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n                                right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n                                top: 0,\n                                bottom: 0\n                            };\n                            \n                            // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n                            // on the margin. Sometimes they need to increase in size slightly\n                            box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n                        } else {\n                            box.update(minBoxSize.minSize.width, maxChartAreaHeight);\n                        }\n                    }\n                }\n                \n                // Update, and calculate the left and right margins for the horizontal boxes\n                helpers.each(leftBoxes.concat(rightBoxes), fitBox);\n                \n                helpers.each(leftBoxes, function(box) {\n                    totalLeftBoxesWidth += box.width;\n                });\n                \n                helpers.each(rightBoxes, function(box) {\n                    totalRightBoxesWidth += box.width;\n                });\n                \n                // Set the Left and Right margins for the horizontal boxes\n                helpers.each(topBoxes.concat(bottomBoxes), fitBox);\n                \n                // Figure out how much margin is on the top and bottom of the vertical boxes\n                helpers.each(topBoxes, function(box) {\n                    totalTopBoxesHeight += box.height;\n                });\n                \n                helpers.each(bottomBoxes, function(box) {\n                    totalBottomBoxesHeight += box.height;\n                });\n                \n                function finalFitVerticalBox(box) {\n                    var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n                        return minSize.box === box;\n                    });\n                    \n                    var scaleMargin = {\n                        left: 0,\n                        right: 0,\n                        top: totalTopBoxesHeight,\n                        bottom: totalBottomBoxesHeight\n                    };\n                    \n                    if (minBoxSize) {\n                        box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n                    }\n                }\n                \n                // Let the left layout know the final margin\n                helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n                \n                // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n                totalLeftBoxesWidth = leftPadding;\n                totalRightBoxesWidth = rightPadding;\n                totalTopBoxesHeight = topPadding;\n                totalBottomBoxesHeight = bottomPadding;\n                \n                helpers.each(leftBoxes, function(box) {\n                    totalLeftBoxesWidth += box.width;\n                });\n                \n                helpers.each(rightBoxes, function(box) {\n                    totalRightBoxesWidth += box.width;\n                });\n                \n                helpers.each(topBoxes, function(box) {\n                    totalTopBoxesHeight += box.height;\n                });\n                helpers.each(bottomBoxes, function(box) {\n                    totalBottomBoxesHeight += box.height;\n                });\n                \n                // We may be adding some padding to account for rotated x axis labels\n                var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n                totalLeftBoxesWidth += leftPaddingAddition;\n                totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n                \n                var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n                totalTopBoxesHeight += topPaddingAddition;\n                totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n                \n                // Figure out if our chart area changed. This would occur if the dataset layout label rotation\n                // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n                // without calling `fit` again\n                var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n                var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n                \n                if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n                    helpers.each(leftBoxes, function(box) {\n                        box.height = newMaxChartAreaHeight;\n                    });\n                    \n                    helpers.each(rightBoxes, function(box) {\n                        box.height = newMaxChartAreaHeight;\n                    });\n                    \n                    helpers.each(topBoxes, function(box) {\n                        if (!box.fullWidth) {\n                            box.width = newMaxChartAreaWidth;\n                        }\n                    });\n                    \n                    helpers.each(bottomBoxes, function(box) {\n                        if (!box.fullWidth) {\n                            box.width = newMaxChartAreaWidth;\n                        }\n                    });\n                    \n                    maxChartAreaHeight = newMaxChartAreaHeight;\n                    maxChartAreaWidth = newMaxChartAreaWidth;\n                }\n                \n                // Step 7 - Position the boxes\n                var left = leftPadding + leftPaddingAddition;\n                var top = topPadding + topPaddingAddition;\n                \n                function placeBox(box) {\n                    if (box.isHorizontal()) {\n                        box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n                        box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n                        box.top = top;\n                        box.bottom = top + box.height;\n                        \n                        // Move to next point\n                        top = box.bottom;\n                        \n                    } else {\n                        \n                        box.left = left;\n                        box.right = left + box.width;\n                        box.top = totalTopBoxesHeight;\n                        box.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n                        \n                        // Move to next point\n                        left = box.right;\n                    }\n                }\n                \n                helpers.each(leftBoxes.concat(topBoxes), placeBox);\n                \n                // Account for chart width and height\n                left += maxChartAreaWidth;\n                top += maxChartAreaHeight;\n                \n                helpers.each(rightBoxes, placeBox);\n                helpers.each(bottomBoxes, placeBox);\n                \n                // Step 8\n                chart.chartArea = {\n                    left: totalLeftBoxesWidth,\n                    top: totalTopBoxesHeight,\n                    right: totalLeftBoxesWidth + maxChartAreaWidth,\n                    bottom: totalTopBoxesHeight + maxChartAreaHeight\n                };\n                \n                // Step 9\n                helpers.each(chartAreaBoxes, function(box) {\n                    box.left = chart.chartArea.left;\n                    box.top = chart.chartArea.top;\n                    box.right = chart.chartArea.right;\n                    box.bottom = chart.chartArea.bottom;\n                    \n                    box.update(maxChartAreaWidth, maxChartAreaHeight);\n                });\n            }\n        };\n    };\n    \n},{}],24:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.global.plugins = {};\n        \n        /**\n         * The plugin service singleton\n         * @namespace Chart.plugins\n         * @since 2.1.0\n         */\n        Chart.plugins = {\n            /**\n             * Globally registered plugins.\n             * @private\n             */\n            _plugins: [],\n            \n            /**\n             * This identifier is used to invalidate the descriptors cache attached to each chart\n             * when a global plugin is registered or unregistered. In this case, the cache ID is\n             * incremented and descriptors are regenerated during following API calls.\n             * @private\n             */\n            _cacheId: 0,\n            \n            /**\n             * Registers the given plugin(s) if not already registered.\n             * @param {Array|Object} plugins plugin instance(s).\n             */\n            register: function(plugins) {\n                var p = this._plugins;\n                ([]).concat(plugins).forEach(function(plugin) {\n                    if (p.indexOf(plugin) === -1) {\n                        p.push(plugin);\n                    }\n                });\n                \n                this._cacheId++;\n            },\n            \n            /**\n             * Unregisters the given plugin(s) only if registered.\n             * @param {Array|Object} plugins plugin instance(s).\n             */\n            unregister: function(plugins) {\n                var p = this._plugins;\n                ([]).concat(plugins).forEach(function(plugin) {\n                    var idx = p.indexOf(plugin);\n                    if (idx !== -1) {\n                        p.splice(idx, 1);\n                    }\n                });\n                \n                this._cacheId++;\n            },\n            \n            /**\n             * Remove all registered plugins.\n             * @since 2.1.5\n             */\n            clear: function() {\n                this._plugins = [];\n                this._cacheId++;\n            },\n            \n            /**\n             * Returns the number of registered plugins?\n             * @returns {Number}\n             * @since 2.1.5\n             */\n            count: function() {\n                return this._plugins.length;\n            },\n            \n            /**\n             * Returns all registered plugin instances.\n             * @returns {Array} array of plugin objects.\n             * @since 2.1.5\n             */\n            getAll: function() {\n                return this._plugins;\n            },\n            \n            /**\n             * Calls enabled plugins for `chart` on the specified hook and with the given args.\n             * This method immediately returns as soon as a plugin explicitly returns false. The\n             * returned value can be used, for instance, to interrupt the current action.\n             * @param {Object} chart - The chart instance for which plugins should be called.\n             * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n             * @param {Array} [args] - Extra arguments to apply to the hook call.\n             * @returns {Boolean} false if any of the plugins return false, else returns true.\n             */\n            notify: function(chart, hook, args) {\n                var descriptors = this.descriptors(chart);\n                var ilen = descriptors.length;\n                var i, descriptor, plugin, params, method;\n                \n                for (i=0; i<ilen; ++i) {\n                    descriptor = descriptors[i];\n                    plugin = descriptor.plugin;\n                    method = plugin[hook];\n                    if (typeof method === 'function') {\n                        params = [chart].concat(args || []);\n                        params.push(descriptor.options);\n                        if (method.apply(plugin, params) === false) {\n                            return false;\n                        }\n                    }\n                }\n                \n                return true;\n            },\n            \n            /**\n             * Returns descriptors of enabled plugins for the given chart.\n             * @returns {Array} [{ plugin, options }]\n             * @private\n             */\n            descriptors: function(chart) {\n                var cache = chart._plugins || (chart._plugins = {});\n                if (cache.id === this._cacheId) {\n                    return cache.descriptors;\n                }\n                \n                var plugins = [];\n                var descriptors = [];\n                var config = (chart && chart.config) || {};\n                var defaults = Chart.defaults.global.plugins;\n                var options = (config.options && config.options.plugins) || {};\n                \n                this._plugins.concat(config.plugins || []).forEach(function(plugin) {\n                    var idx = plugins.indexOf(plugin);\n                    if (idx !== -1) {\n                        return;\n                    }\n                    \n                    var id = plugin.id;\n                    var opts = options[id];\n                    if (opts === false) {\n                        return;\n                    }\n                    \n                    if (opts === true) {\n                        opts = helpers.clone(defaults[id]);\n                    }\n                    \n                    plugins.push(plugin);\n                    descriptors.push({\n                        plugin: plugin,\n                        options: opts || {}\n                    });\n                });\n                \n                cache.descriptors = descriptors;\n                cache.id = this._cacheId;\n                return descriptors;\n            }\n        };\n        \n        /**\n         * Plugin extension hooks.\n         * @interface IPlugin\n         * @since 2.1.0\n         */\n        /**\n         * @method IPlugin#beforeInit\n         * @desc Called before initializing `chart`.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#afterInit\n         * @desc Called after `chart` has been initialized and before the first update.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeUpdate\n         * @desc Called before updating `chart`. If any plugin returns `false`, the update\n         * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} `false` to cancel the chart update.\n         */\n        /**\n         * @method IPlugin#afterUpdate\n         * @desc Called after `chart` has been updated and before rendering. Note that this\n         * hook will not be called if the chart update has been previously cancelled.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeDatasetsUpdate\n         * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n         * the datasets update is cancelled until another `update` is triggered.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} false to cancel the datasets update.\n         * @since version 2.1.5\n         */\n        /**\n         * @method IPlugin#afterDatasetsUpdate\n         * @desc Called after the `chart` datasets have been updated. Note that this hook\n         * will not be called if the datasets update has been previously cancelled.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         * @since version 2.1.5\n         */\n        /**\n         * @method IPlugin#beforeDatasetUpdate\n         * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n         * returns `false`, the datasets update is cancelled until another `update` is triggered.\n         * @param {Chart} chart - The chart instance.\n         * @param {Object} args - The call arguments.\n         * @param {Object} args.index - The dataset index.\n         * @param {Number} args.meta - The dataset metadata.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} `false` to cancel the chart datasets drawing.\n         */\n        /**\n         * @method IPlugin#afterDatasetUpdate\n         * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n         * that this hook will not be called if the datasets update has been previously cancelled.\n         * @param {Chart} chart - The chart instance.\n         * @param {Object} args - The call arguments.\n         * @param {Object} args.index - The dataset index.\n         * @param {Number} args.meta - The dataset metadata.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeLayout\n         * @desc Called before laying out `chart`. If any plugin returns `false`,\n         * the layout update is cancelled until another `update` is triggered.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} `false` to cancel the chart layout.\n         */\n        /**\n         * @method IPlugin#afterLayout\n         * @desc Called after the `chart` has been layed out. Note that this hook will not\n         * be called if the layout update has been previously cancelled.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeRender\n         * @desc Called before rendering `chart`. If any plugin returns `false`,\n         * the rendering is cancelled until another `render` is triggered.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} `false` to cancel the chart rendering.\n         */\n        /**\n         * @method IPlugin#afterRender\n         * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n         * that this hook will not be called if the rendering has been previously cancelled.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeDraw\n         * @desc Called before drawing `chart` at every animation frame specified by the given\n         * easing value. If any plugin returns `false`, the frame drawing is cancelled until\n         * another `render` is triggered.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} `false` to cancel the chart drawing.\n         */\n        /**\n         * @method IPlugin#afterDraw\n         * @desc Called after the `chart` has been drawn for the specific easing value. Note\n         * that this hook will not be called if the drawing has been previously cancelled.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeDatasetsDraw\n         * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n         * the datasets drawing is cancelled until another `render` is triggered.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} `false` to cancel the chart datasets drawing.\n         */\n        /**\n         * @method IPlugin#afterDatasetsDraw\n         * @desc Called after the `chart` datasets have been drawn. Note that this hook\n         * will not be called if the datasets drawing has been previously cancelled.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeDatasetDraw\n         * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n         * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n         * is cancelled until another `render` is triggered.\n         * @param {Chart} chart - The chart instance.\n         * @param {Object} args - The call arguments.\n         * @param {Object} args.index - The dataset index.\n         * @param {Number} args.meta - The dataset metadata.\n         * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n         * @param {Object} options - The plugin options.\n         * @returns {Boolean} `false` to cancel the chart datasets drawing.\n         */\n        /**\n         * @method IPlugin#afterDatasetDraw\n         * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n         * (datasets are drawn in the reverse order). Note that this hook will not be called\n         * if the datasets drawing has been previously cancelled.\n         * @param {Chart} chart - The chart instance.\n         * @param {Object} args - The call arguments.\n         * @param {Object} args.index - The dataset index.\n         * @param {Number} args.meta - The dataset metadata.\n         * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#beforeEvent\n         * @desc Called before processing the specified `event`. If any plugin returns `false`,\n         * the event will be discarded.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {IEvent} event - The event object.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#afterEvent\n         * @desc Called after the `event` has been consumed. Note that this hook\n         * will not be called if the `event` has been previously discarded.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {IEvent} event - The event object.\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#resize\n         * @desc Called after the chart as been resized.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Number} size - The new canvas display size (eq. canvas.style width  height).\n         * @param {Object} options - The plugin options.\n         */\n        /**\n         * @method IPlugin#destroy\n         * @desc Called after the chart as been destroyed.\n         * @param {Chart.Controller} chart - The chart instance.\n         * @param {Object} options - The plugin options.\n         */\n        \n        /**\n         * Provided for backward compatibility, use Chart.plugins instead\n         * @namespace Chart.pluginService\n         * @deprecated since version 2.1.5\n         * @todo remove at version 3\n         * @private\n         */\n        Chart.pluginService = Chart.plugins;\n        \n        /**\n         * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n         * effect, instead simply create/register plugins via plain JavaScript objects.\n         * @interface Chart.PluginBase\n         * @deprecated since version 2.5.0\n         * @todo remove at version 3\n         * @private\n         */\n        Chart.PluginBase = Chart.Element.extend({});\n    };\n    \n},{}],25:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.defaults.scale = {\n            display: true,\n            position: 'left',\n            \n            // grid line settings\n            gridLines: {\n                display: true,\n                color: 'rgba(0, 0, 0, 0.1)',\n                lineWidth: 1,\n                drawBorder: true,\n                drawOnChartArea: true,\n                drawTicks: true,\n                tickMarkLength: 10,\n                zeroLineWidth: 1,\n                zeroLineColor: 'rgba(0,0,0,0.25)',\n                zeroLineBorderDash: [],\n                zeroLineBorderDashOffset: 0.0,\n                offsetGridLines: false,\n                borderDash: [],\n                borderDashOffset: 0.0\n            },\n            \n            // scale label\n            scaleLabel: {\n                // actual label\n                labelString: '',\n                \n                // display property\n                display: false\n            },\n            \n            // label settings\n            ticks: {\n                beginAtZero: false,\n                minRotation: 0,\n                maxRotation: 50,\n                mirror: false,\n                padding: 0,\n                reverse: false,\n                display: true,\n                autoSkip: true,\n                autoSkipPadding: 0,\n                labelOffset: 0,\n                // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n                callback: Chart.Ticks.formatters.values\n            }\n        };\n        \n        function computeTextSize(context, tick, font) {\n            return helpers.isArray(tick) ?\n                helpers.longestText(context, font, tick) :\n                context.measureText(tick).width;\n        }\n        \n        function parseFontOptions(options) {\n            var getValueOrDefault = helpers.getValueOrDefault;\n            var globalDefaults = Chart.defaults.global;\n            var size = getValueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n            var style = getValueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n            var family = getValueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n            \n            return {\n                size: size,\n                style: style,\n                family: family,\n                font: helpers.fontString(size, style, family)\n            };\n        }\n        \n        Chart.Scale = Chart.Element.extend({\n            /**\n             * Get the padding needed for the scale\n             * @method getPadding\n             * @private\n             * @returns {Padding} the necessary padding\n             */\n            getPadding: function() {\n                var me = this;\n                return {\n                    left: me.paddingLeft || 0,\n                    top: me.paddingTop || 0,\n                    right: me.paddingRight || 0,\n                    bottom: me.paddingBottom || 0\n                };\n            },\n            \n            // These methods are ordered by lifecyle. Utilities then follow.\n            // Any function defined here is inherited by all scale types.\n            // Any function can be extended by the scale type\n            \n            beforeUpdate: function() {\n                helpers.callback(this.options.beforeUpdate, [this]);\n            },\n            update: function(maxWidth, maxHeight, margins) {\n                var me = this;\n                \n                // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n                me.beforeUpdate();\n                \n                // Absorb the master measurements\n                me.maxWidth = maxWidth;\n                me.maxHeight = maxHeight;\n                me.margins = helpers.extend({\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    bottom: 0\n                }, margins);\n                me.longestTextCache = me.longestTextCache || {};\n                \n                // Dimensions\n                me.beforeSetDimensions();\n                me.setDimensions();\n                me.afterSetDimensions();\n                \n                // Data min/max\n                me.beforeDataLimits();\n                me.determineDataLimits();\n                me.afterDataLimits();\n                \n                // Ticks\n                me.beforeBuildTicks();\n                me.buildTicks();\n                me.afterBuildTicks();\n                \n                me.beforeTickToLabelConversion();\n                me.convertTicksToLabels();\n                me.afterTickToLabelConversion();\n                \n                // Tick Rotation\n                me.beforeCalculateTickRotation();\n                me.calculateTickRotation();\n                me.afterCalculateTickRotation();\n                // Fit\n                me.beforeFit();\n                me.fit();\n                me.afterFit();\n                //\n                me.afterUpdate();\n                \n                return me.minSize;\n                \n            },\n            afterUpdate: function() {\n                helpers.callback(this.options.afterUpdate, [this]);\n            },\n            \n            //\n            \n            beforeSetDimensions: function() {\n                helpers.callback(this.options.beforeSetDimensions, [this]);\n            },\n            setDimensions: function() {\n                var me = this;\n                // Set the unconstrained dimension before label rotation\n                if (me.isHorizontal()) {\n                    // Reset position before calculating rotation\n                    me.width = me.maxWidth;\n                    me.left = 0;\n                    me.right = me.width;\n                } else {\n                    me.height = me.maxHeight;\n                    \n                    // Reset position before calculating rotation\n                    me.top = 0;\n                    me.bottom = me.height;\n                }\n                \n                // Reset padding\n                me.paddingLeft = 0;\n                me.paddingTop = 0;\n                me.paddingRight = 0;\n                me.paddingBottom = 0;\n            },\n            afterSetDimensions: function() {\n                helpers.callback(this.options.afterSetDimensions, [this]);\n            },\n            \n            // Data limits\n            beforeDataLimits: function() {\n                helpers.callback(this.options.beforeDataLimits, [this]);\n            },\n            determineDataLimits: helpers.noop,\n            afterDataLimits: function() {\n                helpers.callback(this.options.afterDataLimits, [this]);\n            },\n            \n            //\n            beforeBuildTicks: function() {\n                helpers.callback(this.options.beforeBuildTicks, [this]);\n            },\n            buildTicks: helpers.noop,\n            afterBuildTicks: function() {\n                helpers.callback(this.options.afterBuildTicks, [this]);\n            },\n            \n            beforeTickToLabelConversion: function() {\n                helpers.callback(this.options.beforeTickToLabelConversion, [this]);\n            },\n            convertTicksToLabels: function() {\n                var me = this;\n                // Convert ticks to strings\n                var tickOpts = me.options.ticks;\n                me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback);\n            },\n            afterTickToLabelConversion: function() {\n                helpers.callback(this.options.afterTickToLabelConversion, [this]);\n            },\n            \n            //\n            \n            beforeCalculateTickRotation: function() {\n                helpers.callback(this.options.beforeCalculateTickRotation, [this]);\n            },\n            calculateTickRotation: function() {\n                var me = this;\n                var context = me.ctx;\n                var tickOpts = me.options.ticks;\n                \n                // Get the width of each grid by calculating the difference\n                // between x offsets between 0 and 1.\n                var tickFont = parseFontOptions(tickOpts);\n                context.font = tickFont.font;\n                \n                var labelRotation = tickOpts.minRotation || 0;\n                \n                if (me.options.display && me.isHorizontal()) {\n                    var originalLabelWidth = helpers.longestText(context, tickFont.font, me.ticks, me.longestTextCache);\n                    var labelWidth = originalLabelWidth;\n                    var cosRotation;\n                    var sinRotation;\n                    \n                    // Allow 3 pixels x2 padding either side for label readability\n                    var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n                    \n                    // Max label rotation can be set or default to 90 - also act as a loop counter\n                    while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n                        var angleRadians = helpers.toRadians(labelRotation);\n                        cosRotation = Math.cos(angleRadians);\n                        sinRotation = Math.sin(angleRadians);\n                        \n                        if (sinRotation * originalLabelWidth > me.maxHeight) {\n                            // go back one step\n                            labelRotation--;\n                            break;\n                        }\n                        \n                        labelRotation++;\n                        labelWidth = cosRotation * originalLabelWidth;\n                    }\n                }\n                \n                me.labelRotation = labelRotation;\n            },\n            afterCalculateTickRotation: function() {\n                helpers.callback(this.options.afterCalculateTickRotation, [this]);\n            },\n            \n            //\n            \n            beforeFit: function() {\n                helpers.callback(this.options.beforeFit, [this]);\n            },\n            fit: function() {\n                var me = this;\n                // Reset\n                var minSize = me.minSize = {\n                    width: 0,\n                    height: 0\n                };\n                \n                var opts = me.options;\n                var tickOpts = opts.ticks;\n                var scaleLabelOpts = opts.scaleLabel;\n                var gridLineOpts = opts.gridLines;\n                var display = opts.display;\n                var isHorizontal = me.isHorizontal();\n                \n                var tickFont = parseFontOptions(tickOpts);\n                var scaleLabelFontSize = parseFontOptions(scaleLabelOpts).size * 1.5;\n                var tickMarkLength = opts.gridLines.tickMarkLength;\n                \n                // Width\n                if (isHorizontal) {\n                    // subtract the margins to line up with the chartArea if we are a full width scale\n                    minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n                } else {\n                    minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n                }\n                \n                // height\n                if (isHorizontal) {\n                    minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n                } else {\n                    minSize.height = me.maxHeight; // fill all the height\n                }\n                \n                // Are we showing a title for the scale?\n                if (scaleLabelOpts.display && display) {\n                    if (isHorizontal) {\n                        minSize.height += scaleLabelFontSize;\n                    } else {\n                        minSize.width += scaleLabelFontSize;\n                    }\n                }\n                \n                // Don't bother fitting the ticks if we are not showing them\n                if (tickOpts.display && display) {\n                    var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, me.ticks, me.longestTextCache);\n                    var tallestLabelHeightInLines = helpers.numberOfLabelLines(me.ticks);\n                    var lineSpace = tickFont.size * 0.5;\n                    \n                    if (isHorizontal) {\n                        // A horizontal axis is more constrained by the height.\n                        me.longestLabelWidth = largestTextWidth;\n                        \n                        var angleRadians = helpers.toRadians(me.labelRotation);\n                        var cosRotation = Math.cos(angleRadians);\n                        var sinRotation = Math.sin(angleRadians);\n                        \n                        // TODO - improve this calculation\n                        var labelHeight = (sinRotation * largestTextWidth)\n                            + (tickFont.size * tallestLabelHeightInLines)\n                            + (lineSpace * tallestLabelHeightInLines);\n                        \n                        minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight);\n                        me.ctx.font = tickFont.font;\n                        \n                        var firstTick = me.ticks[0];\n                        var firstLabelWidth = computeTextSize(me.ctx, firstTick, tickFont.font);\n                        \n                        var lastTick = me.ticks[me.ticks.length - 1];\n                        var lastLabelWidth = computeTextSize(me.ctx, lastTick, tickFont.font);\n                        \n                        // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned which means that the right padding is dominated\n                        // by the font height\n                        if (me.labelRotation !== 0) {\n                            me.paddingLeft = opts.position === 'bottom'? (cosRotation * firstLabelWidth) + 3: (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n                            me.paddingRight = opts.position === 'bottom'? (cosRotation * lineSpace) + 3: (cosRotation * lastLabelWidth) + 3;\n                        } else {\n                            me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n                            me.paddingRight = lastLabelWidth / 2 + 3;\n                        }\n                    } else {\n                        // A vertical axis is more constrained by the width. Labels are the dominant factor here, so get that length first\n                        // Account for padding\n                        \n                        if (tickOpts.mirror) {\n                            largestTextWidth = 0;\n                        } else {\n                            largestTextWidth += me.options.ticks.padding;\n                        }\n                        minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n                        me.paddingTop = tickFont.size / 2;\n                        me.paddingBottom = tickFont.size / 2;\n                    }\n                }\n                \n                me.handleMargins();\n                \n                me.width = minSize.width;\n                me.height = minSize.height;\n            },\n            \n            /**\n             * Handle margins and padding interactions\n             * @private\n             */\n            handleMargins: function() {\n                var me = this;\n                if (me.margins) {\n                    me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n                    me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n                    me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n                    me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n                }\n            },\n            \n            afterFit: function() {\n                helpers.callback(this.options.afterFit, [this]);\n            },\n            \n            // Shared Methods\n            isHorizontal: function() {\n                return this.options.position === 'top' || this.options.position === 'bottom';\n            },\n            isFullWidth: function() {\n                return (this.options.fullWidth);\n            },\n            \n            // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n            getRightValue: function(rawValue) {\n                // Null and undefined values first\n                if (rawValue === null || typeof(rawValue) === 'undefined') {\n                    return NaN;\n                }\n                // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n                if (typeof(rawValue) === 'number' && !isFinite(rawValue)) {\n                    return NaN;\n                }\n                // If it is in fact an object, dive in one more level\n                if (typeof(rawValue) === 'object') {\n                    if ((rawValue instanceof Date) || (rawValue.isValid)) {\n                        return rawValue;\n                    }\n                    return this.getRightValue(this.isHorizontal() ? rawValue.x : rawValue.y);\n                }\n                \n                // Value is good, return it\n                return rawValue;\n            },\n            \n            // Used to get the value to display in the tooltip for the data at the given index\n            // function getLabelForIndex(index, datasetIndex)\n            getLabelForIndex: helpers.noop,\n            \n            // Used to get data value locations.  Value can either be an index or a numerical value\n            getPixelForValue: helpers.noop,\n            \n            // Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n            getValueForPixel: helpers.noop,\n            \n            // Used for tick location, should\n            getPixelForTick: function(index, includeOffset) {\n                var me = this;\n                if (me.isHorizontal()) {\n                    var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n                    var tickWidth = innerWidth / Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n                    var pixel = (tickWidth * index) + me.paddingLeft;\n                    \n                    if (includeOffset) {\n                        pixel += tickWidth / 2;\n                    }\n                    \n                    var finalVal = me.left + Math.round(pixel);\n                    finalVal += me.isFullWidth() ? me.margins.left : 0;\n                    return finalVal;\n                }\n                var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n                return me.top + (index * (innerHeight / (me.ticks.length - 1)));\n            },\n            \n            // Utility for getting the pixel location of a percentage of scale\n            getPixelForDecimal: function(decimal /* , includeOffset*/) {\n                var me = this;\n                if (me.isHorizontal()) {\n                    var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n                    var valueOffset = (innerWidth * decimal) + me.paddingLeft;\n                    \n                    var finalVal = me.left + Math.round(valueOffset);\n                    finalVal += me.isFullWidth() ? me.margins.left : 0;\n                    return finalVal;\n                }\n                return me.top + (decimal * me.height);\n            },\n            \n            getBasePixel: function() {\n                return this.getPixelForValue(this.getBaseValue());\n            },\n            \n            getBaseValue: function() {\n                var me = this;\n                var min = me.min;\n                var max = me.max;\n                \n                return me.beginAtZero ? 0:\n                    min < 0 && max < 0? max :\n                        min > 0 && max > 0? min :\n                            0;\n            },\n            \n            // Actually draw the scale on the canvas\n            // @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n            draw: function(chartArea) {\n                var me = this;\n                var options = me.options;\n                if (!options.display) {\n                    return;\n                }\n                \n                var context = me.ctx;\n                var globalDefaults = Chart.defaults.global;\n                var optionTicks = options.ticks;\n                var gridLines = options.gridLines;\n                var scaleLabel = options.scaleLabel;\n                \n                var isRotated = me.labelRotation !== 0;\n                var skipRatio;\n                var useAutoskipper = optionTicks.autoSkip;\n                var isHorizontal = me.isHorizontal();\n                \n                // figure out the maximum number of gridlines to show\n                var maxTicks;\n                if (optionTicks.maxTicksLimit) {\n                    maxTicks = optionTicks.maxTicksLimit;\n                }\n                \n                var tickFontColor = helpers.getValueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n                var tickFont = parseFontOptions(optionTicks);\n                \n                var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n                \n                var scaleLabelFontColor = helpers.getValueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n                var scaleLabelFont = parseFontOptions(scaleLabel);\n                \n                var labelRotationRadians = helpers.toRadians(me.labelRotation);\n                var cosRotation = Math.cos(labelRotationRadians);\n                var longestRotatedLabel = me.longestLabelWidth * cosRotation;\n                \n                // Make sure we draw text in the correct color and font\n                context.fillStyle = tickFontColor;\n                \n                var itemsToDraw = [];\n                \n                if (isHorizontal) {\n                    skipRatio = false;\n                    \n                    if ((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length > (me.width - (me.paddingLeft + me.paddingRight))) {\n                        skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * me.ticks.length) / (me.width - (me.paddingLeft + me.paddingRight)));\n                    }\n                    \n                    // if they defined a max number of optionTicks,\n                    // increase skipRatio until that number is met\n                    if (maxTicks && me.ticks.length > maxTicks) {\n                        while (!skipRatio || me.ticks.length / (skipRatio || 1) > maxTicks) {\n                            if (!skipRatio) {\n                                skipRatio = 1;\n                            }\n                            skipRatio += 1;\n                        }\n                    }\n                    \n                    if (!useAutoskipper) {\n                        skipRatio = false;\n                    }\n                }\n                \n                \n                var xTickStart = options.position === 'right' ? me.left : me.right - tl;\n                var xTickEnd = options.position === 'right' ? me.left + tl : me.right;\n                var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;\n                var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;\n                \n                helpers.each(me.ticks, function(label, index) {\n                    // If the callback returned a null or undefined value, do not draw this line\n                    if (label === undefined || label === null) {\n                        return;\n                    }\n                    \n                    var isLastTick = me.ticks.length === index + 1;\n                    \n                    // Since we always show the last tick,we need may need to hide the last shown one before\n                    var shouldSkip = (skipRatio > 1 && index % skipRatio > 0) || (index % skipRatio === 0 && index + skipRatio >= me.ticks.length);\n                    if (shouldSkip && !isLastTick || (label === undefined || label === null)) {\n                        return;\n                    }\n                    \n                    var lineWidth, lineColor, borderDash, borderDashOffset;\n                    if (index === (typeof me.zeroLineIndex !== 'undefined' ? me.zeroLineIndex : 0)) {\n                        // Draw the first index specially\n                        lineWidth = gridLines.zeroLineWidth;\n                        lineColor = gridLines.zeroLineColor;\n                        borderDash = gridLines.zeroLineBorderDash;\n                        borderDashOffset = gridLines.zeroLineBorderDashOffset;\n                    } else {\n                        lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, index);\n                        lineColor = helpers.getValueAtIndexOrDefault(gridLines.color, index);\n                        borderDash = helpers.getValueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n                        borderDashOffset = helpers.getValueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n                    }\n                    \n                    // Common properties\n                    var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n                    var textAlign = 'middle';\n                    var textBaseline = 'middle';\n                    \n                    if (isHorizontal) {\n                        \n                        if (options.position === 'bottom') {\n                            // bottom\n                            textBaseline = !isRotated? 'top':'middle';\n                            textAlign = !isRotated? 'center': 'right';\n                            labelY = me.top + tl;\n                        } else {\n                            // top\n                            textBaseline = !isRotated? 'bottom':'middle';\n                            textAlign = !isRotated? 'center': 'left';\n                            labelY = me.bottom - tl;\n                        }\n                        \n                        var xLineValue = me.getPixelForTick(index) + helpers.aliasPixel(lineWidth); // xvalues for grid lines\n                        labelX = me.getPixelForTick(index, gridLines.offsetGridLines) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n                        \n                        tx1 = tx2 = x1 = x2 = xLineValue;\n                        ty1 = yTickStart;\n                        ty2 = yTickEnd;\n                        y1 = chartArea.top;\n                        y2 = chartArea.bottom;\n                    } else {\n                        var isLeft = options.position === 'left';\n                        var tickPadding = optionTicks.padding;\n                        var labelXOffset;\n                        \n                        if (optionTicks.mirror) {\n                            textAlign = isLeft ? 'left' : 'right';\n                            labelXOffset = tickPadding;\n                        } else {\n                            textAlign = isLeft ? 'right' : 'left';\n                            labelXOffset = tl + tickPadding;\n                        }\n                        \n                        labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n                        \n                        var yLineValue = me.getPixelForTick(index); // xvalues for grid lines\n                        yLineValue += helpers.aliasPixel(lineWidth);\n                        labelY = me.getPixelForTick(index, gridLines.offsetGridLines);\n                        \n                        tx1 = xTickStart;\n                        tx2 = xTickEnd;\n                        x1 = chartArea.left;\n                        x2 = chartArea.right;\n                        ty1 = ty2 = y1 = y2 = yLineValue;\n                    }\n                    \n                    itemsToDraw.push({\n                        tx1: tx1,\n                        ty1: ty1,\n                        tx2: tx2,\n                        ty2: ty2,\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2,\n                        labelX: labelX,\n                        labelY: labelY,\n                        glWidth: lineWidth,\n                        glColor: lineColor,\n                        glBorderDash: borderDash,\n                        glBorderDashOffset: borderDashOffset,\n                        rotation: -1 * labelRotationRadians,\n                        label: label,\n                        textBaseline: textBaseline,\n                        textAlign: textAlign\n                    });\n                });\n                \n                // Draw all of the tick labels, tick marks, and grid lines at the correct places\n                helpers.each(itemsToDraw, function(itemToDraw) {\n                    if (gridLines.display) {\n                        context.save();\n                        context.lineWidth = itemToDraw.glWidth;\n                        context.strokeStyle = itemToDraw.glColor;\n                        if (context.setLineDash) {\n                            context.setLineDash(itemToDraw.glBorderDash);\n                            context.lineDashOffset = itemToDraw.glBorderDashOffset;\n                        }\n                        \n                        context.beginPath();\n                        \n                        if (gridLines.drawTicks) {\n                            context.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n                            context.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n                        }\n                        \n                        if (gridLines.drawOnChartArea) {\n                            context.moveTo(itemToDraw.x1, itemToDraw.y1);\n                            context.lineTo(itemToDraw.x2, itemToDraw.y2);\n                        }\n                        \n                        context.stroke();\n                        context.restore();\n                    }\n                    \n                    if (optionTicks.display) {\n                        context.save();\n                        context.translate(itemToDraw.labelX, itemToDraw.labelY);\n                        context.rotate(itemToDraw.rotation);\n                        context.font = tickFont.font;\n                        context.textBaseline = itemToDraw.textBaseline;\n                        context.textAlign = itemToDraw.textAlign;\n                        \n                        var label = itemToDraw.label;\n                        if (helpers.isArray(label)) {\n                            for (var i = 0, y = 0; i < label.length; ++i) {\n                                // We just make sure the multiline element is a string here..\n                                context.fillText('' + label[i], 0, y);\n                                // apply same lineSpacing as calculated @ L#320\n                                y += (tickFont.size * 1.5);\n                            }\n                        } else {\n                            context.fillText(label, 0, 0);\n                        }\n                        context.restore();\n                    }\n                });\n                \n                if (scaleLabel.display) {\n                    // Draw the scale label\n                    var scaleLabelX;\n                    var scaleLabelY;\n                    var rotation = 0;\n                    \n                    if (isHorizontal) {\n                        scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n                        scaleLabelY = options.position === 'bottom' ? me.bottom - (scaleLabelFont.size / 2) : me.top + (scaleLabelFont.size / 2);\n                    } else {\n                        var isLeft = options.position === 'left';\n                        scaleLabelX = isLeft ? me.left + (scaleLabelFont.size / 2) : me.right - (scaleLabelFont.size / 2);\n                        scaleLabelY = me.top + ((me.bottom - me.top) / 2);\n                        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n                    }\n                    \n                    context.save();\n                    context.translate(scaleLabelX, scaleLabelY);\n                    context.rotate(rotation);\n                    context.textAlign = 'center';\n                    context.textBaseline = 'middle';\n                    context.fillStyle = scaleLabelFontColor; // render in correct colour\n                    context.font = scaleLabelFont.font;\n                    context.fillText(scaleLabel.labelString, 0, 0);\n                    context.restore();\n                }\n                \n                if (gridLines.drawBorder) {\n                    // Draw the line at the edge of the axis\n                    context.lineWidth = helpers.getValueAtIndexOrDefault(gridLines.lineWidth, 0);\n                    context.strokeStyle = helpers.getValueAtIndexOrDefault(gridLines.color, 0);\n                    var x1 = me.left,\n                        x2 = me.right,\n                        y1 = me.top,\n                        y2 = me.bottom;\n                    \n                    var aliasPixel = helpers.aliasPixel(context.lineWidth);\n                    if (isHorizontal) {\n                        y1 = y2 = options.position === 'top' ? me.bottom : me.top;\n                        y1 += aliasPixel;\n                        y2 += aliasPixel;\n                    } else {\n                        x1 = x2 = options.position === 'left' ? me.right : me.left;\n                        x1 += aliasPixel;\n                        x2 += aliasPixel;\n                    }\n                    \n                    context.beginPath();\n                    context.moveTo(x1, y1);\n                    context.lineTo(x2, y2);\n                    context.stroke();\n                }\n            }\n        });\n    };\n    \n},{}],26:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        Chart.scaleService = {\n            // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n            // use the new chart options to grab the correct scale\n            constructors: {},\n            // Use a registration function so that we can move to an ES6 map when we no longer need to support\n            // old browsers\n            \n            // Scale config defaults\n            defaults: {},\n            registerScaleType: function(type, scaleConstructor, defaults) {\n                this.constructors[type] = scaleConstructor;\n                this.defaults[type] = helpers.clone(defaults);\n            },\n            getScaleConstructor: function(type) {\n                return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n            },\n            getScaleDefaults: function(type) {\n                // Return the scale defaults merged with the global settings so that we always use the latest ones\n                return this.defaults.hasOwnProperty(type) ? helpers.scaleMerge(Chart.defaults.scale, this.defaults[type]) : {};\n            },\n            updateScaleDefaults: function(type, additions) {\n                var defaults = this.defaults;\n                if (defaults.hasOwnProperty(type)) {\n                    defaults[type] = helpers.extend(defaults[type], additions);\n                }\n            },\n            addScalesToLayout: function(chart) {\n                // Adds each scale to the chart.boxes array to be sized accordingly\n                helpers.each(chart.scales, function(scale) {\n                    // Set ILayoutItem parameters for backwards compatibility\n                    scale.fullWidth = scale.options.fullWidth;\n                    scale.position = scale.options.position;\n                    scale.weight = scale.options.weight;\n                    Chart.layoutService.addBox(chart, scale);\n                });\n            }\n        };\n    };\n    \n},{}],27:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        /**\n         * Namespace to hold static tick generation functions\n         * @namespace Chart.Ticks\n         */\n        Chart.Ticks = {\n            /**\n             * Namespace to hold generators for different types of ticks\n             * @namespace Chart.Ticks.generators\n             */\n            generators: {\n                /**\n                 * Interface for the options provided to the numeric tick generator\n                 * @interface INumericTickGenerationOptions\n                 */\n                /**\n                 * The maximum number of ticks to display\n                 * @name INumericTickGenerationOptions#maxTicks\n                 * @type Number\n                 */\n                /**\n                 * The distance between each tick.\n                 * @name INumericTickGenerationOptions#stepSize\n                 * @type Number\n                 * @optional\n                 */\n                /**\n                 * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n                 * @name INumericTickGenerationOptions#min\n                 * @type Number\n                 * @optional\n                 */\n                /**\n                 * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n                 * @name INumericTickGenerationOptions#max\n                 * @type Number\n                 * @optional\n                 */\n                \n                /**\n                 * Generate a set of linear ticks\n                 * @method Chart.Ticks.generators.linear\n                 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n                 * @param dataRange {IRange} the range of the data\n                 * @returns {Array<Number>} array of tick values\n                 */\n                linear: function(generationOptions, dataRange) {\n                    var ticks = [];\n                    // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n                    // \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n                    // for details.\n                    \n                    var spacing;\n                    if (generationOptions.stepSize && generationOptions.stepSize > 0) {\n                        spacing = generationOptions.stepSize;\n                    } else {\n                        var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n                        spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n                    }\n                    var niceMin = Math.floor(dataRange.min / spacing) * spacing;\n                    var niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n                    \n                    // If min, max and stepSize is set and they make an evenly spaced scale use it.\n                    if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n                        // If very close to our whole number, use it.\n                        if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n                            niceMin = generationOptions.min;\n                            niceMax = generationOptions.max;\n                        }\n                    }\n                    \n                    var numSpaces = (niceMax - niceMin) / spacing;\n                    // If very close to our rounded value, use it.\n                    if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n                        numSpaces = Math.round(numSpaces);\n                    } else {\n                        numSpaces = Math.ceil(numSpaces);\n                    }\n                    \n                    // Put the values into the ticks array\n                    ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n                    for (var j = 1; j < numSpaces; ++j) {\n                        ticks.push(niceMin + (j * spacing));\n                    }\n                    ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n                    \n                    return ticks;\n                },\n                \n                /**\n                 * Generate a set of logarithmic ticks\n                 * @method Chart.Ticks.generators.logarithmic\n                 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n                 * @param dataRange {IRange} the range of the data\n                 * @returns {Array<Number>} array of tick values\n                 */\n                logarithmic: function(generationOptions, dataRange) {\n                    var ticks = [];\n                    var getValueOrDefault = helpers.getValueOrDefault;\n                    \n                    // Figure out what the max number of ticks we can support it is based on the size of\n                    // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n                    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n                    // the graph\n                    var tickVal = getValueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n                    \n                    var endExp = Math.floor(helpers.log10(dataRange.max));\n                    var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n                    var exp;\n                    var significand;\n                    \n                    if (tickVal === 0) {\n                        exp = Math.floor(helpers.log10(dataRange.minNotZero));\n                        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n                        \n                        ticks.push(tickVal);\n                        tickVal = significand * Math.pow(10, exp);\n                    } else {\n                        exp = Math.floor(helpers.log10(tickVal));\n                        significand = Math.floor(tickVal / Math.pow(10, exp));\n                    }\n                    \n                    do {\n                        ticks.push(tickVal);\n                        \n                        ++significand;\n                        if (significand === 10) {\n                            significand = 1;\n                            ++exp;\n                        }\n                        \n                        tickVal = significand * Math.pow(10, exp);\n                    } while (exp < endExp || (exp === endExp && significand < endSignificand));\n                    \n                    var lastTick = getValueOrDefault(generationOptions.max, tickVal);\n                    ticks.push(lastTick);\n                    \n                    return ticks;\n                }\n            },\n            \n            /**\n             * Namespace to hold formatters for different types of ticks\n             * @namespace Chart.Ticks.formatters\n             */\n            formatters: {\n                /**\n                 * Formatter for value labels\n                 * @method Chart.Ticks.formatters.values\n                 * @param value the value to display\n                 * @return {String|Array} the label to display\n                 */\n                values: function(value) {\n                    return helpers.isArray(value) ? value : '' + value;\n                },\n                \n                /**\n                 * Formatter for linear numeric ticks\n                 * @method Chart.Ticks.formatters.linear\n                 * @param tickValue {Number} the value to be formatted\n                 * @param index {Number} the position of the tickValue parameter in the ticks array\n                 * @param ticks {Array<Number>} the list of ticks being converted\n                 * @return {String} string representation of the tickValue parameter\n                 */\n                linear: function(tickValue, index, ticks) {\n                    // If we have lots of ticks, don't use the ones\n                    var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n                    \n                    // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n                    if (Math.abs(delta) > 1) {\n                        if (tickValue !== Math.floor(tickValue)) {\n                            // not an integer\n                            delta = tickValue - Math.floor(tickValue);\n                        }\n                    }\n                    \n                    var logDelta = helpers.log10(Math.abs(delta));\n                    var tickString = '';\n                    \n                    if (tickValue !== 0) {\n                        var numDecimal = -1 * Math.floor(logDelta);\n                        numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n                        tickString = tickValue.toFixed(numDecimal);\n                    } else {\n                        tickString = '0'; // never show decimal places for 0\n                    }\n                    \n                    return tickString;\n                },\n                \n                logarithmic: function(tickValue, index, ticks) {\n                    var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n                    \n                    if (tickValue === 0) {\n                        return '0';\n                    } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n                        return tickValue.toExponential();\n                    }\n                    return '';\n                }\n            }\n        };\n    };\n    \n},{}],28:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        /**\n         * Helper method to merge the opacity into a color\n         */\n        function mergeOpacity(colorString, opacity) {\n            var color = helpers.color(colorString);\n            return color.alpha(opacity * color.alpha()).rgbaString();\n        }\n        \n        Chart.defaults.global.tooltips = {\n            enabled: true,\n            custom: null,\n            mode: 'nearest',\n            position: 'average',\n            intersect: true,\n            backgroundColor: 'rgba(0,0,0,0.8)',\n            titleFontStyle: 'bold',\n            titleSpacing: 2,\n            titleMarginBottom: 6,\n            titleFontColor: '#fff',\n            titleAlign: 'left',\n            bodySpacing: 2,\n            bodyFontColor: '#fff',\n            bodyAlign: 'left',\n            footerFontStyle: 'bold',\n            footerSpacing: 2,\n            footerMarginTop: 6,\n            footerFontColor: '#fff',\n            footerAlign: 'left',\n            yPadding: 6,\n            xPadding: 6,\n            caretPadding: 2,\n            caretSize: 5,\n            cornerRadius: 6,\n            multiKeyBackground: '#fff',\n            displayColors: true,\n            borderColor: 'rgba(0,0,0,0)',\n            borderWidth: 0,\n            callbacks: {\n                // Args are: (tooltipItems, data)\n                beforeTitle: helpers.noop,\n                title: function(tooltipItems, data) {\n                    // Pick first xLabel for now\n                    var title = '';\n                    var labels = data.labels;\n                    var labelCount = labels ? labels.length : 0;\n                    \n                    if (tooltipItems.length > 0) {\n                        var item = tooltipItems[0];\n                        \n                        if (item.xLabel) {\n                            title = item.xLabel;\n                        } else if (labelCount > 0 && item.index < labelCount) {\n                            title = labels[item.index];\n                        }\n                    }\n                    \n                    return title;\n                },\n                afterTitle: helpers.noop,\n                \n                // Args are: (tooltipItems, data)\n                beforeBody: helpers.noop,\n                \n                // Args are: (tooltipItem, data)\n                beforeLabel: helpers.noop,\n                label: function(tooltipItem, data) {\n                    var label = data.datasets[tooltipItem.datasetIndex].label || '';\n                    \n                    if (label) {\n                        label += ': ';\n                    }\n                    label += tooltipItem.yLabel;\n                    return label;\n                },\n                labelColor: function(tooltipItem, chart) {\n                    var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n                    var activeElement = meta.data[tooltipItem.index];\n                    var view = activeElement._view;\n                    return {\n                        borderColor: view.borderColor,\n                        backgroundColor: view.backgroundColor\n                    };\n                },\n                afterLabel: helpers.noop,\n                \n                // Args are: (tooltipItems, data)\n                afterBody: helpers.noop,\n                \n                // Args are: (tooltipItems, data)\n                beforeFooter: helpers.noop,\n                footer: helpers.noop,\n                afterFooter: helpers.noop\n            }\n        };\n        \n        // Helper to push or concat based on if the 2nd parameter is an array or not\n        function pushOrConcat(base, toPush) {\n            if (toPush) {\n                if (helpers.isArray(toPush)) {\n                    // base = base.concat(toPush);\n                    Array.prototype.push.apply(base, toPush);\n                } else {\n                    base.push(toPush);\n                }\n            }\n            \n            return base;\n        }\n        \n        // Private helper to create a tooltip item model\n        // @param element : the chart element (point, arc, bar) to create the tooltip item for\n        // @return : new tooltip item\n        function createTooltipItem(element) {\n            var xScale = element._xScale;\n            var yScale = element._yScale || element._scale; // handle radar || polarArea charts\n            var index = element._index,\n                datasetIndex = element._datasetIndex;\n            \n            return {\n                xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n                yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n                index: index,\n                datasetIndex: datasetIndex,\n                x: element._model.x,\n                y: element._model.y\n            };\n        }\n        \n        /**\n         * Helper to get the reset model for the tooltip\n         * @param tooltipOpts {Object} the tooltip options\n         */\n        function getBaseModel(tooltipOpts) {\n            var globalDefaults = Chart.defaults.global;\n            var getValueOrDefault = helpers.getValueOrDefault;\n            \n            return {\n                // Positioning\n                xPadding: tooltipOpts.xPadding,\n                yPadding: tooltipOpts.yPadding,\n                xAlign: tooltipOpts.xAlign,\n                yAlign: tooltipOpts.yAlign,\n                \n                // Body\n                bodyFontColor: tooltipOpts.bodyFontColor,\n                _bodyFontFamily: getValueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n                _bodyFontStyle: getValueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n                _bodyAlign: tooltipOpts.bodyAlign,\n                bodyFontSize: getValueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n                bodySpacing: tooltipOpts.bodySpacing,\n                \n                // Title\n                titleFontColor: tooltipOpts.titleFontColor,\n                _titleFontFamily: getValueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n                _titleFontStyle: getValueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n                titleFontSize: getValueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n                _titleAlign: tooltipOpts.titleAlign,\n                titleSpacing: tooltipOpts.titleSpacing,\n                titleMarginBottom: tooltipOpts.titleMarginBottom,\n                \n                // Footer\n                footerFontColor: tooltipOpts.footerFontColor,\n                _footerFontFamily: getValueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n                _footerFontStyle: getValueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n                footerFontSize: getValueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n                _footerAlign: tooltipOpts.footerAlign,\n                footerSpacing: tooltipOpts.footerSpacing,\n                footerMarginTop: tooltipOpts.footerMarginTop,\n                \n                // Appearance\n                caretSize: tooltipOpts.caretSize,\n                cornerRadius: tooltipOpts.cornerRadius,\n                backgroundColor: tooltipOpts.backgroundColor,\n                opacity: 0,\n                legendColorBackground: tooltipOpts.multiKeyBackground,\n                displayColors: tooltipOpts.displayColors,\n                borderColor: tooltipOpts.borderColor,\n                borderWidth: tooltipOpts.borderWidth\n            };\n        }\n        \n        /**\n         * Get the size of the tooltip\n         */\n        function getTooltipSize(tooltip, model) {\n            var ctx = tooltip._chart.ctx;\n            \n            var height = model.yPadding * 2; // Tooltip Padding\n            var width = 0;\n            \n            // Count of all lines in the body\n            var body = model.body;\n            var combinedBodyLength = body.reduce(function(count, bodyItem) {\n                return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n            }, 0);\n            combinedBodyLength += model.beforeBody.length + model.afterBody.length;\n            \n            var titleLineCount = model.title.length;\n            var footerLineCount = model.footer.length;\n            var titleFontSize = model.titleFontSize,\n                bodyFontSize = model.bodyFontSize,\n                footerFontSize = model.footerFontSize;\n            \n            height += titleLineCount * titleFontSize; // Title Lines\n            height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n            height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n            height += combinedBodyLength * bodyFontSize; // Body Lines\n            height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n            height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n            height += footerLineCount * (footerFontSize); // Footer Lines\n            height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n            \n            // Title width\n            var widthPadding = 0;\n            var maxLineWidth = function(line) {\n                width = Math.max(width, ctx.measureText(line).width + widthPadding);\n            };\n            \n            ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n            helpers.each(model.title, maxLineWidth);\n            \n            // Body width\n            ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n            helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n            \n            // Body lines may include some extra width due to the color box\n            widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n            helpers.each(body, function(bodyItem) {\n                helpers.each(bodyItem.before, maxLineWidth);\n                helpers.each(bodyItem.lines, maxLineWidth);\n                helpers.each(bodyItem.after, maxLineWidth);\n            });\n            \n            // Reset back to 0\n            widthPadding = 0;\n            \n            // Footer width\n            ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n            helpers.each(model.footer, maxLineWidth);\n            \n            // Add padding\n            width += 2 * model.xPadding;\n            \n            return {\n                width: width,\n                height: height\n            };\n        }\n        \n        /**\n         * Helper to get the alignment of a tooltip given the size\n         */\n        function determineAlignment(tooltip, size) {\n            var model = tooltip._model;\n            var chart = tooltip._chart;\n            var chartArea = tooltip._chart.chartArea;\n            var xAlign = 'center';\n            var yAlign = 'center';\n            \n            if (model.y < size.height) {\n                yAlign = 'top';\n            } else if (model.y > (chart.height - size.height)) {\n                yAlign = 'bottom';\n            }\n            \n            var lf, rf; // functions to determine left, right alignment\n            var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n            var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n            var midX = (chartArea.left + chartArea.right) / 2;\n            var midY = (chartArea.top + chartArea.bottom) / 2;\n            \n            if (yAlign === 'center') {\n                lf = function(x) {\n                    return x <= midX;\n                };\n                rf = function(x) {\n                    return x > midX;\n                };\n            } else {\n                lf = function(x) {\n                    return x <= (size.width / 2);\n                };\n                rf = function(x) {\n                    return x >= (chart.width - (size.width / 2));\n                };\n            }\n            \n            olf = function(x) {\n                return x + size.width > chart.width;\n            };\n            orf = function(x) {\n                return x - size.width < 0;\n            };\n            yf = function(y) {\n                return y <= midY ? 'top' : 'bottom';\n            };\n            \n            if (lf(model.x)) {\n                xAlign = 'left';\n                \n                // Is tooltip too wide and goes over the right side of the chart.?\n                if (olf(model.x)) {\n                    xAlign = 'center';\n                    yAlign = yf(model.y);\n                }\n            } else if (rf(model.x)) {\n                xAlign = 'right';\n                \n                // Is tooltip too wide and goes outside left edge of canvas?\n                if (orf(model.x)) {\n                    xAlign = 'center';\n                    yAlign = yf(model.y);\n                }\n            }\n            \n            var opts = tooltip._options;\n            return {\n                xAlign: opts.xAlign ? opts.xAlign : xAlign,\n                yAlign: opts.yAlign ? opts.yAlign : yAlign\n            };\n        }\n        \n        /**\n         * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n         */\n        function getBackgroundPoint(vm, size, alignment) {\n            // Background Position\n            var x = vm.x;\n            var y = vm.y;\n            \n            var caretSize = vm.caretSize,\n                caretPadding = vm.caretPadding,\n                cornerRadius = vm.cornerRadius,\n                xAlign = alignment.xAlign,\n                yAlign = alignment.yAlign,\n                paddingAndSize = caretSize + caretPadding,\n                radiusAndPadding = cornerRadius + caretPadding;\n            \n            if (xAlign === 'right') {\n                x -= size.width;\n            } else if (xAlign === 'center') {\n                x -= (size.width / 2);\n            }\n            \n            if (yAlign === 'top') {\n                y += paddingAndSize;\n            } else if (yAlign === 'bottom') {\n                y -= size.height + paddingAndSize;\n            } else {\n                y -= (size.height / 2);\n            }\n            \n            if (yAlign === 'center') {\n                if (xAlign === 'left') {\n                    x += paddingAndSize;\n                } else if (xAlign === 'right') {\n                    x -= paddingAndSize;\n                }\n            } else if (xAlign === 'left') {\n                x -= radiusAndPadding;\n            } else if (xAlign === 'right') {\n                x += radiusAndPadding;\n            }\n            \n            return {\n                x: x,\n                y: y\n            };\n        }\n        \n        Chart.Tooltip = Chart.Element.extend({\n            initialize: function() {\n                this._model = getBaseModel(this._options);\n            },\n            \n            // Get the title\n            // Args are: (tooltipItem, data)\n            getTitle: function() {\n                var me = this;\n                var opts = me._options;\n                var callbacks = opts.callbacks;\n                \n                var beforeTitle = callbacks.beforeTitle.apply(me, arguments),\n                    title = callbacks.title.apply(me, arguments),\n                    afterTitle = callbacks.afterTitle.apply(me, arguments);\n                \n                var lines = [];\n                lines = pushOrConcat(lines, beforeTitle);\n                lines = pushOrConcat(lines, title);\n                lines = pushOrConcat(lines, afterTitle);\n                \n                return lines;\n            },\n            \n            // Args are: (tooltipItem, data)\n            getBeforeBody: function() {\n                var lines = this._options.callbacks.beforeBody.apply(this, arguments);\n                return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n            },\n            \n            // Args are: (tooltipItem, data)\n            getBody: function(tooltipItems, data) {\n                var me = this;\n                var callbacks = me._options.callbacks;\n                var bodyItems = [];\n                \n                helpers.each(tooltipItems, function(tooltipItem) {\n                    var bodyItem = {\n                        before: [],\n                        lines: [],\n                        after: []\n                    };\n                    pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));\n                    pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n                    pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));\n                    \n                    bodyItems.push(bodyItem);\n                });\n                \n                return bodyItems;\n            },\n            \n            // Args are: (tooltipItem, data)\n            getAfterBody: function() {\n                var lines = this._options.callbacks.afterBody.apply(this, arguments);\n                return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];\n            },\n            \n            // Get the footer and beforeFooter and afterFooter lines\n            // Args are: (tooltipItem, data)\n            getFooter: function() {\n                var me = this;\n                var callbacks = me._options.callbacks;\n                \n                var beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n                var footer = callbacks.footer.apply(me, arguments);\n                var afterFooter = callbacks.afterFooter.apply(me, arguments);\n                \n                var lines = [];\n                lines = pushOrConcat(lines, beforeFooter);\n                lines = pushOrConcat(lines, footer);\n                lines = pushOrConcat(lines, afterFooter);\n                \n                return lines;\n            },\n            \n            update: function(changed) {\n                var me = this;\n                var opts = me._options;\n                \n                // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n                // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n                // which breaks any animations.\n                var existingModel = me._model;\n                var model = me._model = getBaseModel(opts);\n                var active = me._active;\n                \n                var data = me._data;\n                \n                // In the case where active.length === 0 we need to keep these at existing values for good animations\n                var alignment = {\n                    xAlign: existingModel.xAlign,\n                    yAlign: existingModel.yAlign\n                };\n                var backgroundPoint = {\n                    x: existingModel.x,\n                    y: existingModel.y\n                };\n                var tooltipSize = {\n                    width: existingModel.width,\n                    height: existingModel.height\n                };\n                var tooltipPosition = {\n                    x: existingModel.caretX,\n                    y: existingModel.caretY\n                };\n                \n                var i, len;\n                \n                if (active.length) {\n                    model.opacity = 1;\n                    \n                    var labelColors = [];\n                    tooltipPosition = Chart.Tooltip.positioners[opts.position](active, me._eventPosition);\n                    \n                    var tooltipItems = [];\n                    for (i = 0, len = active.length; i < len; ++i) {\n                        tooltipItems.push(createTooltipItem(active[i]));\n                    }\n                    \n                    // If the user provided a filter function, use it to modify the tooltip items\n                    if (opts.filter) {\n                        tooltipItems = tooltipItems.filter(function(a) {\n                            return opts.filter(a, data);\n                        });\n                    }\n                    \n                    // If the user provided a sorting function, use it to modify the tooltip items\n                    if (opts.itemSort) {\n                        tooltipItems = tooltipItems.sort(function(a, b) {\n                            return opts.itemSort(a, b, data);\n                        });\n                    }\n                    \n                    // Determine colors for boxes\n                    helpers.each(tooltipItems, function(tooltipItem) {\n                        labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n                    });\n                    \n                    // Build the Text Lines\n                    model.title = me.getTitle(tooltipItems, data);\n                    model.beforeBody = me.getBeforeBody(tooltipItems, data);\n                    model.body = me.getBody(tooltipItems, data);\n                    model.afterBody = me.getAfterBody(tooltipItems, data);\n                    model.footer = me.getFooter(tooltipItems, data);\n                    \n                    // Initial positioning and colors\n                    model.x = Math.round(tooltipPosition.x);\n                    model.y = Math.round(tooltipPosition.y);\n                    model.caretPadding = opts.caretPadding;\n                    model.labelColors = labelColors;\n                    \n                    // data points\n                    model.dataPoints = tooltipItems;\n                    \n                    // We need to determine alignment of the tooltip\n                    tooltipSize = getTooltipSize(this, model);\n                    alignment = determineAlignment(this, tooltipSize);\n                    // Final Size and Position\n                    backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);\n                } else {\n                    model.opacity = 0;\n                }\n                \n                model.xAlign = alignment.xAlign;\n                model.yAlign = alignment.yAlign;\n                model.x = backgroundPoint.x;\n                model.y = backgroundPoint.y;\n                model.width = tooltipSize.width;\n                model.height = tooltipSize.height;\n                \n                // Point where the caret on the tooltip points to\n                model.caretX = tooltipPosition.x;\n                model.caretY = tooltipPosition.y;\n                \n                me._model = model;\n                \n                if (changed && opts.custom) {\n                    opts.custom.call(me, model);\n                }\n                \n                return me;\n            },\n            drawCaret: function(tooltipPoint, size) {\n                var ctx = this._chart.ctx;\n                var vm = this._view;\n                var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n                \n                ctx.lineTo(caretPosition.x1, caretPosition.y1);\n                ctx.lineTo(caretPosition.x2, caretPosition.y2);\n                ctx.lineTo(caretPosition.x3, caretPosition.y3);\n            },\n            getCaretPosition: function(tooltipPoint, size, vm) {\n                var x1, x2, x3;\n                var y1, y2, y3;\n                var caretSize = vm.caretSize;\n                var cornerRadius = vm.cornerRadius;\n                var xAlign = vm.xAlign,\n                    yAlign = vm.yAlign;\n                var ptX = tooltipPoint.x,\n                    ptY = tooltipPoint.y;\n                var width = size.width,\n                    height = size.height;\n                \n                if (yAlign === 'center') {\n                    y2 = ptY + (height / 2);\n                    \n                    if (xAlign === 'left') {\n                        x1 = ptX;\n                        x2 = x1 - caretSize;\n                        x3 = x1;\n                        \n                        y1 = y2 + caretSize;\n                        y3 = y2 - caretSize;\n                    } else {\n                        x1 = ptX + width;\n                        x2 = x1 + caretSize;\n                        x3 = x1;\n                        \n                        y1 = y2 - caretSize;\n                        y3 = y2 + caretSize;\n                    }\n                } else {\n                    if (xAlign === 'left') {\n                        x2 = ptX + cornerRadius + (caretSize);\n                        x1 = x2 - caretSize;\n                        x3 = x2 + caretSize;\n                    } else if (xAlign === 'right') {\n                        x2 = ptX + width - cornerRadius - caretSize;\n                        x1 = x2 - caretSize;\n                        x3 = x2 + caretSize;\n                    } else {\n                        x2 = ptX + (width / 2);\n                        x1 = x2 - caretSize;\n                        x3 = x2 + caretSize;\n                    }\n                    if (yAlign === 'top') {\n                        y1 = ptY;\n                        y2 = y1 - caretSize;\n                        y3 = y1;\n                    } else {\n                        y1 = ptY + height;\n                        y2 = y1 + caretSize;\n                        y3 = y1;\n                        // invert drawing order\n                        var tmp = x3;\n                        x3 = x1;\n                        x1 = tmp;\n                    }\n                }\n                return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n            },\n            drawTitle: function(pt, vm, ctx, opacity) {\n                var title = vm.title;\n                \n                if (title.length) {\n                    ctx.textAlign = vm._titleAlign;\n                    ctx.textBaseline = 'top';\n                    \n                    var titleFontSize = vm.titleFontSize,\n                        titleSpacing = vm.titleSpacing;\n                    \n                    ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);\n                    ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n                    \n                    var i, len;\n                    for (i = 0, len = title.length; i < len; ++i) {\n                        ctx.fillText(title[i], pt.x, pt.y);\n                        pt.y += titleFontSize + titleSpacing; // Line Height and spacing\n                        \n                        if (i + 1 === title.length) {\n                            pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n                        }\n                    }\n                }\n            },\n            drawBody: function(pt, vm, ctx, opacity) {\n                var bodyFontSize = vm.bodyFontSize;\n                var bodySpacing = vm.bodySpacing;\n                var body = vm.body;\n                \n                ctx.textAlign = vm._bodyAlign;\n                ctx.textBaseline = 'top';\n                \n                var textColor = mergeOpacity(vm.bodyFontColor, opacity);\n                ctx.fillStyle = textColor;\n                ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n                \n                // Before Body\n                var xLinePadding = 0;\n                var fillLineOfText = function(line) {\n                    ctx.fillText(line, pt.x + xLinePadding, pt.y);\n                    pt.y += bodyFontSize + bodySpacing;\n                };\n                \n                // Before body lines\n                helpers.each(vm.beforeBody, fillLineOfText);\n                \n                var drawColorBoxes = vm.displayColors;\n                xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;\n                \n                // Draw body lines now\n                helpers.each(body, function(bodyItem, i) {\n                    helpers.each(bodyItem.before, fillLineOfText);\n                    \n                    helpers.each(bodyItem.lines, function(line) {\n                        // Draw Legend-like boxes if needed\n                        if (drawColorBoxes) {\n                            // Fill a white rect so that colours merge nicely if the opacity is < 1\n                            ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);\n                            ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n                            \n                            // Border\n                            ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);\n                            ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);\n                            \n                            // Inner square\n                            ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);\n                            ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n                            \n                            ctx.fillStyle = textColor;\n                        }\n                        \n                        fillLineOfText(line);\n                    });\n                    \n                    helpers.each(bodyItem.after, fillLineOfText);\n                });\n                \n                // Reset back to 0 for after body\n                xLinePadding = 0;\n                \n                // After body lines\n                helpers.each(vm.afterBody, fillLineOfText);\n                pt.y -= bodySpacing; // Remove last body spacing\n            },\n            drawFooter: function(pt, vm, ctx, opacity) {\n                var footer = vm.footer;\n                \n                if (footer.length) {\n                    pt.y += vm.footerMarginTop;\n                    \n                    ctx.textAlign = vm._footerAlign;\n                    ctx.textBaseline = 'top';\n                    \n                    ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);\n                    ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n                    \n                    helpers.each(footer, function(line) {\n                        ctx.fillText(line, pt.x, pt.y);\n                        pt.y += vm.footerFontSize + vm.footerSpacing;\n                    });\n                }\n            },\n            drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {\n                ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);\n                ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);\n                ctx.lineWidth = vm.borderWidth;\n                var xAlign = vm.xAlign;\n                var yAlign = vm.yAlign;\n                var x = pt.x;\n                var y = pt.y;\n                var width = tooltipSize.width;\n                var height = tooltipSize.height;\n                var radius = vm.cornerRadius;\n                \n                ctx.beginPath();\n                ctx.moveTo(x + radius, y);\n                if (yAlign === 'top') {\n                    this.drawCaret(pt, tooltipSize);\n                }\n                ctx.lineTo(x + width - radius, y);\n                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n                if (yAlign === 'center' && xAlign === 'right') {\n                    this.drawCaret(pt, tooltipSize);\n                }\n                ctx.lineTo(x + width, y + height - radius);\n                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n                if (yAlign === 'bottom') {\n                    this.drawCaret(pt, tooltipSize);\n                }\n                ctx.lineTo(x + radius, y + height);\n                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n                if (yAlign === 'center' && xAlign === 'left') {\n                    this.drawCaret(pt, tooltipSize);\n                }\n                ctx.lineTo(x, y + radius);\n                ctx.quadraticCurveTo(x, y, x + radius, y);\n                ctx.closePath();\n                \n                ctx.fill();\n                \n                if (vm.borderWidth > 0) {\n                    ctx.stroke();\n                }\n            },\n            draw: function() {\n                var ctx = this._chart.ctx;\n                var vm = this._view;\n                \n                if (vm.opacity === 0) {\n                    return;\n                }\n                \n                var tooltipSize = {\n                    width: vm.width,\n                    height: vm.height\n                };\n                var pt = {\n                    x: vm.x,\n                    y: vm.y\n                };\n                \n                // IE11/Edge does not like very small opacities, so snap to 0\n                var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n                \n                // Truthy/falsey value for empty tooltip\n                var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n                \n                if (this._options.enabled && hasTooltipContent) {\n                    // Draw Background\n                    this.drawBackground(pt, vm, ctx, tooltipSize, opacity);\n                    \n                    // Draw Title, Body, and Footer\n                    pt.x += vm.xPadding;\n                    pt.y += vm.yPadding;\n                    \n                    // Titles\n                    this.drawTitle(pt, vm, ctx, opacity);\n                    \n                    // Body\n                    this.drawBody(pt, vm, ctx, opacity);\n                    \n                    // Footer\n                    this.drawFooter(pt, vm, ctx, opacity);\n                }\n            },\n            \n            /**\n             * Handle an event\n             * @private\n             * @param {IEvent} event - The event to handle\n             * @returns {Boolean} true if the tooltip changed\n             */\n            handleEvent: function(e) {\n                var me = this;\n                var options = me._options;\n                var changed = false;\n                \n                me._lastActive = me._lastActive || [];\n                \n                // Find Active Elements for tooltips\n                if (e.type === 'mouseout') {\n                    me._active = [];\n                } else {\n                    me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n                }\n                \n                // Remember Last Actives\n                changed = !helpers.arrayEquals(me._active, me._lastActive);\n                \n                // If tooltip didn't change, do not handle the target event\n                if (!changed) {\n                    return false;\n                }\n                \n                me._lastActive = me._active;\n                \n                if (options.enabled || options.custom) {\n                    me._eventPosition = {\n                        x: e.x,\n                        y: e.y\n                    };\n                    \n                    var model = me._model;\n                    me.update(true);\n                    me.pivot();\n                    \n                    // See if our tooltip position changed\n                    changed |= (model.x !== me._model.x) || (model.y !== me._model.y);\n                }\n                \n                return changed;\n            }\n        });\n        \n        /**\n         * @namespace Chart.Tooltip.positioners\n         */\n        Chart.Tooltip.positioners = {\n            /**\n             * Average mode places the tooltip at the average position of the elements shown\n             * @function Chart.Tooltip.positioners.average\n             * @param elements {ChartElement[]} the elements being displayed in the tooltip\n             * @returns {Point} tooltip position\n             */\n            average: function(elements) {\n                if (!elements.length) {\n                    return false;\n                }\n                \n                var i, len;\n                var x = 0;\n                var y = 0;\n                var count = 0;\n                \n                for (i = 0, len = elements.length; i < len; ++i) {\n                    var el = elements[i];\n                    if (el && el.hasValue()) {\n                        var pos = el.tooltipPosition();\n                        x += pos.x;\n                        y += pos.y;\n                        ++count;\n                    }\n                }\n                \n                return {\n                    x: Math.round(x / count),\n                    y: Math.round(y / count)\n                };\n            },\n            \n            /**\n             * Gets the tooltip position nearest of the item nearest to the event position\n             * @function Chart.Tooltip.positioners.nearest\n             * @param elements {Chart.Element[]} the tooltip elements\n             * @param eventPosition {Point} the position of the event in canvas coordinates\n             * @returns {Point} the tooltip position\n             */\n            nearest: function(elements, eventPosition) {\n                var x = eventPosition.x;\n                var y = eventPosition.y;\n                \n                var nearestElement;\n                var minDistance = Number.POSITIVE_INFINITY;\n                var i, len;\n                for (i = 0, len = elements.length; i < len; ++i) {\n                    var el = elements[i];\n                    if (el && el.hasValue()) {\n                        var center = el.getCenterPoint();\n                        var d = helpers.distanceBetweenPoints(eventPosition, center);\n                        \n                        if (d < minDistance) {\n                            minDistance = d;\n                            nearestElement = el;\n                        }\n                    }\n                }\n                \n                if (nearestElement) {\n                    var tp = nearestElement.tooltipPosition();\n                    x = tp.x;\n                    y = tp.y;\n                }\n                \n                return {\n                    x: x,\n                    y: y\n                };\n            }\n        };\n    };\n    \n},{}],29:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers,\n            globalOpts = Chart.defaults.global;\n        \n        globalOpts.elements.arc = {\n            backgroundColor: globalOpts.defaultColor,\n            borderColor: '#fff',\n            borderWidth: 2\n        };\n        \n        Chart.elements.Arc = Chart.Element.extend({\n            inLabelRange: function(mouseX) {\n                var vm = this._view;\n                \n                if (vm) {\n                    return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n                }\n                return false;\n            },\n            inRange: function(chartX, chartY) {\n                var vm = this._view;\n                \n                if (vm) {\n                    var pointRelativePosition = helpers.getAngleFromPoint(vm, {\n                            x: chartX,\n                            y: chartY\n                        }),\n                        angle = pointRelativePosition.angle,\n                        distance = pointRelativePosition.distance;\n                    \n                    // Sanitise angle range\n                    var startAngle = vm.startAngle;\n                    var endAngle = vm.endAngle;\n                    while (endAngle < startAngle) {\n                        endAngle += 2.0 * Math.PI;\n                    }\n                    while (angle > endAngle) {\n                        angle -= 2.0 * Math.PI;\n                    }\n                    while (angle < startAngle) {\n                        angle += 2.0 * Math.PI;\n                    }\n                    \n                    // Check if within the range of the open/close angle\n                    var betweenAngles = (angle >= startAngle && angle <= endAngle),\n                        withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n                    \n                    return (betweenAngles && withinRadius);\n                }\n                return false;\n            },\n            getCenterPoint: function() {\n                var vm = this._view;\n                var halfAngle = (vm.startAngle + vm.endAngle) / 2;\n                var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n                return {\n                    x: vm.x + Math.cos(halfAngle) * halfRadius,\n                    y: vm.y + Math.sin(halfAngle) * halfRadius\n                };\n            },\n            getArea: function() {\n                var vm = this._view;\n                return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n            },\n            tooltipPosition: function() {\n                var vm = this._view;\n                \n                var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2),\n                    rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n                return {\n                    x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n                    y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n                };\n            },\n            draw: function() {\n                \n                var ctx = this._chart.ctx,\n                    vm = this._view,\n                    sA = vm.startAngle,\n                    eA = vm.endAngle;\n                \n                ctx.beginPath();\n                \n                ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n                ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n                \n                ctx.closePath();\n                ctx.strokeStyle = vm.borderColor;\n                ctx.lineWidth = vm.borderWidth;\n                \n                ctx.fillStyle = vm.backgroundColor;\n                \n                ctx.fill();\n                ctx.lineJoin = 'bevel';\n                \n                if (vm.borderWidth) {\n                    ctx.stroke();\n                }\n            }\n        });\n    };\n    \n},{}],30:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        var globalDefaults = Chart.defaults.global;\n        \n        Chart.defaults.global.elements.line = {\n            tension: 0.4,\n            backgroundColor: globalDefaults.defaultColor,\n            borderWidth: 3,\n            borderColor: globalDefaults.defaultColor,\n            borderCapStyle: 'butt',\n            borderDash: [],\n            borderDashOffset: 0.0,\n            borderJoinStyle: 'miter',\n            capBezierPoints: true,\n            fill: true, // do we fill in the area between the line and its base axis\n        };\n        \n        Chart.elements.Line = Chart.Element.extend({\n            draw: function() {\n                var me = this;\n                var vm = me._view;\n                var ctx = me._chart.ctx;\n                var spanGaps = vm.spanGaps;\n                var points = me._children.slice(); // clone array\n                var globalOptionLineElements = globalDefaults.elements.line;\n                var lastDrawnIndex = -1;\n                var index, current, previous, currentVM;\n                \n                // If we are looping, adding the first point again\n                if (me._loop && points.length) {\n                    points.push(points[0]);\n                }\n                \n                ctx.save();\n                \n                // Stroke Line Options\n                ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n                \n                // IE 9 and 10 do not support line dash\n                if (ctx.setLineDash) {\n                    ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n                }\n                \n                ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;\n                ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n                ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;\n                ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n                \n                // Stroke Line\n                ctx.beginPath();\n                lastDrawnIndex = -1;\n                \n                for (index = 0; index < points.length; ++index) {\n                    current = points[index];\n                    previous = helpers.previousItem(points, index);\n                    currentVM = current._view;\n                    \n                    // First point moves to it's starting position no matter what\n                    if (index === 0) {\n                        if (!currentVM.skip) {\n                            ctx.moveTo(currentVM.x, currentVM.y);\n                            lastDrawnIndex = index;\n                        }\n                    } else {\n                        previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n                        \n                        if (!currentVM.skip) {\n                            if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n                                // There was a gap and this is the first point after the gap\n                                ctx.moveTo(currentVM.x, currentVM.y);\n                            } else {\n                                // Line to next point\n                                helpers.canvas.lineTo(ctx, previous._view, current._view);\n                            }\n                            lastDrawnIndex = index;\n                        }\n                    }\n                }\n                \n                ctx.stroke();\n                ctx.restore();\n            }\n        });\n    };\n    \n},{}],31:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers,\n            globalOpts = Chart.defaults.global,\n            defaultColor = globalOpts.defaultColor;\n        \n        globalOpts.elements.point = {\n            radius: 3,\n            pointStyle: 'circle',\n            backgroundColor: defaultColor,\n            borderWidth: 1,\n            borderColor: defaultColor,\n            // Hover\n            hitRadius: 1,\n            hoverRadius: 4,\n            hoverBorderWidth: 1\n        };\n        \n        function xRange(mouseX) {\n            var vm = this._view;\n            return vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n        }\n        \n        function yRange(mouseY) {\n            var vm = this._view;\n            return vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;\n        }\n        \n        Chart.elements.Point = Chart.Element.extend({\n            inRange: function(mouseX, mouseY) {\n                var vm = this._view;\n                return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n            },\n            \n            inLabelRange: xRange,\n            inXRange: xRange,\n            inYRange: yRange,\n            \n            getCenterPoint: function() {\n                var vm = this._view;\n                return {\n                    x: vm.x,\n                    y: vm.y\n                };\n            },\n            getArea: function() {\n                return Math.PI * Math.pow(this._view.radius, 2);\n            },\n            tooltipPosition: function() {\n                var vm = this._view;\n                return {\n                    x: vm.x,\n                    y: vm.y,\n                    padding: vm.radius + vm.borderWidth\n                };\n            },\n            draw: function(chartArea) {\n                var vm = this._view;\n                var model = this._model;\n                var ctx = this._chart.ctx;\n                var pointStyle = vm.pointStyle;\n                var radius = vm.radius;\n                var x = vm.x;\n                var y = vm.y;\n                var color = Chart.helpers.color;\n                var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)\n                var ratio = 0;\n                \n                if (vm.skip) {\n                    return;\n                }\n                \n                ctx.strokeStyle = vm.borderColor || defaultColor;\n                ctx.lineWidth = helpers.getValueOrDefault(vm.borderWidth, globalOpts.elements.point.borderWidth);\n                ctx.fillStyle = vm.backgroundColor || defaultColor;\n                \n                // Cliping for Points.\n                // going out from inner charArea?\n                if ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right*errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom*errMargin < model.y))) {\n                    // Point fade out\n                    if (model.x < chartArea.left) {\n                        ratio = (x - model.x) / (chartArea.left - model.x);\n                    } else if (chartArea.right*errMargin < model.x) {\n                        ratio = (model.x - x) / (model.x - chartArea.right);\n                    } else if (model.y < chartArea.top) {\n                        ratio = (y - model.y) / (chartArea.top - model.y);\n                    } else if (chartArea.bottom*errMargin < model.y) {\n                        ratio = (model.y - y) / (model.y - chartArea.bottom);\n                    }\n                    ratio = Math.round(ratio*100) / 100;\n                    ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();\n                    ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();\n                }\n                \n                Chart.canvasHelpers.drawPoint(ctx, pointStyle, radius, x, y);\n            }\n        });\n    };\n    \n},{}],32:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var globalOpts = Chart.defaults.global;\n        \n        globalOpts.elements.rectangle = {\n            backgroundColor: globalOpts.defaultColor,\n            borderWidth: 0,\n            borderColor: globalOpts.defaultColor,\n            borderSkipped: 'bottom'\n        };\n        \n        function isVertical(bar) {\n            return bar._view.width !== undefined;\n        }\n        \n        /**\n         * Helper function to get the bounds of the bar regardless of the orientation\n         * @private\n         * @param bar {Chart.Element.Rectangle} the bar\n         * @return {Bounds} bounds of the bar\n         */\n        function getBarBounds(bar) {\n            var vm = bar._view;\n            var x1, x2, y1, y2;\n            \n            if (isVertical(bar)) {\n                // vertical\n                var halfWidth = vm.width / 2;\n                x1 = vm.x - halfWidth;\n                x2 = vm.x + halfWidth;\n                y1 = Math.min(vm.y, vm.base);\n                y2 = Math.max(vm.y, vm.base);\n            } else {\n                // horizontal bar\n                var halfHeight = vm.height / 2;\n                x1 = Math.min(vm.x, vm.base);\n                x2 = Math.max(vm.x, vm.base);\n                y1 = vm.y - halfHeight;\n                y2 = vm.y + halfHeight;\n            }\n            \n            return {\n                left: x1,\n                top: y1,\n                right: x2,\n                bottom: y2\n            };\n        }\n        \n        Chart.elements.Rectangle = Chart.Element.extend({\n            draw: function() {\n                var ctx = this._chart.ctx;\n                var vm = this._view;\n                var left, right, top, bottom, signX, signY, borderSkipped;\n                var borderWidth = vm.borderWidth;\n                \n                if (!vm.horizontal) {\n                    // bar\n                    left = vm.x - vm.width / 2;\n                    right = vm.x + vm.width / 2;\n                    top = vm.y;\n                    bottom = vm.base;\n                    signX = 1;\n                    signY = bottom > top? 1: -1;\n                    borderSkipped = vm.borderSkipped || 'bottom';\n                } else {\n                    // horizontal bar\n                    left = vm.base;\n                    right = vm.x;\n                    top = vm.y - vm.height / 2;\n                    bottom = vm.y + vm.height / 2;\n                    signX = right > left? 1: -1;\n                    signY = 1;\n                    borderSkipped = vm.borderSkipped || 'left';\n                }\n                \n                // Canvas doesn't allow us to stroke inside the width so we can\n                // adjust the sizes to fit if we're setting a stroke on the line\n                if (borderWidth) {\n                    // borderWidth shold be less than bar width and bar height.\n                    var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n                    borderWidth = borderWidth > barSize? barSize: borderWidth;\n                    var halfStroke = borderWidth / 2;\n                    // Adjust borderWidth when bar top position is near vm.base(zero).\n                    var borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);\n                    var borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);\n                    var borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);\n                    var borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);\n                    // not become a vertical line?\n                    if (borderLeft !== borderRight) {\n                        top = borderTop;\n                        bottom = borderBottom;\n                    }\n                    // not become a horizontal line?\n                    if (borderTop !== borderBottom) {\n                        left = borderLeft;\n                        right = borderRight;\n                    }\n                }\n                \n                ctx.beginPath();\n                ctx.fillStyle = vm.backgroundColor;\n                ctx.strokeStyle = vm.borderColor;\n                ctx.lineWidth = borderWidth;\n                \n                // Corner points, from bottom-left to bottom-right clockwise\n                // | 1 2 |\n                // | 0 3 |\n                var corners = [\n                    [left, bottom],\n                    [left, top],\n                    [right, top],\n                    [right, bottom]\n                ];\n                \n                // Find first (starting) corner with fallback to 'bottom'\n                var borders = ['bottom', 'left', 'top', 'right'];\n                var startCorner = borders.indexOf(borderSkipped, 0);\n                if (startCorner === -1) {\n                    startCorner = 0;\n                }\n                \n                function cornerAt(index) {\n                    return corners[(startCorner + index) % 4];\n                }\n                \n                // Draw rectangle from 'startCorner'\n                var corner = cornerAt(0);\n                ctx.moveTo(corner[0], corner[1]);\n                \n                for (var i = 1; i < 4; i++) {\n                    corner = cornerAt(i);\n                    ctx.lineTo(corner[0], corner[1]);\n                }\n                \n                ctx.fill();\n                if (borderWidth) {\n                    ctx.stroke();\n                }\n            },\n            height: function() {\n                var vm = this._view;\n                return vm.base - vm.y;\n            },\n            inRange: function(mouseX, mouseY) {\n                var inRange = false;\n                \n                if (this._view) {\n                    var bounds = getBarBounds(this);\n                    inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;\n                }\n                \n                return inRange;\n            },\n            inLabelRange: function(mouseX, mouseY) {\n                var me = this;\n                if (!me._view) {\n                    return false;\n                }\n                \n                var inRange = false;\n                var bounds = getBarBounds(me);\n                \n                if (isVertical(me)) {\n                    inRange = mouseX >= bounds.left && mouseX <= bounds.right;\n                } else {\n                    inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;\n                }\n                \n                return inRange;\n            },\n            inXRange: function(mouseX) {\n                var bounds = getBarBounds(this);\n                return mouseX >= bounds.left && mouseX <= bounds.right;\n            },\n            inYRange: function(mouseY) {\n                var bounds = getBarBounds(this);\n                return mouseY >= bounds.top && mouseY <= bounds.bottom;\n            },\n            getCenterPoint: function() {\n                var vm = this._view;\n                var x, y;\n                if (isVertical(this)) {\n                    x = vm.x;\n                    y = (vm.y + vm.base) / 2;\n                } else {\n                    x = (vm.x + vm.base) / 2;\n                    y = vm.y;\n                }\n                \n                return {x: x, y: y};\n            },\n            getArea: function() {\n                var vm = this._view;\n                return vm.width * Math.abs(vm.y - vm.base);\n            },\n            tooltipPosition: function() {\n                var vm = this._view;\n                return {\n                    x: vm.x,\n                    y: vm.y\n                };\n            }\n        });\n        \n    };\n    \n},{}],33:[function(require,module,exports){\n    'use strict';\n\n// Chart.Platform implementation for targeting a web browser\n    module.exports = function(Chart) {\n        var helpers = Chart.helpers;\n        \n        // DOM event types -> Chart.js event types.\n        // Note: only events with different types are mapped.\n        // https://developer.mozilla.org/en-US/docs/Web/Events\n        var eventTypeMap = {\n            // Touch events\n            touchstart: 'mousedown',\n            touchmove: 'mousemove',\n            touchend: 'mouseup',\n            \n            // Pointer events\n            pointerenter: 'mouseenter',\n            pointerdown: 'mousedown',\n            pointermove: 'mousemove',\n            pointerup: 'mouseup',\n            pointerleave: 'mouseout',\n            pointerout: 'mouseout'\n        };\n        \n        /**\n         * The \"used\" size is the final value of a dimension property after all calculations have\n         * been performed. This method uses the computed style of `element` but returns undefined\n         * if the computed style is not expressed in pixels. That can happen in some cases where\n         * `element` has a size relative to its parent and this last one is not yet displayed,\n         * for example because of `display: none` on a parent node.\n         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n         * @returns {Number} Size in pixels or undefined if unknown.\n         */\n        function readUsedSize(element, property) {\n            var value = helpers.getStyle(element, property);\n            var matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n            return matches? Number(matches[1]) : undefined;\n        }\n        \n        /**\n         * Initializes the canvas style and render size without modifying the canvas display size,\n         * since responsiveness is handled by the controller.resize() method. The config is used\n         * to determine the aspect ratio to apply in case no explicit height has been specified.\n         */\n        function initCanvas(canvas, config) {\n            var style = canvas.style;\n            \n            // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n            // returns null or '' if no explicit value has been set to the canvas attribute.\n            var renderHeight = canvas.getAttribute('height');\n            var renderWidth = canvas.getAttribute('width');\n            \n            // Chart.js modifies some canvas values that we want to restore on destroy\n            canvas._chartjs = {\n                initial: {\n                    height: renderHeight,\n                    width: renderWidth,\n                    style: {\n                        display: style.display,\n                        height: style.height,\n                        width: style.width\n                    }\n                }\n            };\n            \n            // Force canvas to display as block to avoid extra space caused by inline\n            // elements, which would interfere with the responsive resize process.\n            // https://github.com/chartjs/Chart.js/issues/2538\n            style.display = style.display || 'block';\n            \n            if (renderWidth === null || renderWidth === '') {\n                var displayWidth = readUsedSize(canvas, 'width');\n                if (displayWidth !== undefined) {\n                    canvas.width = displayWidth;\n                }\n            }\n            \n            if (renderHeight === null || renderHeight === '') {\n                if (canvas.style.height === '') {\n                    // If no explicit render height and style height, let's apply the aspect ratio,\n                    // which one can be specified by the user but also by charts as default option\n                    // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n                    canvas.height = canvas.width / (config.options.aspectRatio || 2);\n                } else {\n                    var displayHeight = readUsedSize(canvas, 'height');\n                    if (displayWidth !== undefined) {\n                        canvas.height = displayHeight;\n                    }\n                }\n            }\n            \n            return canvas;\n        }\n        \n        function createEvent(type, chart, x, y, nativeEvent) {\n            return {\n                type: type,\n                chart: chart,\n                native: nativeEvent || null,\n                x: x !== undefined? x : null,\n                y: y !== undefined? y : null,\n            };\n        }\n        \n        function fromNativeEvent(event, chart) {\n            var type = eventTypeMap[event.type] || event.type;\n            var pos = helpers.getRelativePosition(event, chart);\n            return createEvent(type, chart, pos.x, pos.y, event);\n        }\n        \n        function createResizer(handler) {\n            var iframe = document.createElement('iframe');\n            iframe.className = 'chartjs-hidden-iframe';\n            iframe.style.cssText =\n                'display:block;'+\n                'overflow:hidden;'+\n                'border:0;'+\n                'margin:0;'+\n                'top:0;'+\n                'left:0;'+\n                'bottom:0;'+\n                'right:0;'+\n                'height:100%;'+\n                'width:100%;'+\n                'position:absolute;'+\n                'pointer-events:none;'+\n                'z-index:-1;';\n            \n            // Prevent the iframe to gain focus on tab.\n            // https://github.com/chartjs/Chart.js/issues/3090\n            iframe.tabIndex = -1;\n            \n            // If the iframe is re-attached to the DOM, the resize listener is removed because the\n            // content is reloaded, so make sure to install the handler after the iframe is loaded.\n            // https://github.com/chartjs/Chart.js/issues/3521\n            helpers.addEvent(iframe, 'load', function() {\n                helpers.addEvent(iframe.contentWindow || iframe, 'resize', handler);\n                \n                // The iframe size might have changed while loading, which can also\n                // happen if the size has been changed while detached from the DOM.\n                handler();\n            });\n            \n            return iframe;\n        }\n        \n        function addResizeListener(node, listener, chart) {\n            var stub = node._chartjs = {\n                ticking: false\n            };\n            \n            // Throttle the callback notification until the next animation frame.\n            var notify = function() {\n                if (!stub.ticking) {\n                    stub.ticking = true;\n                    helpers.requestAnimFrame.call(window, function() {\n                        if (stub.resizer) {\n                            stub.ticking = false;\n                            return listener(createEvent('resize', chart));\n                        }\n                    });\n                }\n            };\n            \n            // Let's keep track of this added iframe and thus avoid DOM query when removing it.\n            stub.resizer = createResizer(notify);\n            \n            node.insertBefore(stub.resizer, node.firstChild);\n        }\n        \n        function removeResizeListener(node) {\n            if (!node || !node._chartjs) {\n                return;\n            }\n            \n            var resizer = node._chartjs.resizer;\n            if (resizer) {\n                resizer.parentNode.removeChild(resizer);\n                node._chartjs.resizer = null;\n            }\n            \n            delete node._chartjs;\n        }\n        \n        return {\n            acquireContext: function(item, config) {\n                if (typeof item === 'string') {\n                    item = document.getElementById(item);\n                } else if (item.length) {\n                    // Support for array based queries (such as jQuery)\n                    item = item[0];\n                }\n                \n                if (item && item.canvas) {\n                    // Support for any object associated to a canvas (including a context2d)\n                    item = item.canvas;\n                }\n                \n                // To prevent canvas fingerprinting, some add-ons undefine the getContext\n                // method, for example: https://github.com/kkapsner/CanvasBlocker\n                // https://github.com/chartjs/Chart.js/issues/2807\n                var context = item && item.getContext && item.getContext('2d');\n                \n                // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n                // inside an iframe or when running in a protected environment. We could guess the\n                // types from their toString() value but let's keep things flexible and assume it's\n                // a sufficient condition if the item has a context2D which has item as `canvas`.\n                // https://github.com/chartjs/Chart.js/issues/3887\n                // https://github.com/chartjs/Chart.js/issues/4102\n                // https://github.com/chartjs/Chart.js/issues/4152\n                if (context && context.canvas === item) {\n                    initCanvas(item, config);\n                    return context;\n                }\n                \n                return null;\n            },\n            \n            releaseContext: function(context) {\n                var canvas = context.canvas;\n                if (!canvas._chartjs) {\n                    return;\n                }\n                \n                var initial = canvas._chartjs.initial;\n                ['height', 'width'].forEach(function(prop) {\n                    var value = initial[prop];\n                    if (value === undefined || value === null) {\n                        canvas.removeAttribute(prop);\n                    } else {\n                        canvas.setAttribute(prop, value);\n                    }\n                });\n                \n                helpers.each(initial.style || {}, function(value, key) {\n                    canvas.style[key] = value;\n                });\n                \n                // The canvas render size might have been changed (and thus the state stack discarded),\n                // we can't use save() and restore() to restore the initial state. So make sure that at\n                // least the canvas context is reset to the default state by setting the canvas width.\n                // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n                canvas.width = canvas.width;\n                \n                delete canvas._chartjs;\n            },\n            \n            addEventListener: function(chart, type, listener) {\n                var canvas = chart.canvas;\n                if (type === 'resize') {\n                    // Note: the resize event is not supported on all browsers.\n                    addResizeListener(canvas.parentNode, listener, chart);\n                    return;\n                }\n                \n                var stub = listener._chartjs || (listener._chartjs = {});\n                var proxies = stub.proxies || (stub.proxies = {});\n                var proxy = proxies[chart.id + '_' + type] = function(event) {\n                    listener(fromNativeEvent(event, chart));\n                };\n                \n                helpers.addEvent(canvas, type, proxy);\n            },\n            \n            removeEventListener: function(chart, type, listener) {\n                var canvas = chart.canvas;\n                if (type === 'resize') {\n                    // Note: the resize event is not supported on all browsers.\n                    removeResizeListener(canvas.parentNode, listener);\n                    return;\n                }\n                \n                var stub = listener._chartjs || {};\n                var proxies = stub.proxies || {};\n                var proxy = proxies[chart.id + '_' + type];\n                if (!proxy) {\n                    return;\n                }\n                \n                helpers.removeEvent(canvas, type, proxy);\n            }\n        };\n    };\n    \n},{}],34:[function(require,module,exports){\n    'use strict';\n\n// By default, select the browser (DOM) platform.\n// @TODO Make possible to select another platform at build time.\n    var implementation = require(33);\n    \n    module.exports = function(Chart) {\n        /**\n         * @namespace Chart.platform\n         * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n         * @since 2.4.0\n         */\n        Chart.platform = {\n            /**\n             * Called at chart construction time, returns a context2d instance implementing\n             * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n             * @param {*} item - The native item from which to acquire context (platform specific)\n             * @param {Object} options - The chart options\n             * @returns {CanvasRenderingContext2D} context2d instance\n             */\n            acquireContext: function() {},\n            \n            /**\n             * Called at chart destruction time, releases any resources associated to the context\n             * previously returned by the acquireContext() method.\n             * @param {CanvasRenderingContext2D} context - The context2d instance\n             * @returns {Boolean} true if the method succeeded, else false\n             */\n            releaseContext: function() {},\n            \n            /**\n             * Registers the specified listener on the given chart.\n             * @param {Chart} chart - Chart from which to listen for event\n             * @param {String} type - The ({@link IEvent}) type to listen for\n             * @param {Function} listener - Receives a notification (an object that implements\n             * the {@link IEvent} interface) when an event of the specified type occurs.\n             */\n            addEventListener: function() {},\n            \n            /**\n             * Removes the specified listener previously registered with addEventListener.\n             * @param {Chart} chart -Chart from which to remove the listener\n             * @param {String} type - The ({@link IEvent}) type to remove\n             * @param {Function} listener - The listener function to remove from the event target.\n             */\n            removeEventListener: function() {}\n        };\n        \n        /**\n         * @interface IPlatform\n         * Allows abstracting platform dependencies away from the chart\n         * @borrows Chart.platform.acquireContext as acquireContext\n         * @borrows Chart.platform.releaseContext as releaseContext\n         * @borrows Chart.platform.addEventListener as addEventListener\n         * @borrows Chart.platform.removeEventListener as removeEventListener\n         */\n        \n        /**\n         * @interface IEvent\n         * @prop {String} type - The event type name, possible values are:\n         * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',\n         * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'\n         * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')\n         * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)\n         * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)\n         */\n        \n        Chart.helpers.extend(Chart.platform, implementation(Chart));\n    };\n    \n},{\"33\":33}],35:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        /**\n         * Plugin based on discussion from the following Chart.js issues:\n         * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n         * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n         */\n        Chart.defaults.global.plugins.filler = {\n            propagate: true\n        };\n        \n        var defaults = Chart.defaults;\n        var helpers = Chart.helpers;\n        var mappers = {\n            dataset: function(source) {\n                var index = source.fill;\n                var chart = source.chart;\n                var meta = chart.getDatasetMeta(index);\n                var visible = meta && chart.isDatasetVisible(index);\n                var points = (visible && meta.dataset._children) || [];\n                \n                return !points.length? null : function(point, i) {\n                    return points[i]._view || null;\n                };\n            },\n            \n            boundary: function(source) {\n                var boundary = source.boundary;\n                var x = boundary? boundary.x : null;\n                var y = boundary? boundary.y : null;\n                \n                return function(point) {\n                    return {\n                        x: x === null? point.x : x,\n                        y: y === null? point.y : y,\n                    };\n                };\n            }\n        };\n        \n        // @todo if (fill[0] === '#')\n        function decodeFill(el, index, count) {\n            var model = el._model || {};\n            var fill = model.fill;\n            var target;\n            \n            if (fill === undefined) {\n                fill = !!model.backgroundColor;\n            }\n            \n            if (fill === false || fill === null) {\n                return false;\n            }\n            \n            if (fill === true) {\n                return 'origin';\n            }\n            \n            target = parseFloat(fill, 10);\n            if (isFinite(target) && Math.floor(target) === target) {\n                if (fill[0] === '-' || fill[0] === '+') {\n                    target = index + target;\n                }\n                \n                if (target === index || target < 0 || target >= count) {\n                    return false;\n                }\n                \n                return target;\n            }\n            \n            switch (fill) {\n                // compatibility\n                case 'bottom':\n                    return 'start';\n                case 'top':\n                    return 'end';\n                case 'zero':\n                    return 'origin';\n                // supported boundaries\n                case 'origin':\n                case 'start':\n                case 'end':\n                    return fill;\n                // invalid fill values\n                default:\n                    return false;\n            }\n        }\n        \n        function computeBoundary(source) {\n            var model = source.el._model || {};\n            var scale = source.el._scale || {};\n            var fill = source.fill;\n            var target = null;\n            var horizontal;\n            \n            if (isFinite(fill)) {\n                return null;\n            }\n            \n            // Backward compatibility: until v3, we still need to support boundary values set on\n            // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n            // controllers might still use it (e.g. the Smith chart).\n            \n            if (fill === 'start') {\n                target = model.scaleBottom === undefined? scale.bottom : model.scaleBottom;\n            } else if (fill === 'end') {\n                target = model.scaleTop === undefined? scale.top : model.scaleTop;\n            } else if (model.scaleZero !== undefined) {\n                target = model.scaleZero;\n            } else if (scale.getBasePosition) {\n                target = scale.getBasePosition();\n            } else if (scale.getBasePixel) {\n                target = scale.getBasePixel();\n            }\n            \n            if (target !== undefined && target !== null) {\n                if (target.x !== undefined && target.y !== undefined) {\n                    return target;\n                }\n                \n                if (typeof target === 'number' && isFinite(target)) {\n                    horizontal = scale.isHorizontal();\n                    return {\n                        x: horizontal? target : null,\n                        y: horizontal? null : target\n                    };\n                }\n            }\n            \n            return null;\n        }\n        \n        function resolveTarget(sources, index, propagate) {\n            var source = sources[index];\n            var fill = source.fill;\n            var visited = [index];\n            var target;\n            \n            if (!propagate) {\n                return fill;\n            }\n            \n            while (fill !== false && visited.indexOf(fill) === -1) {\n                if (!isFinite(fill)) {\n                    return fill;\n                }\n                \n                target = sources[fill];\n                if (!target) {\n                    return false;\n                }\n                \n                if (target.visible) {\n                    return fill;\n                }\n                \n                visited.push(fill);\n                fill = target.fill;\n            }\n            \n            return false;\n        }\n        \n        function createMapper(source) {\n            var fill = source.fill;\n            var type = 'dataset';\n            \n            if (fill === false) {\n                return null;\n            }\n            \n            if (!isFinite(fill)) {\n                type = 'boundary';\n            }\n            \n            return mappers[type](source);\n        }\n        \n        function isDrawable(point) {\n            return point && !point.skip;\n        }\n        \n        function drawArea(ctx, curve0, curve1, len0, len1) {\n            var i;\n            \n            if (!len0 || !len1) {\n                return;\n            }\n            \n            // building first area curve (normal)\n            ctx.moveTo(curve0[0].x, curve0[0].y);\n            for (i=1; i<len0; ++i) {\n                helpers.canvas.lineTo(ctx, curve0[i-1], curve0[i]);\n            }\n            \n            // joining the two area curves\n            ctx.lineTo(curve1[len1-1].x, curve1[len1-1].y);\n            \n            // building opposite area curve (reverse)\n            for (i=len1-1; i>0; --i) {\n                helpers.canvas.lineTo(ctx, curve1[i], curve1[i-1], true);\n            }\n        }\n        \n        function doFill(ctx, points, mapper, view, color, loop) {\n            var count = points.length;\n            var span = view.spanGaps;\n            var curve0 = [];\n            var curve1 = [];\n            var len0 = 0;\n            var len1 = 0;\n            var i, ilen, index, p0, p1, d0, d1;\n            \n            ctx.beginPath();\n            \n            for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n                index = i%count;\n                p0 = points[index]._view;\n                p1 = mapper(p0, index, view);\n                d0 = isDrawable(p0);\n                d1 = isDrawable(p1);\n                \n                if (d0 && d1) {\n                    len0 = curve0.push(p0);\n                    len1 = curve1.push(p1);\n                } else if (len0 && len1) {\n                    if (!span) {\n                        drawArea(ctx, curve0, curve1, len0, len1);\n                        len0 = len1 = 0;\n                        curve0 = [];\n                        curve1 = [];\n                    } else {\n                        if (d0) {\n                            curve0.push(p0);\n                        }\n                        if (d1) {\n                            curve1.push(p1);\n                        }\n                    }\n                }\n            }\n            \n            drawArea(ctx, curve0, curve1, len0, len1);\n            \n            ctx.closePath();\n            ctx.fillStyle = color;\n            ctx.fill();\n        }\n        \n        return {\n            id: 'filler',\n            \n            afterDatasetsUpdate: function(chart, options) {\n                var count = (chart.data.datasets || []).length;\n                var propagate = options.propagate;\n                var sources = [];\n                var meta, i, el, source;\n                \n                for (i = 0; i < count; ++i) {\n                    meta = chart.getDatasetMeta(i);\n                    el = meta.dataset;\n                    source = null;\n                    \n                    if (el && el._model && el instanceof Chart.elements.Line) {\n                        source = {\n                            visible: chart.isDatasetVisible(i),\n                            fill: decodeFill(el, i, count),\n                            chart: chart,\n                            el: el\n                        };\n                    }\n                    \n                    meta.$filler = source;\n                    sources.push(source);\n                }\n                \n                for (i=0; i<count; ++i) {\n                    source = sources[i];\n                    if (!source) {\n                        continue;\n                    }\n                    \n                    source.fill = resolveTarget(sources, i, propagate);\n                    source.boundary = computeBoundary(source);\n                    source.mapper = createMapper(source);\n                }\n            },\n            \n            beforeDatasetDraw: function(chart, args) {\n                var meta = args.meta.$filler;\n                if (!meta) {\n                    return;\n                }\n                \n                var el = meta.el;\n                var view = el._view;\n                var points = el._children || [];\n                var mapper = meta.mapper;\n                var color = view.backgroundColor || defaults.global.defaultColor;\n                \n                if (mapper && color && points.length) {\n                    doFill(chart.ctx, points, mapper, view, color, el._loop);\n                }\n            }\n        };\n    };\n    \n},{}],36:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function (Chart) {\n        \n        var helpers = Chart.helpers;\n        var layout = Chart.layoutService;\n        var noop = helpers.noop;\n        \n        Chart.defaults.global.legend = {\n            display:    true,\n            position:   'top',\n            fullWidth:  true,\n            reverse:    false,\n            weight:     1000,\n            paddingTop: 100,\n            \n            // a callback that will handle\n            onClick: function (e, legendItem) {\n                var index = legendItem.datasetIndex;\n                var ci = this.chart;\n                var meta = ci.getDatasetMeta(index);\n                \n                // See controller.isDatasetVisible comment\n                meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n                \n                // We hid a dataset ... rerender the chart\n                ci.update();\n            },\n            \n            onHover: null,\n            \n            labels: {\n                boxWidth:       12,\n                padding:        10,\n                hiddenOpacity:  0.1,\n                // Generates labels shown in the legend\n                // Valid properties to return:\n                // text : text to display\n                // fillStyle : fill of coloured box\n                // strokeStyle: stroke of coloured box\n                // hidden : if this legend item refers to a hidden item\n                // lineCap : cap style for line\n                // lineDash\n                // lineDashOffset :\n                // lineJoin :\n                // lineWidth :\n                generateLabels: function (chart) {\n                    var data = chart.data;\n                    var labels = [];\n                    data.datasets.forEach(function (dataset, i) {\n                        if (dataset.label) {\n                            labels.push({\n                                text:           dataset.label,\n                                fillStyle:      (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n                                hidden:         !chart.isDatasetVisible(i),\n                                lineCap:        dataset.borderCapStyle,\n                                lineDash:       dataset.borderDash,\n                                lineDashOffset: dataset.borderDashOffset,\n                                lineJoin:       dataset.borderJoinStyle,\n                                lineWidth:      dataset.borderWidth,\n                                strokeStyle:    dataset.borderColor,\n                                pointStyle:     dataset.pointStyle,\n                                \n                                // Below is extra data used for toggling the datasets\n                                datasetIndex: i\n                            });\n                        }\n                    }, this);\n                    \n                    return labels;\n                }\n            }\n        };\n        \n        /**\n         * Helper function to get the box width based on the usePointStyle option\n         * @param labelopts {Object} the label options on the legend\n         * @param fontSize {Number} the label font size\n         * @return {Number} width of the color box area\n         */\n        function getBoxWidth(labelOpts, fontSize) {\n            return labelOpts.usePointStyle ?\n                fontSize * Math.SQRT2 :\n                labelOpts.boxWidth;\n        }\n        \n        Chart.Legend = Chart.Element.extend({\n            \n            initialize: function (config) {\n                helpers.extend(this, config);\n                \n                // Contains hit boxes for each dataset (in dataset order)\n                this.legendHitBoxes = [];\n                \n                // Are we in doughnut mode which has a different data type\n                this.doughnutMode = false;\n            },\n            \n            // These methods are ordered by lifecycle. Utilities then follow.\n            // Any function defined here is inherited by all legend types.\n            // Any function can be extended by the legend type\n            \n            beforeUpdate: noop,\n            update:       function (maxWidth, maxHeight, margins) {\n                var me = this;\n                \n                // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n                me.beforeUpdate();\n                \n                // Absorb the master measurements\n                me.maxWidth = maxWidth;\n                me.maxHeight = maxHeight;\n                me.margins = margins;\n                \n                // Dimensions\n                me.beforeSetDimensions();\n                me.setDimensions();\n                me.afterSetDimensions();\n                // Labels\n                me.beforeBuildLabels();\n                me.buildLabels();\n                me.afterBuildLabels();\n                \n                // Fit\n                me.beforeFit();\n                me.fit();\n                me.afterFit();\n                //\n                me.afterUpdate();\n                \n                return me.minSize;\n            },\n            afterUpdate:  noop,\n            \n            //\n            \n            beforeSetDimensions: noop,\n            setDimensions:       function () {\n                var me = this;\n                // Set the unconstrained dimension before label rotation\n                if (me.isHorizontal()) {\n                    // Reset position before calculating rotation\n                    me.width = me.maxWidth;\n                    me.left = 0;\n                    me.right = me.width;\n                } else {\n                    me.height = me.maxHeight;\n                    \n                    // Reset position before calculating rotation\n                    me.top = 0;\n                    me.bottom = me.height;\n                }\n                \n                // Reset padding\n                me.paddingLeft = 0;\n                me.paddingTop = 0;\n                me.paddingRight = 0;\n                me.paddingBottom = 0;\n                \n                // Reset minSize\n                me.minSize = {\n                    width:  0,\n                    height: 0\n                };\n            },\n            afterSetDimensions:  noop,\n            \n            //\n            \n            beforeBuildLabels: noop,\n            buildLabels:       function () {\n                var me = this;\n                var labelOpts = me.options.labels;\n                var legendItems = labelOpts.generateLabels.call(me, me.chart);\n                \n                if (labelOpts.filter) {\n                    legendItems = legendItems.filter(function (item) {\n                        return labelOpts.filter(item, me.chart.data);\n                    });\n                }\n                \n                if (me.options.reverse) {\n                    legendItems.reverse();\n                }\n                \n                me.legendItems = legendItems;\n            },\n            afterBuildLabels:  noop,\n            \n            //\n            \n            beforeFit: noop,\n            fit:       function () {\n                var me = this;\n                var opts = me.options;\n                var labelOpts = opts.labels;\n                var display = opts.display;\n                \n                var ctx = me.ctx;\n                \n                var globalDefault = Chart.defaults.global,\n                    itemOrDefault = helpers.getValueOrDefault,\n                    fontSize      = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n                    fontStyle     = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n                    fontFamily    = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n                    labelFont     = helpers.fontString(fontSize, fontStyle, fontFamily);\n                \n                // Reset hit boxes\n                var hitboxes = me.legendHitBoxes = [];\n                \n                var minSize = me.minSize;\n                var isHorizontal = me.isHorizontal();\n                \n                if (isHorizontal) {\n                    minSize.width = me.maxWidth; // fill all the width\n                    minSize.height = display ? 10 : 0;\n                } else {\n                    minSize.width = display ? 10 : 0;\n                    minSize.height = me.maxHeight; // fill all the height\n                }\n                \n                // Increase sizes here\n                if (display) {\n                    ctx.font = labelFont;\n                    \n                    if (isHorizontal) {\n                        // Labels\n                        \n                        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n                        var lineWidths = me.lineWidths = [0];\n                        var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n                        \n                        ctx.textAlign = 'left';\n                        ctx.textBaseline = 'top';\n                        \n                        helpers.each(me.legendItems, function (legendItem, i) {\n                            var boxWidth = getBoxWidth(labelOpts, fontSize);\n                            var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n                            \n                            if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n                                totalHeight += fontSize + (labelOpts.padding);\n                                lineWidths[lineWidths.length] = me.left;\n                            }\n                            \n                            // Store the hitbox width and height here. Final position will be updated in `draw`\n                            hitboxes[i] = {\n                                left:   0,\n                                top:    0,\n                                width:  width,\n                                height: fontSize\n                            };\n                            \n                            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n                        });\n                        \n                        minSize.height += totalHeight;\n                        \n                    } else {\n                        var vPadding = labelOpts.padding;\n                        var columnWidths = me.columnWidths = [];\n                        var totalWidth = labelOpts.padding;\n                        var currentColWidth = 0;\n                        var currentColHeight = 0;\n                        var itemHeight = fontSize + vPadding;\n                        \n                        helpers.each(me.legendItems, function (legendItem, i) {\n                            var boxWidth = getBoxWidth(labelOpts, fontSize);\n                            var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n                            \n                            // If too tall, go to new column\n                            if (currentColHeight + itemHeight > minSize.height) {\n                                totalWidth += currentColWidth + labelOpts.padding;\n                                columnWidths.push(currentColWidth); // previous column width\n                                \n                                currentColWidth = 0;\n                                currentColHeight = 0;\n                            }\n                            \n                            // Get max width\n                            currentColWidth = Math.max(currentColWidth, itemWidth);\n                            currentColHeight += itemHeight;\n                            \n                            // Store the hitbox width and height here. Final position will be updated in `draw`\n                            hitboxes[i] = {\n                                left:   0,\n                                top:    0,\n                                width:  itemWidth,\n                                height: fontSize\n                            };\n                        });\n                        \n                        totalWidth += currentColWidth;\n                        columnWidths.push(currentColWidth);\n                        minSize.width += totalWidth;\n                    }\n                }\n                \n                me.width = minSize.width;\n                me.height = minSize.height;\n            },\n            afterFit:  noop,\n            \n            // Shared Methods\n            isHorizontal: function () {\n                return this.options.position === 'top' || this.options.position === 'bottom';\n            },\n            \n            // Actually draw the legend on the canvas\n            draw: function () {\n                var me = this;\n                var opts = me.options;\n                var labelOpts = opts.labels;\n                var globalDefault = Chart.defaults.global,\n                    lineDefault   = globalDefault.elements.line,\n                    legendWidth   = me.width,\n                    lineWidths    = me.lineWidths;\n                \n                if (opts.display) {\n                    var ctx           = me.ctx,\n                        cursor,\n                        itemOrDefault = helpers.getValueOrDefault,\n                        fontColor     = itemOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor),\n                        fontSize      = itemOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize),\n                        fontStyle     = itemOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle),\n                        fontFamily    = itemOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily),\n                        labelFont     = helpers.fontString(fontSize, fontStyle, fontFamily);\n                    \n                    // Canvas setup\n                    ctx.textAlign = 'left';\n                    ctx.textBaseline = 'top';\n                    ctx.lineWidth = 0.5;\n                    ctx.strokeStyle = fontColor; // for strikethrough effect\n                    ctx.fillStyle = fontColor; // render in correct colour\n                    ctx.font = labelFont;\n                    \n                    \n                    var boxWidth = getBoxWidth(labelOpts, fontSize),\n                        hitboxes = me.legendHitBoxes;\n                    \n                    // current position\n                    var drawLegendBox = function (x, y, legendItem) {\n                        if (isNaN(boxWidth) || boxWidth <= 0) {\n                            return;\n                        }\n                        \n                        // Set the ctx for the box\n                        ctx.save();\n                        \n                        if (legendItem.hidden) {\n                            ctx.globalAlpha = labelOpts.hiddenOpacity;\n                        }\n                        \n                        ctx.fillStyle = itemOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n                        ctx.strokeStyle = itemOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n                        ctx.lineCap = itemOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n                        ctx.lineDashOffset = itemOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n                        ctx.lineJoin = itemOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n                        ctx.lineWidth = itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n                        \n                        var isLineWidthZero = (itemOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n                        \n                        if (ctx.setLineDash) {\n                            // IE 9 and 10 do not support line dash\n                            ctx.setLineDash(itemOrDefault(legendItem.lineDash, lineDefault.borderDash));\n                        }\n                        \n                        if (opts.labels && opts.labels.usePointStyle) {\n                            // Recalculate x and y for drawPoint() because its expecting\n                            // x and y to be center of figure (instead of top left)\n                            var radius = fontSize * Math.SQRT2 / 2;\n                            var offSet = radius / Math.SQRT2;\n                            var centerX = x + offSet;\n                            var centerY = y + offSet;\n                            \n                            // Draw pointStyle as legend symbol\n                            Chart.canvasHelpers.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n                        } else {\n                            // Draw box as legend symbol\n                            if (!isLineWidthZero) {\n                                ctx.strokeRect(x, y, boxWidth, fontSize);\n                            }\n                            ctx.fillRect(x, y, boxWidth, fontSize);\n                        }\n                        \n                        ctx.restore();\n                    };\n                    var fillText = function (x, y, legendItem, textWidth) {\n                        ctx.fillText(legendItem.text, boxWidth + (fontSize / 2) + x, y);\n                        //if (legendItem.hidden) {\n                        //    // Strikethrough the text if hidden\n                        //    ctx.beginPath();\n                        //    ctx.lineWidth = 1;\n                        //    ctx.moveTo(boxWidth + (fontSize / 2) + x, y + (fontSize / 2));\n                        //    ctx.lineTo(boxWidth + (fontSize / 2) + x + textWidth, y + (fontSize / 2));\n                        //    ctx.stroke();\n                        //}\n                    };\n                    \n                    // Horizontal\n                    var isHorizontal = me.isHorizontal();\n                    if (isHorizontal) {\n                        cursor = {\n                            x:    me.left + ((legendWidth - lineWidths[0]) / 2),\n                            y:    me.top + labelOpts.padding,\n                            line: 0\n                        };\n                    } else {\n                        cursor = {\n                            x:    me.left + labelOpts.padding,\n                            y:    me.top + labelOpts.padding,\n                            line: 0\n                        };\n                    }\n                    \n                    var itemHeight = fontSize + labelOpts.padding;\n                    helpers.each(me.legendItems, function (legendItem, i) {\n                        var textWidth = ctx.measureText(legendItem.text).width,\n                            width     = boxWidth + (fontSize / 2) + textWidth,\n                            x         = cursor.x,\n                            y         = cursor.y;\n                        \n                        if (isHorizontal) {\n                            if (x + width >= legendWidth) {\n                                y = cursor.y += itemHeight;\n                                cursor.line++;\n                                x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n                            }\n                        } else if (y + itemHeight > me.bottom) {\n                            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n                            y = cursor.y = me.top + labelOpts.padding;\n                            cursor.line++;\n                        }\n                        \n                        drawLegendBox(x, y, legendItem);\n                        \n                        hitboxes[i].left = x;\n                        hitboxes[i].top = y;\n                        \n                        // Fill the actual label\n                        fillText(x, y, legendItem, textWidth);\n                        \n                        if (isHorizontal) {\n                            cursor.x += width + (labelOpts.padding);\n                        } else {\n                            cursor.y += itemHeight;\n                        }\n                        \n                    });\n                }\n            },\n            \n            /**\n             * Handle an event\n             * @private\n             * @param {IEvent} event - The event to handle\n             * @return {Boolean} true if a change occured\n             */\n            handleEvent: function (e) {\n                var me = this;\n                var opts = me.options;\n                var type = e.type === 'mouseup' ? 'click' : e.type;\n                var changed = false;\n                \n                if (type === 'mousemove') {\n                    if (!opts.onHover) {\n                        return;\n                    }\n                } else if (type === 'click') {\n                    if (!opts.onClick) {\n                        return;\n                    }\n                } else {\n                    return;\n                }\n                \n                // Chart event already has relative position in it\n                var x = e.x,\n                    y = e.y;\n                \n                if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n                    // See if we are touching one of the dataset boxes\n                    var lh = me.legendHitBoxes;\n                    for (var i = 0; i < lh.length; ++i) {\n                        var hitBox = lh[i];\n                        \n                        if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n                            // Touching an element\n                            if (type === 'click') {\n                                // use e.native for backwards compatibility\n                                opts.onClick.call(me, e.native, me.legendItems[i]);\n                                changed = true;\n                                break;\n                            } else if (type === 'mousemove') {\n                                // use e.native for backwards compatibility\n                                opts.onHover.call(me, e.native, me.legendItems[i]);\n                                changed = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                \n                return changed;\n            }\n        });\n        \n        function createNewLegendAndAttach(chart, legendOpts) {\n            var legend = new Chart.Legend({\n                ctx:     chart.ctx,\n                options: legendOpts,\n                chart:   chart\n            });\n            \n            layout.configure(chart, legend, legendOpts);\n            layout.addBox(chart, legend);\n            chart.legend = legend;\n        }\n        \n        return {\n            id: 'legend',\n            \n            beforeInit: function (chart) {\n                var legendOpts = chart.options.legend;\n                \n                if (legendOpts) {\n                    createNewLegendAndAttach(chart, legendOpts);\n                }\n            },\n            \n            beforeUpdate: function (chart) {\n                var legendOpts = chart.options.legend;\n                var legend = chart.legend;\n                \n                if (legendOpts) {\n                    legendOpts = helpers.configMerge(Chart.defaults.global.legend, legendOpts);\n                    \n                    if (legend) {\n                        layout.configure(chart, legend, legendOpts);\n                        legend.options = legendOpts;\n                    } else {\n                        createNewLegendAndAttach(chart, legendOpts);\n                    }\n                } else if (legend) {\n                    layout.removeBox(chart, legend);\n                    delete chart.legend;\n                }\n            },\n            \n            afterEvent: function (chart, e) {\n                var legend = chart.legend;\n                if (legend) {\n                    legend.handleEvent(e);\n                }\n            }\n        };\n    };\n    \n},{}],37:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        var layout = Chart.layoutService;\n        var noop = helpers.noop;\n        \n        Chart.defaults.global.title = {\n            display: false,\n            position: 'top',\n            fullWidth: true,\n            weight: 2000,        // by default greater than legend (1000) to be above\n            fontStyle: 'bold',\n            padding: 10,\n            \n            // actual title\n            text: ''\n        };\n        \n        Chart.Title = Chart.Element.extend({\n            initialize: function(config) {\n                var me = this;\n                helpers.extend(me, config);\n                \n                // Contains hit boxes for each dataset (in dataset order)\n                me.legendHitBoxes = [];\n            },\n            \n            // These methods are ordered by lifecycle. Utilities then follow.\n            \n            beforeUpdate: noop,\n            update: function(maxWidth, maxHeight, margins) {\n                var me = this;\n                \n                // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n                me.beforeUpdate();\n                \n                // Absorb the master measurements\n                me.maxWidth = maxWidth;\n                me.maxHeight = maxHeight;\n                me.margins = margins;\n                \n                // Dimensions\n                me.beforeSetDimensions();\n                me.setDimensions();\n                me.afterSetDimensions();\n                // Labels\n                me.beforeBuildLabels();\n                me.buildLabels();\n                me.afterBuildLabels();\n                \n                // Fit\n                me.beforeFit();\n                me.fit();\n                me.afterFit();\n                //\n                me.afterUpdate();\n                \n                return me.minSize;\n                \n            },\n            afterUpdate: noop,\n            \n            //\n            \n            beforeSetDimensions: noop,\n            setDimensions: function() {\n                var me = this;\n                // Set the unconstrained dimension before label rotation\n                if (me.isHorizontal()) {\n                    // Reset position before calculating rotation\n                    me.width = me.maxWidth;\n                    me.left = 0;\n                    me.right = me.width;\n                } else {\n                    me.height = me.maxHeight;\n                    \n                    // Reset position before calculating rotation\n                    me.top = 0;\n                    me.bottom = me.height;\n                }\n                \n                // Reset padding\n                me.paddingLeft = 0;\n                me.paddingTop = 0;\n                me.paddingRight = 0;\n                me.paddingBottom = 0;\n                \n                // Reset minSize\n                me.minSize = {\n                    width: 0,\n                    height: 0\n                };\n            },\n            afterSetDimensions: noop,\n            \n            //\n            \n            beforeBuildLabels: noop,\n            buildLabels: noop,\n            afterBuildLabels: noop,\n            \n            //\n            \n            beforeFit: noop,\n            fit: function() {\n                var me = this,\n                    valueOrDefault = helpers.getValueOrDefault,\n                    opts = me.options,\n                    globalDefaults = Chart.defaults.global,\n                    display = opts.display,\n                    fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n                    minSize = me.minSize;\n                \n                if (me.isHorizontal()) {\n                    minSize.width = me.maxWidth; // fill all the width\n                    minSize.height = display ? fontSize + (opts.padding * 2) : 0;\n                } else {\n                    minSize.width = display ? fontSize + (opts.padding * 2) : 0;\n                    minSize.height = me.maxHeight; // fill all the height\n                }\n                \n                me.width = minSize.width;\n                me.height = minSize.height;\n                \n            },\n            afterFit: noop,\n            \n            // Shared Methods\n            isHorizontal: function() {\n                var pos = this.options.position;\n                return pos === 'top' || pos === 'bottom';\n            },\n            \n            // Actually draw the title block on the canvas\n            draw: function() {\n                var me = this,\n                    ctx = me.ctx,\n                    valueOrDefault = helpers.getValueOrDefault,\n                    opts = me.options,\n                    globalDefaults = Chart.defaults.global;\n                \n                if (opts.display) {\n                    var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize),\n                        fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle),\n                        fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily),\n                        titleFont = helpers.fontString(fontSize, fontStyle, fontFamily),\n                        rotation = 0,\n                        titleX,\n                        titleY,\n                        top = me.top,\n                        left = me.left,\n                        bottom = me.bottom,\n                        right = me.right,\n                        maxWidth;\n                    \n                    ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour\n                    ctx.font = titleFont;\n                    \n                    // Horizontal\n                    if (me.isHorizontal()) {\n                        titleX = left + ((right - left) / 2); // midpoint of the width\n                        titleY = top + ((bottom - top) / 2); // midpoint of the height\n                        maxWidth = right - left;\n                    } else {\n                        titleX = opts.position === 'left' ? left + (fontSize / 2) : right - (fontSize / 2);\n                        titleY = top + ((bottom - top) / 2);\n                        maxWidth = bottom - top;\n                        rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n                    }\n                    \n                    ctx.save();\n                    ctx.translate(titleX, titleY);\n                    ctx.rotate(rotation);\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    ctx.fillText(opts.text, 0, 0, maxWidth);\n                    ctx.restore();\n                }\n            }\n        });\n        \n        function createNewTitleBlockAndAttach(chart, titleOpts) {\n            var title = new Chart.Title({\n                ctx: chart.ctx,\n                options: titleOpts,\n                chart: chart\n            });\n            \n            layout.configure(chart, title, titleOpts);\n            layout.addBox(chart, title);\n            chart.titleBlock = title;\n        }\n        \n        return {\n            id: 'title',\n            \n            beforeInit: function(chart) {\n                var titleOpts = chart.options.title;\n                \n                if (titleOpts) {\n                    createNewTitleBlockAndAttach(chart, titleOpts);\n                }\n            },\n            \n            beforeUpdate: function(chart) {\n                var titleOpts = chart.options.title;\n                var titleBlock = chart.titleBlock;\n                \n                if (titleOpts) {\n                    titleOpts = helpers.configMerge(Chart.defaults.global.title, titleOpts);\n                    \n                    if (titleBlock) {\n                        layout.configure(chart, titleBlock, titleOpts);\n                        titleBlock.options = titleOpts;\n                    } else {\n                        createNewTitleBlockAndAttach(chart, titleOpts);\n                    }\n                } else if (titleBlock) {\n                    Chart.layoutService.removeBox(chart, titleBlock);\n                    delete chart.titleBlock;\n                }\n            }\n        };\n    };\n    \n},{}],38:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        // Default config for a category scale\n        var defaultConfig = {\n            position: 'bottom'\n        };\n        \n        var DatasetScale = Chart.Scale.extend({\n            /**\n             * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n             * else fall back to data.labels\n             * @private\n             */\n            getLabels: function() {\n                var data = this.chart.data;\n                return (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n            },\n            \n            determineDataLimits: function() {\n                var me = this;\n                var labels = me.getLabels();\n                me.minIndex = 0;\n                me.maxIndex = labels.length - 1;\n                var findIndex;\n                \n                if (me.options.ticks.min !== undefined) {\n                    // user specified min value\n                    findIndex = helpers.indexOf(labels, me.options.ticks.min);\n                    me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n                }\n                \n                if (me.options.ticks.max !== undefined) {\n                    // user specified max value\n                    findIndex = helpers.indexOf(labels, me.options.ticks.max);\n                    me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n                }\n                \n                me.min = labels[me.minIndex];\n                me.max = labels[me.maxIndex];\n            },\n            \n            buildTicks: function() {\n                var me = this;\n                var labels = me.getLabels();\n                // If we are viewing some subset of labels, slice the original array\n                me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n            },\n            \n            getLabelForIndex: function(index, datasetIndex) {\n                var me = this;\n                var data = me.chart.data;\n                var isHorizontal = me.isHorizontal();\n                \n                if (data.yLabels && !isHorizontal) {\n                    return me.getRightValue(data.datasets[datasetIndex].data[index]);\n                }\n                return me.ticks[index - me.minIndex];\n            },\n            \n            // Used to get data value locations.  Value can either be an index or a numerical value\n            getPixelForValue: function(value, index, datasetIndex, includeOffset) {\n                var me = this;\n                // 1 is added because we need the length but we have the indexes\n                var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n                \n                // If value is a data object, then index is the index in the data array,\n                // not the index of the scale. We need to change that.\n                var valueCategory;\n                if (value !== undefined && value !== null) {\n                    valueCategory = me.isHorizontal() ? value.x : value.y;\n                }\n                if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n                    var labels = me.getLabels();\n                    value = valueCategory || value;\n                    var idx = labels.indexOf(value);\n                    index = idx !== -1 ? idx : index;\n                }\n                \n                if (me.isHorizontal()) {\n                    var valueWidth = me.width / offsetAmt;\n                    var widthOffset = (valueWidth * (index - me.minIndex));\n                    \n                    if (me.options.gridLines.offsetGridLines && includeOffset || me.maxIndex === me.minIndex && includeOffset) {\n                        widthOffset += (valueWidth / 2);\n                    }\n                    \n                    return me.left + Math.round(widthOffset);\n                }\n                var valueHeight = me.height / offsetAmt;\n                var heightOffset = (valueHeight * (index - me.minIndex));\n                \n                if (me.options.gridLines.offsetGridLines && includeOffset) {\n                    heightOffset += (valueHeight / 2);\n                }\n                \n                return me.top + Math.round(heightOffset);\n            },\n            getPixelForTick: function(index, includeOffset) {\n                return this.getPixelForValue(this.ticks[index], index + this.minIndex, null, includeOffset);\n            },\n            getValueForPixel: function(pixel) {\n                var me = this;\n                var value;\n                var offsetAmt = Math.max((me.ticks.length - ((me.options.gridLines.offsetGridLines) ? 0 : 1)), 1);\n                var horz = me.isHorizontal();\n                var valueDimension = (horz ? me.width : me.height) / offsetAmt;\n                \n                pixel -= horz ? me.left : me.top;\n                \n                if (me.options.gridLines.offsetGridLines) {\n                    pixel -= (valueDimension / 2);\n                }\n                \n                if (pixel <= 0) {\n                    value = 0;\n                } else {\n                    value = Math.round(pixel / valueDimension);\n                }\n                \n                return value;\n            },\n            getBasePixel: function() {\n                return this.bottom;\n            }\n        });\n        \n        Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);\n        \n    };\n    \n},{}],39:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        var defaultConfig = {\n            position: 'left',\n            ticks: {\n                callback: Chart.Ticks.formatters.linear\n            }\n        };\n        \n        var LinearScale = Chart.LinearScaleBase.extend({\n            \n            determineDataLimits: function() {\n                var me = this;\n                var opts = me.options;\n                var chart = me.chart;\n                var data = chart.data;\n                var datasets = data.datasets;\n                var isHorizontal = me.isHorizontal();\n                var DEFAULT_MIN = 0;\n                var DEFAULT_MAX = 1;\n                \n                function IDMatches(meta) {\n                    return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n                }\n                \n                // First Calculate the range\n                me.min = null;\n                me.max = null;\n                \n                var hasStacks = opts.stacked;\n                if (hasStacks === undefined) {\n                    helpers.each(datasets, function(dataset, datasetIndex) {\n                        if (hasStacks) {\n                            return;\n                        }\n                        \n                        var meta = chart.getDatasetMeta(datasetIndex);\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n                            meta.stack !== undefined) {\n                            hasStacks = true;\n                        }\n                    });\n                }\n                \n                if (opts.stacked || hasStacks) {\n                    var valuesPerStack = {};\n                    \n                    helpers.each(datasets, function(dataset, datasetIndex) {\n                        var meta = chart.getDatasetMeta(datasetIndex);\n                        var key = [\n                            meta.type,\n                            // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n                            ((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n                            meta.stack\n                        ].join('.');\n                        \n                        if (valuesPerStack[key] === undefined) {\n                            valuesPerStack[key] = {\n                                positiveValues: [],\n                                negativeValues: []\n                            };\n                        }\n                        \n                        // Store these per type\n                        var positiveValues = valuesPerStack[key].positiveValues;\n                        var negativeValues = valuesPerStack[key].negativeValues;\n                        \n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                            helpers.each(dataset.data, function(rawValue, index) {\n                                var value = +me.getRightValue(rawValue);\n                                if (isNaN(value) || meta.data[index].hidden) {\n                                    return;\n                                }\n                                \n                                positiveValues[index] = positiveValues[index] || 0;\n                                negativeValues[index] = negativeValues[index] || 0;\n                                \n                                if (opts.relativePoints) {\n                                    positiveValues[index] = 100;\n                                } else if (value < 0) {\n                                    negativeValues[index] += value;\n                                } else {\n                                    positiveValues[index] += value;\n                                }\n                            });\n                        }\n                    });\n                    \n                    helpers.each(valuesPerStack, function(valuesForType) {\n                        var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n                        var minVal = helpers.min(values);\n                        var maxVal = helpers.max(values);\n                        me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n                        me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n                    });\n                    \n                } else {\n                    helpers.each(datasets, function(dataset, datasetIndex) {\n                        var meta = chart.getDatasetMeta(datasetIndex);\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                            helpers.each(dataset.data, function(rawValue, index) {\n                                var value = +me.getRightValue(rawValue);\n                                if (isNaN(value) || meta.data[index].hidden) {\n                                    return;\n                                }\n                                \n                                if (me.min === null) {\n                                    me.min = value;\n                                } else if (value < me.min) {\n                                    me.min = value;\n                                }\n                                \n                                if (me.max === null) {\n                                    me.max = value;\n                                } else if (value > me.max) {\n                                    me.max = value;\n                                }\n                            });\n                        }\n                    });\n                }\n                \n                me.min = isFinite(me.min) ? me.min : DEFAULT_MIN;\n                me.max = isFinite(me.max) ? me.max : DEFAULT_MAX;\n                \n                // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n                this.handleTickRangeOptions();\n            },\n            getTickLimit: function() {\n                var maxTicks;\n                var me = this;\n                var tickOpts = me.options.ticks;\n                \n                if (me.isHorizontal()) {\n                    maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));\n                } else {\n                    // The factor of 2 used to scale the font size has been experimentally determined.\n                    var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, Chart.defaults.global.defaultFontSize);\n                    maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));\n                }\n                \n                return maxTicks;\n            },\n            // Called after the ticks are built. We need\n            handleDirectionalChanges: function() {\n                if (!this.isHorizontal()) {\n                    // We are in a vertical orientation. The top value is the highest. So reverse the array\n                    this.ticks.reverse();\n                }\n            },\n            getLabelForIndex: function(index, datasetIndex) {\n                return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n            },\n            // Utils\n            getPixelForValue: function(value) {\n                // This must be called after fit has been run so that\n                // this.left, this.top, this.right, and this.bottom have been defined\n                var me = this;\n                var start = me.start;\n                \n                var rightValue = +me.getRightValue(value);\n                var pixel;\n                var range = me.end - start;\n                \n                if (me.isHorizontal()) {\n                    pixel = me.left + (me.width / range * (rightValue - start));\n                    return Math.round(pixel);\n                }\n                \n                pixel = me.bottom - (me.height / range * (rightValue - start));\n                return Math.round(pixel);\n            },\n            getValueForPixel: function(pixel) {\n                var me = this;\n                var isHorizontal = me.isHorizontal();\n                var innerDimension = isHorizontal ? me.width : me.height;\n                var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n                return me.start + ((me.end - me.start) * offset);\n            },\n            getPixelForTick: function(index) {\n                return this.getPixelForValue(this.ticksAsNumbers[index]);\n            }\n        });\n        Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);\n        \n    };\n    \n},{}],40:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers,\n            noop = helpers.noop;\n        \n        Chart.LinearScaleBase = Chart.Scale.extend({\n            handleTickRangeOptions: function() {\n                var me = this;\n                var opts = me.options;\n                var tickOpts = opts.ticks;\n                \n                // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n                // do nothing since that would make the chart weird. If the user really wants a weird chart\n                // axis, they can manually override it\n                if (tickOpts.beginAtZero) {\n                    var minSign = helpers.sign(me.min);\n                    var maxSign = helpers.sign(me.max);\n                    \n                    if (minSign < 0 && maxSign < 0) {\n                        // move the top up to 0\n                        me.max = 0;\n                    } else if (minSign > 0 && maxSign > 0) {\n                        // move the bottom down to 0\n                        me.min = 0;\n                    }\n                }\n                \n                if (tickOpts.min !== undefined) {\n                    me.min = tickOpts.min;\n                } else if (tickOpts.suggestedMin !== undefined) {\n                    if (me.min === null) {\n                        me.min = tickOpts.suggestedMin;\n                    } else {\n                        me.min = Math.min(me.min, tickOpts.suggestedMin);\n                    }\n                }\n                \n                if (tickOpts.max !== undefined) {\n                    me.max = tickOpts.max;\n                } else if (tickOpts.suggestedMax !== undefined) {\n                    if (me.max === null) {\n                        me.max = tickOpts.suggestedMax;\n                    } else {\n                        me.max = Math.max(me.max, tickOpts.suggestedMax);\n                    }\n                }\n                \n                if (me.min === me.max) {\n                    me.max++;\n                    \n                    if (!tickOpts.beginAtZero) {\n                        me.min--;\n                    }\n                }\n            },\n            getTickLimit: noop,\n            handleDirectionalChanges: noop,\n            \n            buildTicks: function() {\n                var me = this;\n                var opts = me.options;\n                var tickOpts = opts.ticks;\n                \n                // Figure out what the max number of ticks we can support it is based on the size of\n                // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n                // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n                // the graph. Make sure we always have at least 2 ticks\n                var maxTicks = me.getTickLimit();\n                maxTicks = Math.max(2, maxTicks);\n                \n                var numericGeneratorOptions = {\n                    maxTicks: maxTicks,\n                    min: tickOpts.min,\n                    max: tickOpts.max,\n                    stepSize: helpers.getValueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n                };\n                var ticks = me.ticks = Chart.Ticks.generators.linear(numericGeneratorOptions, me);\n                \n                me.handleDirectionalChanges();\n                \n                // At this point, we need to update our max and min given the tick values since we have expanded the\n                // range of the scale\n                me.max = helpers.max(ticks);\n                me.min = helpers.min(ticks);\n                \n                if (tickOpts.reverse) {\n                    ticks.reverse();\n                    \n                    me.start = me.max;\n                    me.end = me.min;\n                } else {\n                    me.start = me.min;\n                    me.end = me.max;\n                }\n            },\n            convertTicksToLabels: function() {\n                var me = this;\n                me.ticksAsNumbers = me.ticks.slice();\n                me.zeroLineIndex = me.ticks.indexOf(0);\n                \n                Chart.Scale.prototype.convertTicksToLabels.call(me);\n            }\n        });\n    };\n    \n},{}],41:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        \n        var defaultConfig = {\n            position: 'left',\n            \n            // label settings\n            ticks: {\n                callback: Chart.Ticks.formatters.logarithmic\n            }\n        };\n        \n        var LogarithmicScale = Chart.Scale.extend({\n            determineDataLimits: function() {\n                var me = this;\n                var opts = me.options;\n                var tickOpts = opts.ticks;\n                var chart = me.chart;\n                var data = chart.data;\n                var datasets = data.datasets;\n                var getValueOrDefault = helpers.getValueOrDefault;\n                var isHorizontal = me.isHorizontal();\n                function IDMatches(meta) {\n                    return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n                }\n                \n                // Calculate Range\n                me.min = null;\n                me.max = null;\n                me.minNotZero = null;\n                \n                var hasStacks = opts.stacked;\n                if (hasStacks === undefined) {\n                    helpers.each(datasets, function(dataset, datasetIndex) {\n                        if (hasStacks) {\n                            return;\n                        }\n                        \n                        var meta = chart.getDatasetMeta(datasetIndex);\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n                            meta.stack !== undefined) {\n                            hasStacks = true;\n                        }\n                    });\n                }\n                \n                if (opts.stacked || hasStacks) {\n                    var valuesPerStack = {};\n                    \n                    helpers.each(datasets, function(dataset, datasetIndex) {\n                        var meta = chart.getDatasetMeta(datasetIndex);\n                        var key = [\n                            meta.type,\n                            // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n                            ((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n                            meta.stack\n                        ].join('.');\n                        \n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                            if (valuesPerStack[key] === undefined) {\n                                valuesPerStack[key] = [];\n                            }\n                            \n                            helpers.each(dataset.data, function(rawValue, index) {\n                                var values = valuesPerStack[key];\n                                var value = +me.getRightValue(rawValue);\n                                if (isNaN(value) || meta.data[index].hidden) {\n                                    return;\n                                }\n                                \n                                values[index] = values[index] || 0;\n                                \n                                if (opts.relativePoints) {\n                                    values[index] = 100;\n                                } else {\n                                    // Don't need to split positive and negative since the log scale can't handle a 0 crossing\n                                    values[index] += value;\n                                }\n                            });\n                        }\n                    });\n                    \n                    helpers.each(valuesPerStack, function(valuesForType) {\n                        var minVal = helpers.min(valuesForType);\n                        var maxVal = helpers.max(valuesForType);\n                        me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n                        me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n                    });\n                    \n                } else {\n                    helpers.each(datasets, function(dataset, datasetIndex) {\n                        var meta = chart.getDatasetMeta(datasetIndex);\n                        if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n                            helpers.each(dataset.data, function(rawValue, index) {\n                                var value = +me.getRightValue(rawValue);\n                                if (isNaN(value) || meta.data[index].hidden) {\n                                    return;\n                                }\n                                \n                                if (me.min === null) {\n                                    me.min = value;\n                                } else if (value < me.min) {\n                                    me.min = value;\n                                }\n                                \n                                if (me.max === null) {\n                                    me.max = value;\n                                } else if (value > me.max) {\n                                    me.max = value;\n                                }\n                                \n                                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n                                    me.minNotZero = value;\n                                }\n                            });\n                        }\n                    });\n                }\n                \n                me.min = getValueOrDefault(tickOpts.min, me.min);\n                me.max = getValueOrDefault(tickOpts.max, me.max);\n                \n                if (me.min === me.max) {\n                    if (me.min !== 0 && me.min !== null) {\n                        me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n                        me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n                    } else {\n                        me.min = 1;\n                        me.max = 10;\n                    }\n                }\n            },\n            buildTicks: function() {\n                var me = this;\n                var opts = me.options;\n                var tickOpts = opts.ticks;\n                \n                var generationOptions = {\n                    min: tickOpts.min,\n                    max: tickOpts.max\n                };\n                var ticks = me.ticks = Chart.Ticks.generators.logarithmic(generationOptions, me);\n                \n                if (!me.isHorizontal()) {\n                    // We are in a vertical orientation. The top value is the highest. So reverse the array\n                    ticks.reverse();\n                }\n                \n                // At this point, we need to update our max and min given the tick values since we have expanded the\n                // range of the scale\n                me.max = helpers.max(ticks);\n                me.min = helpers.min(ticks);\n                \n                if (tickOpts.reverse) {\n                    ticks.reverse();\n                    \n                    me.start = me.max;\n                    me.end = me.min;\n                } else {\n                    me.start = me.min;\n                    me.end = me.max;\n                }\n            },\n            convertTicksToLabels: function() {\n                this.tickValues = this.ticks.slice();\n                \n                Chart.Scale.prototype.convertTicksToLabels.call(this);\n            },\n            // Get the correct tooltip label\n            getLabelForIndex: function(index, datasetIndex) {\n                return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n            },\n            getPixelForTick: function(index) {\n                return this.getPixelForValue(this.tickValues[index]);\n            },\n            getPixelForValue: function(value) {\n                var me = this;\n                var innerDimension;\n                var pixel;\n                \n                var start = me.start;\n                var newVal = +me.getRightValue(value);\n                var range;\n                var opts = me.options;\n                var tickOpts = opts.ticks;\n                \n                if (me.isHorizontal()) {\n                    range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n                    if (newVal === 0) {\n                        pixel = me.left;\n                    } else {\n                        innerDimension = me.width;\n                        pixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n                    }\n                } else {\n                    // Bottom - top since pixels increase downward on a screen\n                    innerDimension = me.height;\n                    if (start === 0 && !tickOpts.reverse) {\n                        range = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n                        if (newVal === start) {\n                            pixel = me.bottom;\n                        } else if (newVal === me.minNotZero) {\n                            pixel = me.bottom - innerDimension * 0.02;\n                        } else {\n                            pixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n                        }\n                    } else if (me.end === 0 && tickOpts.reverse) {\n                        range = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n                        if (newVal === me.end) {\n                            pixel = me.top;\n                        } else if (newVal === me.minNotZero) {\n                            pixel = me.top + innerDimension * 0.02;\n                        } else {\n                            pixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98/ range * (helpers.log10(newVal)-helpers.log10(me.minNotZero)));\n                        }\n                    } else if (newVal === 0) {\n                        pixel = tickOpts.reverse ? me.top : me.bottom;\n                    } else {\n                        range = helpers.log10(me.end) - helpers.log10(start);\n                        innerDimension = me.height;\n                        pixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n                    }\n                }\n                return pixel;\n            },\n            getValueForPixel: function(pixel) {\n                var me = this;\n                var range = helpers.log10(me.end) - helpers.log10(me.start);\n                var value, innerDimension;\n                \n                if (me.isHorizontal()) {\n                    innerDimension = me.width;\n                    value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n                } else {  // todo: if start === 0\n                    innerDimension = me.height;\n                    value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n                }\n                return value;\n            }\n        });\n        Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n        \n    };\n    \n},{}],42:[function(require,module,exports){\n    'use strict';\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        var globalDefaults = Chart.defaults.global;\n        \n        var defaultConfig = {\n            display: true,\n            \n            // Boolean - Whether to animate scaling the chart from the centre\n            animate: true,\n            position: 'chartArea',\n            \n            angleLines: {\n                display: true,\n                color: 'rgba(0, 0, 0, 0.1)',\n                lineWidth: 1\n            },\n            \n            gridLines: {\n                circular: false\n            },\n            \n            // label settings\n            ticks: {\n                // Boolean - Show a backdrop to the scale label\n                showLabelBackdrop: true,\n                \n                // String - The colour of the label backdrop\n                backdropColor: 'rgba(255,255,255,0.75)',\n                \n                // Number - The backdrop padding above & below the label in pixels\n                backdropPaddingY: 2,\n                \n                // Number - The backdrop padding to the side of the label in pixels\n                backdropPaddingX: 2,\n                \n                callback: Chart.Ticks.formatters.linear\n            },\n            \n            pointLabels: {\n                // Boolean - if true, show point labels\n                display: true,\n                \n                // Number - Point label font size in pixels\n                fontSize: 10,\n                \n                // Function - Used to convert point labels\n                callback: function(label) {\n                    return label;\n                }\n            }\n        };\n        \n        function getValueCount(scale) {\n            var opts = scale.options;\n            return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n        }\n        \n        function getPointLabelFontOptions(scale) {\n            var pointLabelOptions = scale.options.pointLabels;\n            var fontSize = helpers.getValueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);\n            var fontStyle = helpers.getValueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);\n            var fontFamily = helpers.getValueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);\n            var font = helpers.fontString(fontSize, fontStyle, fontFamily);\n            \n            return {\n                size: fontSize,\n                style: fontStyle,\n                family: fontFamily,\n                font: font\n            };\n        }\n        \n        function measureLabelSize(ctx, fontSize, label) {\n            if (helpers.isArray(label)) {\n                return {\n                    w: helpers.longestText(ctx, ctx.font, label),\n                    h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)\n                };\n            }\n            \n            return {\n                w: ctx.measureText(label).width,\n                h: fontSize\n            };\n        }\n        \n        function determineLimits(angle, pos, size, min, max) {\n            if (angle === min || angle === max) {\n                return {\n                    start: pos - (size / 2),\n                    end: pos + (size / 2)\n                };\n            } else if (angle < min || angle > max) {\n                return {\n                    start: pos - size - 5,\n                    end: pos\n                };\n            }\n            \n            return {\n                start: pos,\n                end: pos + size + 5\n            };\n        }\n        \n        /**\n         * Helper function to fit a radial linear scale with point labels\n         */\n        function fitWithPointLabels(scale) {\n            /*\n             * Right, this is really confusing and there is a lot of maths going on here\n             * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n             *\n             * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n             *\n             * Solution:\n             *\n             * We assume the radius of the polygon is half the size of the canvas at first\n             * at each index we check if the text overlaps.\n             *\n             * Where it does, we store that angle and that index.\n             *\n             * After finding the largest index and angle we calculate how much we need to remove\n             * from the shape radius to move the point inwards by that x.\n             *\n             * We average the left and right distances to get the maximum shape radius that can fit in the box\n             * along with labels.\n             *\n             * Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n             * on each side, removing that from the size, halving it and adding the left x protrusion width.\n             *\n             * This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n             * and position it in the most space efficient manner\n             *\n             * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n             */\n            \n            var plFont = getPointLabelFontOptions(scale);\n            \n            // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n            // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n            var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n            var furthestLimits = {\n                r: scale.width,\n                l: 0,\n                t: scale.height,\n                b: 0\n            };\n            var furthestAngles = {};\n            var i;\n            var textSize;\n            var pointPosition;\n            \n            scale.ctx.font = plFont.font;\n            scale._pointLabelSizes = [];\n            \n            var valueCount = getValueCount(scale);\n            for (i = 0; i < valueCount; i++) {\n                pointPosition = scale.getPointPosition(i, largestPossibleRadius);\n                textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');\n                scale._pointLabelSizes[i] = textSize;\n                \n                // Add quarter circle to make degree 0 mean top of circle\n                var angleRadians = scale.getIndexAngle(i);\n                var angle = helpers.toDegrees(angleRadians) % 360;\n                var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n                var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n                \n                if (hLimits.start < furthestLimits.l) {\n                    furthestLimits.l = hLimits.start;\n                    furthestAngles.l = angleRadians;\n                }\n                \n                if (hLimits.end > furthestLimits.r) {\n                    furthestLimits.r = hLimits.end;\n                    furthestAngles.r = angleRadians;\n                }\n                \n                if (vLimits.start < furthestLimits.t) {\n                    furthestLimits.t = vLimits.start;\n                    furthestAngles.t = angleRadians;\n                }\n                \n                if (vLimits.end > furthestLimits.b) {\n                    furthestLimits.b = vLimits.end;\n                    furthestAngles.b = angleRadians;\n                }\n            }\n            \n            scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);\n        }\n        \n        /**\n         * Helper function to fit a radial linear scale with no point labels\n         */\n        function fit(scale) {\n            var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);\n            scale.drawingArea = Math.round(largestPossibleRadius);\n            scale.setCenterPoint(0, 0, 0, 0);\n        }\n        \n        function getTextAlignForAngle(angle) {\n            if (angle === 0 || angle === 180) {\n                return 'center';\n            } else if (angle < 180) {\n                return 'left';\n            }\n            \n            return 'right';\n        }\n        \n        function fillText(ctx, text, position, fontSize) {\n            if (helpers.isArray(text)) {\n                var y = position.y;\n                var spacing = 1.5 * fontSize;\n                \n                for (var i = 0; i < text.length; ++i) {\n                    ctx.fillText(text[i], position.x, y);\n                    y+= spacing;\n                }\n            } else {\n                ctx.fillText(text, position.x, position.y);\n            }\n        }\n        \n        function adjustPointPositionForLabelHeight(angle, textSize, position) {\n            if (angle === 90 || angle === 270) {\n                position.y -= (textSize.h / 2);\n            } else if (angle > 270 || angle < 90) {\n                position.y -= textSize.h;\n            }\n        }\n        \n        function drawPointLabels(scale) {\n            var ctx = scale.ctx;\n            var getValueOrDefault = helpers.getValueOrDefault;\n            var opts = scale.options;\n            var angleLineOpts = opts.angleLines;\n            var pointLabelOpts = opts.pointLabels;\n            \n            ctx.lineWidth = angleLineOpts.lineWidth;\n            ctx.strokeStyle = angleLineOpts.color;\n            \n            var outerDistance = scale.getDistanceFromCenterForValue(opts.reverse ? scale.min : scale.max);\n            \n            // Point Label Font\n            var plFont = getPointLabelFontOptions(scale);\n            \n            ctx.textBaseline = 'top';\n            \n            for (var i = getValueCount(scale) - 1; i >= 0; i--) {\n                if (angleLineOpts.display) {\n                    var outerPosition = scale.getPointPosition(i, outerDistance);\n                    ctx.beginPath();\n                    ctx.moveTo(scale.xCenter, scale.yCenter);\n                    ctx.lineTo(outerPosition.x, outerPosition.y);\n                    ctx.stroke();\n                    ctx.closePath();\n                }\n                \n                if (pointLabelOpts.display) {\n                    // Extra 3px out for some label spacing\n                    var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);\n                    \n                    // Keep this in loop since we may support array properties here\n                    var pointLabelFontColor = getValueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);\n                    ctx.font = plFont.font;\n                    ctx.fillStyle = pointLabelFontColor;\n                    \n                    var angleRadians = scale.getIndexAngle(i);\n                    var angle = helpers.toDegrees(angleRadians);\n                    ctx.textAlign = getTextAlignForAngle(angle);\n                    adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n                    fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);\n                }\n            }\n        }\n        \n        function drawRadiusLine(scale, gridLineOpts, radius, index) {\n            var ctx = scale.ctx;\n            ctx.strokeStyle = helpers.getValueAtIndexOrDefault(gridLineOpts.color, index - 1);\n            ctx.lineWidth = helpers.getValueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);\n            \n            if (scale.options.gridLines.circular) {\n                // Draw circular arcs between the points\n                ctx.beginPath();\n                ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n                ctx.closePath();\n                ctx.stroke();\n            } else {\n                // Draw straight lines connecting each index\n                var valueCount = getValueCount(scale);\n                \n                if (valueCount === 0) {\n                    return;\n                }\n                \n                ctx.beginPath();\n                var pointPosition = scale.getPointPosition(0, radius);\n                ctx.moveTo(pointPosition.x, pointPosition.y);\n                \n                for (var i = 1; i < valueCount; i++) {\n                    pointPosition = scale.getPointPosition(i, radius);\n                    ctx.lineTo(pointPosition.x, pointPosition.y);\n                }\n                \n                ctx.closePath();\n                ctx.stroke();\n            }\n        }\n        \n        function numberOrZero(param) {\n            return helpers.isNumber(param) ? param : 0;\n        }\n        \n        var LinearRadialScale = Chart.LinearScaleBase.extend({\n            setDimensions: function() {\n                var me = this;\n                var opts = me.options;\n                var tickOpts = opts.ticks;\n                // Set the unconstrained dimension before label rotation\n                me.width = me.maxWidth;\n                me.height = me.maxHeight;\n                me.xCenter = Math.round(me.width / 2);\n                me.yCenter = Math.round(me.height / 2);\n                \n                var minSize = helpers.min([me.height, me.width]);\n                var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n                me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);\n            },\n            determineDataLimits: function() {\n                var me = this;\n                var chart = me.chart;\n                var min = Number.POSITIVE_INFINITY;\n                var max = Number.NEGATIVE_INFINITY;\n                \n                helpers.each(chart.data.datasets, function(dataset, datasetIndex) {\n                    if (chart.isDatasetVisible(datasetIndex)) {\n                        var meta = chart.getDatasetMeta(datasetIndex);\n                        \n                        helpers.each(dataset.data, function(rawValue, index) {\n                            var value = +me.getRightValue(rawValue);\n                            if (isNaN(value) || meta.data[index].hidden) {\n                                return;\n                            }\n                            \n                            min = Math.min(value, min);\n                            max = Math.max(value, max);\n                        });\n                    }\n                });\n                \n                me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n                me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n                \n                // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n                me.handleTickRangeOptions();\n            },\n            getTickLimit: function() {\n                var tickOpts = this.options.ticks;\n                var tickFontSize = helpers.getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n                return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));\n            },\n            convertTicksToLabels: function() {\n                var me = this;\n                Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);\n                \n                // Point labels\n                me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n            },\n            getLabelForIndex: function(index, datasetIndex) {\n                return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n            },\n            fit: function() {\n                if (this.options.pointLabels.display) {\n                    fitWithPointLabels(this);\n                } else {\n                    fit(this);\n                }\n            },\n            /**\n             * Set radius reductions and determine new radius and center point\n             * @private\n             */\n            setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n                var me = this;\n                var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n                var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n                var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n                var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);\n                \n                radiusReductionLeft = numberOrZero(radiusReductionLeft);\n                radiusReductionRight = numberOrZero(radiusReductionRight);\n                radiusReductionTop = numberOrZero(radiusReductionTop);\n                radiusReductionBottom = numberOrZero(radiusReductionBottom);\n                \n                me.drawingArea = Math.min(\n                    Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n                    Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n                me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n            },\n            setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n                var me = this;\n                var maxRight = me.width - rightMovement - me.drawingArea,\n                    maxLeft = leftMovement + me.drawingArea,\n                    maxTop = topMovement + me.drawingArea,\n                    maxBottom = me.height - bottomMovement - me.drawingArea;\n                \n                me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);\n                me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);\n            },\n            \n            getIndexAngle: function(index) {\n                var angleMultiplier = (Math.PI * 2) / getValueCount(this);\n                var startAngle = this.chart.options && this.chart.options.startAngle ?\n                    this.chart.options.startAngle :\n                    0;\n                \n                var startAngleRadians = startAngle * Math.PI * 2 / 360;\n                \n                // Start from the top instead of right, so remove a quarter of the circle\n                return index * angleMultiplier + startAngleRadians;\n            },\n            getDistanceFromCenterForValue: function(value) {\n                var me = this;\n                \n                if (value === null) {\n                    return 0; // null always in center\n                }\n                \n                // Take into account half font size + the yPadding of the top value\n                var scalingFactor = me.drawingArea / (me.max - me.min);\n                if (me.options.reverse) {\n                    return (me.max - value) * scalingFactor;\n                }\n                return (value - me.min) * scalingFactor;\n            },\n            getPointPosition: function(index, distanceFromCenter) {\n                var me = this;\n                var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n                return {\n                    x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,\n                    y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter\n                };\n            },\n            getPointPositionForValue: function(index, value) {\n                return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n            },\n            \n            getBasePosition: function() {\n                var me = this;\n                var min = me.min;\n                var max = me.max;\n                \n                return me.getPointPositionForValue(0,\n                    me.beginAtZero? 0:\n                        min < 0 && max < 0? max :\n                            min > 0 && max > 0? min :\n                                0);\n            },\n            \n            draw: function() {\n                var me = this;\n                var opts = me.options;\n                var gridLineOpts = opts.gridLines;\n                var tickOpts = opts.ticks;\n                var getValueOrDefault = helpers.getValueOrDefault;\n                \n                if (opts.display) {\n                    var ctx = me.ctx;\n                    \n                    // Tick Font\n                    var tickFontSize = getValueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);\n                    var tickFontStyle = getValueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);\n                    var tickFontFamily = getValueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);\n                    var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);\n                    \n                    helpers.each(me.ticks, function(label, index) {\n                        // Don't draw a centre value (if it is minimum)\n                        if (index > 0 || opts.reverse) {\n                            var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n                            var yHeight = me.yCenter - yCenterOffset;\n                            \n                            // Draw circular lines around the scale\n                            if (gridLineOpts.display && index !== 0) {\n                                drawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n                            }\n                            \n                            if (tickOpts.display) {\n                                var tickFontColor = getValueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);\n                                ctx.font = tickLabelFont;\n                                \n                                if (tickOpts.showLabelBackdrop) {\n                                    var labelWidth = ctx.measureText(label).width;\n                                    ctx.fillStyle = tickOpts.backdropColor;\n                                    ctx.fillRect(\n                                        me.xCenter - labelWidth / 2 - tickOpts.backdropPaddingX,\n                                        yHeight - tickFontSize / 2 - tickOpts.backdropPaddingY,\n                                        labelWidth + tickOpts.backdropPaddingX * 2,\n                                        tickFontSize + tickOpts.backdropPaddingY * 2\n                                    );\n                                }\n                                \n                                ctx.textAlign = 'center';\n                                ctx.textBaseline = 'middle';\n                                ctx.fillStyle = tickFontColor;\n                                ctx.fillText(label, me.xCenter, yHeight);\n                            }\n                        }\n                    });\n                    \n                    if (opts.angleLines.display || opts.pointLabels.display) {\n                        drawPointLabels(me);\n                    }\n                }\n            }\n        });\n        Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);\n        \n    };\n    \n},{}],43:[function(require,module,exports){\n    /* global window: false */\n    'use strict';\n    \n    var moment = require(44);\n    moment = typeof(moment) === 'function' ? moment : window.moment;\n    \n    module.exports = function(Chart) {\n        \n        var helpers = Chart.helpers;\n        var interval = {\n            millisecond: {\n                size: 1,\n                steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n            },\n            second: {\n                size: 1000,\n                steps: [1, 2, 5, 10, 30]\n            },\n            minute: {\n                size: 60000,\n                steps: [1, 2, 5, 10, 30]\n            },\n            hour: {\n                size: 3600000,\n                steps: [1, 2, 3, 6, 12]\n            },\n            day: {\n                size: 86400000,\n                steps: [1, 2, 5]\n            },\n            week: {\n                size: 604800000,\n                maxStep: 4\n            },\n            month: {\n                size: 2.628e9,\n                maxStep: 3\n            },\n            quarter: {\n                size: 7.884e9,\n                maxStep: 4\n            },\n            year: {\n                size: 3.154e10,\n                maxStep: false\n            }\n        };\n        \n        var defaultConfig = {\n            position: 'bottom',\n            \n            time: {\n                parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n                format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n                unit: false, // false == automatic or override with week, month, year, etc.\n                round: false, // none, or override with week, month, year, etc.\n                displayFormat: false, // DEPRECATED\n                isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n                minUnit: 'millisecond',\n                \n                // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n                displayFormats: {\n                    millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n                    second: 'h:mm:ss a', // 11:20:01 AM\n                    minute: 'h:mm:ss a', // 11:20:01 AM\n                    hour: 'MMM D, hA', // Sept 4, 5PM\n                    day: 'll', // Sep 4 2015\n                    week: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n                    month: 'MMM YYYY', // Sept 2015\n                    quarter: '[Q]Q - YYYY', // Q3\n                    year: 'YYYY' // 2015\n                },\n            },\n            ticks: {\n                autoSkip: false\n            }\n        };\n        \n        /**\n         * Helper function to parse time to a moment object\n         * @param axis {TimeAxis} the time axis\n         * @param label {Date|string|number|Moment} The thing to parse\n         * @return {Moment} parsed time\n         */\n        function parseTime(axis, label) {\n            var timeOpts = axis.options.time;\n            if (typeof timeOpts.parser === 'string') {\n                return moment(label, timeOpts.parser);\n            }\n            if (typeof timeOpts.parser === 'function') {\n                return timeOpts.parser(label);\n            }\n            if (typeof label.getMonth === 'function' || typeof label === 'number') {\n                // Date objects\n                return moment(label);\n            }\n            if (label.isValid && label.isValid()) {\n                // Moment support\n                return label;\n            }\n            var format = timeOpts.format;\n            if (typeof format !== 'string' && format.call) {\n                // Custom parsing (return an instance of moment)\n                console.warn('options.time.format is deprecated and replaced by options.time.parser.');\n                return format(label);\n            }\n            // Moment format parsing\n            return moment(label, format);\n        }\n        \n        /**\n         * Figure out which is the best unit for the scale\n         * @param minUnit {String} minimum unit to use\n         * @param min {Number} scale minimum\n         * @param max {Number} scale maximum\n         * @return {String} the unit to use\n         */\n        function determineUnit(minUnit, min, max, maxTicks) {\n            var units = Object.keys(interval);\n            var unit;\n            var numUnits = units.length;\n            \n            for (var i = units.indexOf(minUnit); i < numUnits; i++) {\n                unit = units[i];\n                var unitDetails = interval[unit];\n                var steps = (unitDetails.steps && unitDetails.steps[unitDetails.steps.length - 1]) || unitDetails.maxStep;\n                if (steps === undefined || Math.ceil((max - min) / (steps * unitDetails.size)) <= maxTicks) {\n                    break;\n                }\n            }\n            \n            return unit;\n        }\n        \n        /**\n         * Determines how we scale the unit\n         * @param min {Number} the scale minimum\n         * @param max {Number} the scale maximum\n         * @param unit {String} the unit determined by the {@see determineUnit} method\n         * @return {Number} the axis step size as a multiple of unit\n         */\n        function determineStepSize(min, max, unit, maxTicks) {\n            // Using our unit, figoure out what we need to scale as\n            var unitDefinition = interval[unit];\n            var unitSizeInMilliSeconds = unitDefinition.size;\n            var sizeInUnits = Math.ceil((max - min) / unitSizeInMilliSeconds);\n            var multiplier = 1;\n            var range = max - min;\n            \n            if (unitDefinition.steps) {\n                // Have an array of steps\n                var numSteps = unitDefinition.steps.length;\n                for (var i = 0; i < numSteps && sizeInUnits > maxTicks; i++) {\n                    multiplier = unitDefinition.steps[i];\n                    sizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));\n                }\n            } else {\n                while (sizeInUnits > maxTicks && maxTicks > 0) {\n                    ++multiplier;\n                    sizeInUnits = Math.ceil(range / (unitSizeInMilliSeconds * multiplier));\n                }\n            }\n            \n            return multiplier;\n        }\n        \n        /**\n         * Helper for generating axis labels.\n         * @param options {ITimeGeneratorOptions} the options for generation\n         * @param dataRange {IRange} the data range\n         * @param niceRange {IRange} the pretty range to display\n         * @return {Number[]} ticks\n         */\n        function generateTicks(options, dataRange, niceRange) {\n            var ticks = [];\n            if (options.maxTicks) {\n                var stepSize = options.stepSize;\n                ticks.push(options.min !== undefined ? options.min : niceRange.min);\n                var cur = moment(niceRange.min);\n                while (cur.add(stepSize, options.unit).valueOf() < niceRange.max) {\n                    ticks.push(cur.valueOf());\n                }\n                var realMax = options.max || niceRange.max;\n                if (ticks[ticks.length - 1] !== realMax) {\n                    ticks.push(realMax);\n                }\n            }\n            return ticks;\n        }\n        \n        /**\n         * @function Chart.Ticks.generators.time\n         * @param options {ITimeGeneratorOptions} the options for generation\n         * @param dataRange {IRange} the data range\n         * @return {Number[]} ticks\n         */\n        Chart.Ticks.generators.time = function(options, dataRange) {\n            var niceMin;\n            var niceMax;\n            var isoWeekday = options.isoWeekday;\n            if (options.unit === 'week' && isoWeekday !== false) {\n                niceMin = moment(dataRange.min).startOf('isoWeek').isoWeekday(isoWeekday).valueOf();\n                niceMax = moment(dataRange.max).startOf('isoWeek').isoWeekday(isoWeekday);\n                if (dataRange.max - niceMax > 0) {\n                    niceMax.add(1, 'week');\n                }\n                niceMax = niceMax.valueOf();\n            } else {\n                niceMin = moment(dataRange.min).startOf(options.unit).valueOf();\n                niceMax = moment(dataRange.max).startOf(options.unit);\n                if (dataRange.max - niceMax > 0) {\n                    niceMax.add(1, options.unit);\n                }\n                niceMax = niceMax.valueOf();\n            }\n            return generateTicks(options, dataRange, {\n                min: niceMin,\n                max: niceMax\n            });\n        };\n        \n        var TimeScale = Chart.Scale.extend({\n            initialize: function() {\n                if (!moment) {\n                    throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');\n                }\n                \n                Chart.Scale.prototype.initialize.call(this);\n            },\n            determineDataLimits: function() {\n                var me = this;\n                var timeOpts = me.options.time;\n                \n                // We store the data range as unix millisecond timestamps so dataMin and dataMax will always be integers.\n                var dataMin = Number.MAX_SAFE_INTEGER;\n                var dataMax = Number.MIN_SAFE_INTEGER;\n                \n                var chartData = me.chart.data;\n                var parsedData = {\n                    labels: [],\n                    datasets: []\n                };\n                \n                var timestamp;\n                \n                helpers.each(chartData.labels, function(label, labelIndex) {\n                    var labelMoment = parseTime(me, label);\n                    \n                    if (labelMoment.isValid()) {\n                        // We need to round the time\n                        if (timeOpts.round) {\n                            labelMoment.startOf(timeOpts.round);\n                        }\n                        \n                        timestamp = labelMoment.valueOf();\n                        dataMin = Math.min(timestamp, dataMin);\n                        dataMax = Math.max(timestamp, dataMax);\n                        \n                        // Store this value for later\n                        parsedData.labels[labelIndex] = timestamp;\n                    }\n                });\n                \n                helpers.each(chartData.datasets, function(dataset, datasetIndex) {\n                    var timestamps = [];\n                    \n                    if (typeof dataset.data[0] === 'object' && dataset.data[0] !== null && me.chart.isDatasetVisible(datasetIndex)) {\n                        // We have potential point data, so we need to parse this\n                        helpers.each(dataset.data, function(value, dataIndex) {\n                            var dataMoment = parseTime(me, me.getRightValue(value));\n                            \n                            if (dataMoment.isValid()) {\n                                if (timeOpts.round) {\n                                    dataMoment.startOf(timeOpts.round);\n                                }\n                                \n                                timestamp = dataMoment.valueOf();\n                                dataMin = Math.min(timestamp, dataMin);\n                                dataMax = Math.max(timestamp, dataMax);\n                                timestamps[dataIndex] = timestamp;\n                            }\n                        });\n                    } else {\n                        // We have no x coordinates, so use the ones from the labels\n                        timestamps = parsedData.labels.slice();\n                    }\n                    \n                    parsedData.datasets[datasetIndex] = timestamps;\n                });\n                \n                me.dataMin = dataMin;\n                me.dataMax = dataMax;\n                me._parsedData = parsedData;\n            },\n            buildTicks: function() {\n                var me = this;\n                var timeOpts = me.options.time;\n                \n                var minTimestamp;\n                var maxTimestamp;\n                var dataMin = me.dataMin;\n                var dataMax = me.dataMax;\n                \n                if (timeOpts.min) {\n                    var minMoment = parseTime(me, timeOpts.min);\n                    if (timeOpts.round) {\n                        minMoment.round(timeOpts.round);\n                    }\n                    minTimestamp = minMoment.valueOf();\n                }\n                \n                if (timeOpts.max) {\n                    maxTimestamp = parseTime(me, timeOpts.max).valueOf();\n                }\n                \n                var maxTicks = me.getLabelCapacity(minTimestamp || dataMin);\n                var unit = timeOpts.unit || determineUnit(timeOpts.minUnit, minTimestamp || dataMin, maxTimestamp || dataMax, maxTicks);\n                me.displayFormat = timeOpts.displayFormats[unit];\n                \n                var stepSize = timeOpts.stepSize || determineStepSize(minTimestamp || dataMin, maxTimestamp || dataMax, unit, maxTicks);\n                me.ticks = Chart.Ticks.generators.time({\n                    maxTicks: maxTicks,\n                    min: minTimestamp,\n                    max: maxTimestamp,\n                    stepSize: stepSize,\n                    unit: unit,\n                    isoWeekday: timeOpts.isoWeekday\n                }, {\n                    min: dataMin,\n                    max: dataMax\n                });\n                \n                // At this point, we need to update our max and min given the tick values since we have expanded the\n                // range of the scale\n                me.max = helpers.max(me.ticks);\n                me.min = helpers.min(me.ticks);\n            },\n            // Get tooltip label\n            getLabelForIndex: function(index, datasetIndex) {\n                var me = this;\n                var label = me.chart.data.labels && index < me.chart.data.labels.length ? me.chart.data.labels[index] : '';\n                var value = me.chart.data.datasets[datasetIndex].data[index];\n                \n                if (value !== null && typeof value === 'object') {\n                    label = me.getRightValue(value);\n                }\n                \n                // Format nicely\n                if (me.options.time.tooltipFormat) {\n                    label = parseTime(me, label).format(me.options.time.tooltipFormat);\n                }\n                \n                return label;\n            },\n            // Function to format an individual tick mark\n            tickFormatFunction: function(tick, index, ticks) {\n                var formattedTick = tick.format(this.displayFormat);\n                var tickOpts = this.options.ticks;\n                var callback = helpers.getValueOrDefault(tickOpts.callback, tickOpts.userCallback);\n                \n                if (callback) {\n                    return callback(formattedTick, index, ticks);\n                }\n                return formattedTick;\n            },\n            convertTicksToLabels: function() {\n                var me = this;\n                me.ticksAsTimestamps = me.ticks;\n                me.ticks = me.ticks.map(function(tick) {\n                    return moment(tick);\n                }).map(me.tickFormatFunction, me);\n            },\n            getPixelForOffset: function(offset) {\n                var me = this;\n                var epochWidth = me.max - me.min;\n                var decimal = epochWidth ? (offset - me.min) / epochWidth : 0;\n                \n                if (me.isHorizontal()) {\n                    var valueOffset = (me.width * decimal);\n                    return me.left + Math.round(valueOffset);\n                }\n                \n                var heightOffset = (me.height * decimal);\n                return me.top + Math.round(heightOffset);\n            },\n            getPixelForValue: function(value, index, datasetIndex) {\n                var me = this;\n                var offset = null;\n                if (index !== undefined && datasetIndex !== undefined) {\n                    offset = me._parsedData.datasets[datasetIndex][index];\n                }\n                \n                if (offset === null) {\n                    if (!value || !value.isValid) {\n                        // not already a moment object\n                        value = parseTime(me, me.getRightValue(value));\n                    }\n                    \n                    if (value && value.isValid && value.isValid()) {\n                        offset = value.valueOf();\n                    }\n                }\n                \n                if (offset !== null) {\n                    return me.getPixelForOffset(offset);\n                }\n            },\n            getPixelForTick: function(index) {\n                return this.getPixelForOffset(this.ticksAsTimestamps[index]);\n            },\n            getValueForPixel: function(pixel) {\n                var me = this;\n                var innerDimension = me.isHorizontal() ? me.width : me.height;\n                var offset = (pixel - (me.isHorizontal() ? me.left : me.top)) / innerDimension;\n                return moment(me.min + (offset * (me.max - me.min)));\n            },\n            // Crude approximation of what the label width might be\n            getLabelWidth: function(label) {\n                var me = this;\n                var ticks = me.options.ticks;\n                \n                var tickLabelWidth = me.ctx.measureText(label).width;\n                var cosRotation = Math.cos(helpers.toRadians(ticks.maxRotation));\n                var sinRotation = Math.sin(helpers.toRadians(ticks.maxRotation));\n                var tickFontSize = helpers.getValueOrDefault(ticks.fontSize, Chart.defaults.global.defaultFontSize);\n                return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n            },\n            getLabelCapacity: function(exampleTime) {\n                var me = this;\n                \n                me.displayFormat = me.options.time.displayFormats.millisecond;\t// Pick the longest format for guestimation\n                var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, []);\n                var tickLabelWidth = me.getLabelWidth(exampleLabel);\n                \n                var innerWidth = me.isHorizontal() ? me.width : me.height;\n                var labelCapacity = innerWidth / tickLabelWidth;\n                return labelCapacity;\n            }\n        });\n        Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);\n        \n    };\n    \n},{\"44\":44}],44:[function(require,module,exports){\n\n},{}],45:[function(require,module,exports){\n    /* MIT license */\n    var colorNames = require(49);\n    \n    module.exports = {\n        getRgba: getRgba,\n        getHsla: getHsla,\n        getRgb: getRgb,\n        getHsl: getHsl,\n        getHwb: getHwb,\n        getAlpha: getAlpha,\n        \n        hexString: hexString,\n        rgbString: rgbString,\n        rgbaString: rgbaString,\n        percentString: percentString,\n        percentaString: percentaString,\n        hslString: hslString,\n        hslaString: hslaString,\n        hwbString: hwbString,\n        keyword: keyword\n    }\n    \n    function getRgba(string) {\n        if (!string) {\n            return;\n        }\n        var abbr =  /^#([a-fA-F0-9]{3})$/,\n            hex =  /^#([a-fA-F0-9]{6})$/,\n            rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\n            per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/,\n            keyword = /(\\w+)/;\n        \n        var rgb = [0, 0, 0],\n            a = 1,\n            match = string.match(abbr);\n        if (match) {\n            match = match[1];\n            for (var i = 0; i < rgb.length; i++) {\n                rgb[i] = parseInt(match[i] + match[i], 16);\n            }\n        }\n        else if (match = string.match(hex)) {\n            match = match[1];\n            for (var i = 0; i < rgb.length; i++) {\n                rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n            }\n        }\n        else if (match = string.match(rgba)) {\n            for (var i = 0; i < rgb.length; i++) {\n                rgb[i] = parseInt(match[i + 1]);\n            }\n            a = parseFloat(match[4]);\n        }\n        else if (match = string.match(per)) {\n            for (var i = 0; i < rgb.length; i++) {\n                rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n            }\n            a = parseFloat(match[4]);\n        }\n        else if (match = string.match(keyword)) {\n            if (match[1] == \"transparent\") {\n                return [0, 0, 0, 0];\n            }\n            rgb = colorNames[match[1]];\n            if (!rgb) {\n                return;\n            }\n        }\n        \n        for (var i = 0; i < rgb.length; i++) {\n            rgb[i] = scale(rgb[i], 0, 255);\n        }\n        if (!a && a != 0) {\n            a = 1;\n        }\n        else {\n            a = scale(a, 0, 1);\n        }\n        rgb[3] = a;\n        return rgb;\n    }\n    \n    function getHsla(string) {\n        if (!string) {\n            return;\n        }\n        var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n        var match = string.match(hsl);\n        if (match) {\n            var alpha = parseFloat(match[4]);\n            var h = scale(parseInt(match[1]), 0, 360),\n                s = scale(parseFloat(match[2]), 0, 100),\n                l = scale(parseFloat(match[3]), 0, 100),\n                a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n            return [h, s, l, a];\n        }\n    }\n    \n    function getHwb(string) {\n        if (!string) {\n            return;\n        }\n        var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n        var match = string.match(hwb);\n        if (match) {\n            var alpha = parseFloat(match[4]);\n            var h = scale(parseInt(match[1]), 0, 360),\n                w = scale(parseFloat(match[2]), 0, 100),\n                b = scale(parseFloat(match[3]), 0, 100),\n                a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n            return [h, w, b, a];\n        }\n    }\n    \n    function getRgb(string) {\n        var rgba = getRgba(string);\n        return rgba && rgba.slice(0, 3);\n    }\n    \n    function getHsl(string) {\n        var hsla = getHsla(string);\n        return hsla && hsla.slice(0, 3);\n    }\n    \n    function getAlpha(string) {\n        var vals = getRgba(string);\n        if (vals) {\n            return vals[3];\n        }\n        else if (vals = getHsla(string)) {\n            return vals[3];\n        }\n        else if (vals = getHwb(string)) {\n            return vals[3];\n        }\n    }\n\n// generators\n    function hexString(rgb) {\n        return \"#\" + hexDouble(rgb[0]) + hexDouble(rgb[1])\n            + hexDouble(rgb[2]);\n    }\n    \n    function rgbString(rgba, alpha) {\n        if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n            return rgbaString(rgba, alpha);\n        }\n        return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n    }\n    \n    function rgbaString(rgba, alpha) {\n        if (alpha === undefined) {\n            alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n        }\n        return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n            + \", \" + alpha + \")\";\n    }\n    \n    function percentString(rgba, alpha) {\n        if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n            return percentaString(rgba, alpha);\n        }\n        var r = Math.round(rgba[0]/255 * 100),\n            g = Math.round(rgba[1]/255 * 100),\n            b = Math.round(rgba[2]/255 * 100);\n        \n        return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n    }\n    \n    function percentaString(rgba, alpha) {\n        var r = Math.round(rgba[0]/255 * 100),\n            g = Math.round(rgba[1]/255 * 100),\n            b = Math.round(rgba[2]/255 * 100);\n        return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n    }\n    \n    function hslString(hsla, alpha) {\n        if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n            return hslaString(hsla, alpha);\n        }\n        return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n    }\n    \n    function hslaString(hsla, alpha) {\n        if (alpha === undefined) {\n            alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n        }\n        return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n            + alpha + \")\";\n    }\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\n    function hwbString(hwb, alpha) {\n        if (alpha === undefined) {\n            alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n        }\n        return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n            + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n    }\n    \n    function keyword(rgb) {\n        return reverseNames[rgb.slice(0, 3)];\n    }\n\n// helpers\n    function scale(num, min, max) {\n        return Math.min(Math.max(min, num), max);\n    }\n    \n    function hexDouble(num) {\n        var str = num.toString(16).toUpperCase();\n        return (str.length < 2) ? \"0\" + str : str;\n    }\n\n\n//create a list of reverse color names\n    var reverseNames = {};\n    for (var name in colorNames) {\n        reverseNames[colorNames[name]] = name;\n    }\n    \n},{\"49\":49}],46:[function(require,module,exports){\n    /* MIT license */\n    var convert = require(48);\n    var string = require(45);\n    \n    var Color = function (obj) {\n        if (obj instanceof Color) {\n            return obj;\n        }\n        if (!(this instanceof Color)) {\n            return new Color(obj);\n        }\n        \n        this.valid = false;\n        this.values = {\n            rgb: [0, 0, 0],\n            hsl: [0, 0, 0],\n            hsv: [0, 0, 0],\n            hwb: [0, 0, 0],\n            cmyk: [0, 0, 0, 0],\n            alpha: 1\n        };\n        \n        // parse Color() argument\n        var vals;\n        if (typeof obj === 'string') {\n            vals = string.getRgba(obj);\n            if (vals) {\n                this.setValues('rgb', vals);\n            } else if (vals = string.getHsla(obj)) {\n                this.setValues('hsl', vals);\n            } else if (vals = string.getHwb(obj)) {\n                this.setValues('hwb', vals);\n            }\n        } else if (typeof obj === 'object') {\n            vals = obj;\n            if (vals.r !== undefined || vals.red !== undefined) {\n                this.setValues('rgb', vals);\n            } else if (vals.l !== undefined || vals.lightness !== undefined) {\n                this.setValues('hsl', vals);\n            } else if (vals.v !== undefined || vals.value !== undefined) {\n                this.setValues('hsv', vals);\n            } else if (vals.w !== undefined || vals.whiteness !== undefined) {\n                this.setValues('hwb', vals);\n            } else if (vals.c !== undefined || vals.cyan !== undefined) {\n                this.setValues('cmyk', vals);\n            }\n        }\n    };\n    \n    Color.prototype = {\n        isValid: function () {\n            return this.valid;\n        },\n        rgb: function () {\n            return this.setSpace('rgb', arguments);\n        },\n        hsl: function () {\n            return this.setSpace('hsl', arguments);\n        },\n        hsv: function () {\n            return this.setSpace('hsv', arguments);\n        },\n        hwb: function () {\n            return this.setSpace('hwb', arguments);\n        },\n        cmyk: function () {\n            return this.setSpace('cmyk', arguments);\n        },\n        \n        rgbArray: function () {\n            return this.values.rgb;\n        },\n        hslArray: function () {\n            return this.values.hsl;\n        },\n        hsvArray: function () {\n            return this.values.hsv;\n        },\n        hwbArray: function () {\n            var values = this.values;\n            if (values.alpha !== 1) {\n                return values.hwb.concat([values.alpha]);\n            }\n            return values.hwb;\n        },\n        cmykArray: function () {\n            return this.values.cmyk;\n        },\n        rgbaArray: function () {\n            var values = this.values;\n            return values.rgb.concat([values.alpha]);\n        },\n        hslaArray: function () {\n            var values = this.values;\n            return values.hsl.concat([values.alpha]);\n        },\n        alpha: function (val) {\n            if (val === undefined) {\n                return this.values.alpha;\n            }\n            this.setValues('alpha', val);\n            return this;\n        },\n        \n        red: function (val) {\n            return this.setChannel('rgb', 0, val);\n        },\n        green: function (val) {\n            return this.setChannel('rgb', 1, val);\n        },\n        blue: function (val) {\n            return this.setChannel('rgb', 2, val);\n        },\n        hue: function (val) {\n            if (val) {\n                val %= 360;\n                val = val < 0 ? 360 + val : val;\n            }\n            return this.setChannel('hsl', 0, val);\n        },\n        saturation: function (val) {\n            return this.setChannel('hsl', 1, val);\n        },\n        lightness: function (val) {\n            return this.setChannel('hsl', 2, val);\n        },\n        saturationv: function (val) {\n            return this.setChannel('hsv', 1, val);\n        },\n        whiteness: function (val) {\n            return this.setChannel('hwb', 1, val);\n        },\n        blackness: function (val) {\n            return this.setChannel('hwb', 2, val);\n        },\n        value: function (val) {\n            return this.setChannel('hsv', 2, val);\n        },\n        cyan: function (val) {\n            return this.setChannel('cmyk', 0, val);\n        },\n        magenta: function (val) {\n            return this.setChannel('cmyk', 1, val);\n        },\n        yellow: function (val) {\n            return this.setChannel('cmyk', 2, val);\n        },\n        black: function (val) {\n            return this.setChannel('cmyk', 3, val);\n        },\n        \n        hexString: function () {\n            return string.hexString(this.values.rgb);\n        },\n        rgbString: function () {\n            return string.rgbString(this.values.rgb, this.values.alpha);\n        },\n        rgbaString: function () {\n            return string.rgbaString(this.values.rgb, this.values.alpha);\n        },\n        percentString: function () {\n            return string.percentString(this.values.rgb, this.values.alpha);\n        },\n        hslString: function () {\n            return string.hslString(this.values.hsl, this.values.alpha);\n        },\n        hslaString: function () {\n            return string.hslaString(this.values.hsl, this.values.alpha);\n        },\n        hwbString: function () {\n            return string.hwbString(this.values.hwb, this.values.alpha);\n        },\n        keyword: function () {\n            return string.keyword(this.values.rgb, this.values.alpha);\n        },\n        \n        rgbNumber: function () {\n            var rgb = this.values.rgb;\n            return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n        },\n        \n        luminosity: function () {\n            // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n            var rgb = this.values.rgb;\n            var lum = [];\n            for (var i = 0; i < rgb.length; i++) {\n                var chan = rgb[i] / 255;\n                lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n            }\n            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n        },\n        \n        contrast: function (color2) {\n            // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n            var lum1 = this.luminosity();\n            var lum2 = color2.luminosity();\n            if (lum1 > lum2) {\n                return (lum1 + 0.05) / (lum2 + 0.05);\n            }\n            return (lum2 + 0.05) / (lum1 + 0.05);\n        },\n        \n        level: function (color2) {\n            var contrastRatio = this.contrast(color2);\n            if (contrastRatio >= 7.1) {\n                return 'AAA';\n            }\n            \n            return (contrastRatio >= 4.5) ? 'AA' : '';\n        },\n        \n        dark: function () {\n            // YIQ equation from http://24ways.org/2010/calculating-color-contrast\n            var rgb = this.values.rgb;\n            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n            return yiq < 128;\n        },\n        \n        light: function () {\n            return !this.dark();\n        },\n        \n        negate: function () {\n            var rgb = [];\n            for (var i = 0; i < 3; i++) {\n                rgb[i] = 255 - this.values.rgb[i];\n            }\n            this.setValues('rgb', rgb);\n            return this;\n        },\n        \n        lighten: function (ratio) {\n            var hsl = this.values.hsl;\n            hsl[2] += hsl[2] * ratio;\n            this.setValues('hsl', hsl);\n            return this;\n        },\n        \n        darken: function (ratio) {\n            var hsl = this.values.hsl;\n            hsl[2] -= hsl[2] * ratio;\n            this.setValues('hsl', hsl);\n            return this;\n        },\n        \n        saturate: function (ratio) {\n            var hsl = this.values.hsl;\n            hsl[1] += hsl[1] * ratio;\n            this.setValues('hsl', hsl);\n            return this;\n        },\n        \n        desaturate: function (ratio) {\n            var hsl = this.values.hsl;\n            hsl[1] -= hsl[1] * ratio;\n            this.setValues('hsl', hsl);\n            return this;\n        },\n        \n        whiten: function (ratio) {\n            var hwb = this.values.hwb;\n            hwb[1] += hwb[1] * ratio;\n            this.setValues('hwb', hwb);\n            return this;\n        },\n        \n        blacken: function (ratio) {\n            var hwb = this.values.hwb;\n            hwb[2] += hwb[2] * ratio;\n            this.setValues('hwb', hwb);\n            return this;\n        },\n        \n        greyscale: function () {\n            var rgb = this.values.rgb;\n            // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n            this.setValues('rgb', [val, val, val]);\n            return this;\n        },\n        \n        clearer: function (ratio) {\n            var alpha = this.values.alpha;\n            this.setValues('alpha', alpha - (alpha * ratio));\n            return this;\n        },\n        \n        opaquer: function (ratio) {\n            var alpha = this.values.alpha;\n            this.setValues('alpha', alpha + (alpha * ratio));\n            return this;\n        },\n        \n        rotate: function (degrees) {\n            var hsl = this.values.hsl;\n            var hue = (hsl[0] + degrees) % 360;\n            hsl[0] = hue < 0 ? 360 + hue : hue;\n            this.setValues('hsl', hsl);\n            return this;\n        },\n        \n        /**\n         * Ported from sass implementation in C\n         * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n         */\n        mix: function (mixinColor, weight) {\n            var color1 = this;\n            var color2 = mixinColor;\n            var p = weight === undefined ? 0.5 : weight;\n            \n            var w = 2 * p - 1;\n            var a = color1.alpha() - color2.alpha();\n            \n            var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n            var w2 = 1 - w1;\n            \n            return this\n                .rgb(\n                    w1 * color1.red() + w2 * color2.red(),\n                    w1 * color1.green() + w2 * color2.green(),\n                    w1 * color1.blue() + w2 * color2.blue()\n                )\n                .alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n        },\n        \n        toJSON: function () {\n            return this.rgb();\n        },\n        \n        clone: function () {\n            // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n            // making the final build way to big to embed in Chart.js. So let's do it manually,\n            // assuming that values to clone are 1 dimension arrays containing only numbers,\n            // except 'alpha' which is a number.\n            var result = new Color();\n            var source = this.values;\n            var target = result.values;\n            var value, type;\n            \n            for (var prop in source) {\n                if (source.hasOwnProperty(prop)) {\n                    value = source[prop];\n                    type = ({}).toString.call(value);\n                    if (type === '[object Array]') {\n                        target[prop] = value.slice(0);\n                    } else if (type === '[object Number]') {\n                        target[prop] = value;\n                    } else {\n                        console.error('unexpected color value:', value);\n                    }\n                }\n            }\n            \n            return result;\n        }\n    };\n    \n    Color.prototype.spaces = {\n        rgb: ['red', 'green', 'blue'],\n        hsl: ['hue', 'saturation', 'lightness'],\n        hsv: ['hue', 'saturation', 'value'],\n        hwb: ['hue', 'whiteness', 'blackness'],\n        cmyk: ['cyan', 'magenta', 'yellow', 'black']\n    };\n    \n    Color.prototype.maxes = {\n        rgb: [255, 255, 255],\n        hsl: [360, 100, 100],\n        hsv: [360, 100, 100],\n        hwb: [360, 100, 100],\n        cmyk: [100, 100, 100, 100]\n    };\n    \n    Color.prototype.getValues = function (space) {\n        var values = this.values;\n        var vals = {};\n        \n        for (var i = 0; i < space.length; i++) {\n            vals[space.charAt(i)] = values[space][i];\n        }\n        \n        if (values.alpha !== 1) {\n            vals.a = values.alpha;\n        }\n        \n        // {r: 255, g: 255, b: 255, a: 0.4}\n        return vals;\n    };\n    \n    Color.prototype.setValues = function (space, vals) {\n        var values = this.values;\n        var spaces = this.spaces;\n        var maxes = this.maxes;\n        var alpha = 1;\n        var i;\n        \n        this.valid = true;\n        \n        if (space === 'alpha') {\n            alpha = vals;\n        } else if (vals.length) {\n            // [10, 10, 10]\n            values[space] = vals.slice(0, space.length);\n            alpha = vals[space.length];\n        } else if (vals[space.charAt(0)] !== undefined) {\n            // {r: 10, g: 10, b: 10}\n            for (i = 0; i < space.length; i++) {\n                values[space][i] = vals[space.charAt(i)];\n            }\n            \n            alpha = vals.a;\n        } else if (vals[spaces[space][0]] !== undefined) {\n            // {red: 10, green: 10, blue: 10}\n            var chans = spaces[space];\n            \n            for (i = 0; i < space.length; i++) {\n                values[space][i] = vals[chans[i]];\n            }\n            \n            alpha = vals.alpha;\n        }\n        \n        values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n        \n        if (space === 'alpha') {\n            return false;\n        }\n        \n        var capped;\n        \n        // cap values of the space prior converting all values\n        for (i = 0; i < space.length; i++) {\n            capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n            values[space][i] = Math.round(capped);\n        }\n        \n        // convert to all the other color spaces\n        for (var sname in spaces) {\n            if (sname !== space) {\n                values[sname] = convert[space][sname](values[space]);\n            }\n        }\n        \n        return true;\n    };\n    \n    Color.prototype.setSpace = function (space, args) {\n        var vals = args[0];\n        \n        if (vals === undefined) {\n            // color.rgb()\n            return this.getValues(space);\n        }\n        \n        // color.rgb(10, 10, 10)\n        if (typeof vals === 'number') {\n            vals = Array.prototype.slice.call(args);\n        }\n        \n        this.setValues(space, vals);\n        return this;\n    };\n    \n    Color.prototype.setChannel = function (space, index, val) {\n        var svalues = this.values[space];\n        if (val === undefined) {\n            // color.red()\n            return svalues[index];\n        } else if (val === svalues[index]) {\n            // color.red(color.red())\n            return this;\n        }\n        \n        // color.red(100)\n        svalues[index] = val;\n        this.setValues(space, svalues);\n        \n        return this;\n    };\n    \n    if (typeof window !== 'undefined') {\n        window.Color = Color;\n    }\n    \n    module.exports = Color;\n    \n},{\"45\":45,\"48\":48}],47:[function(require,module,exports){\n    /* MIT license */\n    \n    module.exports = {\n        rgb2hsl: rgb2hsl,\n        rgb2hsv: rgb2hsv,\n        rgb2hwb: rgb2hwb,\n        rgb2cmyk: rgb2cmyk,\n        rgb2keyword: rgb2keyword,\n        rgb2xyz: rgb2xyz,\n        rgb2lab: rgb2lab,\n        rgb2lch: rgb2lch,\n        \n        hsl2rgb: hsl2rgb,\n        hsl2hsv: hsl2hsv,\n        hsl2hwb: hsl2hwb,\n        hsl2cmyk: hsl2cmyk,\n        hsl2keyword: hsl2keyword,\n        \n        hsv2rgb: hsv2rgb,\n        hsv2hsl: hsv2hsl,\n        hsv2hwb: hsv2hwb,\n        hsv2cmyk: hsv2cmyk,\n        hsv2keyword: hsv2keyword,\n        \n        hwb2rgb: hwb2rgb,\n        hwb2hsl: hwb2hsl,\n        hwb2hsv: hwb2hsv,\n        hwb2cmyk: hwb2cmyk,\n        hwb2keyword: hwb2keyword,\n        \n        cmyk2rgb: cmyk2rgb,\n        cmyk2hsl: cmyk2hsl,\n        cmyk2hsv: cmyk2hsv,\n        cmyk2hwb: cmyk2hwb,\n        cmyk2keyword: cmyk2keyword,\n        \n        keyword2rgb: keyword2rgb,\n        keyword2hsl: keyword2hsl,\n        keyword2hsv: keyword2hsv,\n        keyword2hwb: keyword2hwb,\n        keyword2cmyk: keyword2cmyk,\n        keyword2lab: keyword2lab,\n        keyword2xyz: keyword2xyz,\n        \n        xyz2rgb: xyz2rgb,\n        xyz2lab: xyz2lab,\n        xyz2lch: xyz2lch,\n        \n        lab2xyz: lab2xyz,\n        lab2rgb: lab2rgb,\n        lab2lch: lab2lch,\n        \n        lch2lab: lch2lab,\n        lch2xyz: lch2xyz,\n        lch2rgb: lch2rgb\n    }\n    \n    \n    function rgb2hsl(rgb) {\n        var r = rgb[0]/255,\n            g = rgb[1]/255,\n            b = rgb[2]/255,\n            min = Math.min(r, g, b),\n            max = Math.max(r, g, b),\n            delta = max - min,\n            h, s, l;\n        \n        if (max == min)\n            h = 0;\n        else if (r == max)\n            h = (g - b) / delta;\n        else if (g == max)\n            h = 2 + (b - r) / delta;\n        else if (b == max)\n            h = 4 + (r - g)/ delta;\n        \n        h = Math.min(h * 60, 360);\n        \n        if (h < 0)\n            h += 360;\n        \n        l = (min + max) / 2;\n        \n        if (max == min)\n            s = 0;\n        else if (l <= 0.5)\n            s = delta / (max + min);\n        else\n            s = delta / (2 - max - min);\n        \n        return [h, s * 100, l * 100];\n    }\n    \n    function rgb2hsv(rgb) {\n        var r = rgb[0],\n            g = rgb[1],\n            b = rgb[2],\n            min = Math.min(r, g, b),\n            max = Math.max(r, g, b),\n            delta = max - min,\n            h, s, v;\n        \n        if (max == 0)\n            s = 0;\n        else\n            s = (delta/max * 1000)/10;\n        \n        if (max == min)\n            h = 0;\n        else if (r == max)\n            h = (g - b) / delta;\n        else if (g == max)\n            h = 2 + (b - r) / delta;\n        else if (b == max)\n            h = 4 + (r - g) / delta;\n        \n        h = Math.min(h * 60, 360);\n        \n        if (h < 0)\n            h += 360;\n        \n        v = ((max / 255) * 1000) / 10;\n        \n        return [h, s, v];\n    }\n    \n    function rgb2hwb(rgb) {\n        var r = rgb[0],\n            g = rgb[1],\n            b = rgb[2],\n            h = rgb2hsl(rgb)[0],\n            w = 1/255 * Math.min(r, Math.min(g, b)),\n            b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n        \n        return [h, w * 100, b * 100];\n    }\n    \n    function rgb2cmyk(rgb) {\n        var r = rgb[0] / 255,\n            g = rgb[1] / 255,\n            b = rgb[2] / 255,\n            c, m, y, k;\n        \n        k = Math.min(1 - r, 1 - g, 1 - b);\n        c = (1 - r - k) / (1 - k) || 0;\n        m = (1 - g - k) / (1 - k) || 0;\n        y = (1 - b - k) / (1 - k) || 0;\n        return [c * 100, m * 100, y * 100, k * 100];\n    }\n    \n    function rgb2keyword(rgb) {\n        return reverseKeywords[JSON.stringify(rgb)];\n    }\n    \n    function rgb2xyz(rgb) {\n        var r = rgb[0] / 255,\n            g = rgb[1] / 255,\n            b = rgb[2] / 255;\n        \n        // assume sRGB\n        r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n        g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n        b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n        \n        var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n        var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n        var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n        \n        return [x * 100, y *100, z * 100];\n    }\n    \n    function rgb2lab(rgb) {\n        var xyz = rgb2xyz(rgb),\n            x = xyz[0],\n            y = xyz[1],\n            z = xyz[2],\n            l, a, b;\n        \n        x /= 95.047;\n        y /= 100;\n        z /= 108.883;\n        \n        x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n        y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n        z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n        \n        l = (116 * y) - 16;\n        a = 500 * (x - y);\n        b = 200 * (y - z);\n        \n        return [l, a, b];\n    }\n    \n    function rgb2lch(args) {\n        return lab2lch(rgb2lab(args));\n    }\n    \n    function hsl2rgb(hsl) {\n        var h = hsl[0] / 360,\n            s = hsl[1] / 100,\n            l = hsl[2] / 100,\n            t1, t2, t3, rgb, val;\n        \n        if (s == 0) {\n            val = l * 255;\n            return [val, val, val];\n        }\n        \n        if (l < 0.5)\n            t2 = l * (1 + s);\n        else\n            t2 = l + s - l * s;\n        t1 = 2 * l - t2;\n        \n        rgb = [0, 0, 0];\n        for (var i = 0; i < 3; i++) {\n            t3 = h + 1 / 3 * - (i - 1);\n            t3 < 0 && t3++;\n            t3 > 1 && t3--;\n            \n            if (6 * t3 < 1)\n                val = t1 + (t2 - t1) * 6 * t3;\n            else if (2 * t3 < 1)\n                val = t2;\n            else if (3 * t3 < 2)\n                val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n            else\n                val = t1;\n            \n            rgb[i] = val * 255;\n        }\n        \n        return rgb;\n    }\n    \n    function hsl2hsv(hsl) {\n        var h = hsl[0],\n            s = hsl[1] / 100,\n            l = hsl[2] / 100,\n            sv, v;\n        \n        if(l === 0) {\n            // no need to do calc on black\n            // also avoids divide by 0 error\n            return [0, 0, 0];\n        }\n        \n        l *= 2;\n        s *= (l <= 1) ? l : 2 - l;\n        v = (l + s) / 2;\n        sv = (2 * s) / (l + s);\n        return [h, sv * 100, v * 100];\n    }\n    \n    function hsl2hwb(args) {\n        return rgb2hwb(hsl2rgb(args));\n    }\n    \n    function hsl2cmyk(args) {\n        return rgb2cmyk(hsl2rgb(args));\n    }\n    \n    function hsl2keyword(args) {\n        return rgb2keyword(hsl2rgb(args));\n    }\n    \n    \n    function hsv2rgb(hsv) {\n        var h = hsv[0] / 60,\n            s = hsv[1] / 100,\n            v = hsv[2] / 100,\n            hi = Math.floor(h) % 6;\n        \n        var f = h - Math.floor(h),\n            p = 255 * v * (1 - s),\n            q = 255 * v * (1 - (s * f)),\n            t = 255 * v * (1 - (s * (1 - f))),\n            v = 255 * v;\n        \n        switch(hi) {\n            case 0:\n                return [v, t, p];\n            case 1:\n                return [q, v, p];\n            case 2:\n                return [p, v, t];\n            case 3:\n                return [p, q, v];\n            case 4:\n                return [t, p, v];\n            case 5:\n                return [v, p, q];\n        }\n    }\n    \n    function hsv2hsl(hsv) {\n        var h = hsv[0],\n            s = hsv[1] / 100,\n            v = hsv[2] / 100,\n            sl, l;\n        \n        l = (2 - s) * v;\n        sl = s * v;\n        sl /= (l <= 1) ? l : 2 - l;\n        sl = sl || 0;\n        l /= 2;\n        return [h, sl * 100, l * 100];\n    }\n    \n    function hsv2hwb(args) {\n        return rgb2hwb(hsv2rgb(args))\n    }\n    \n    function hsv2cmyk(args) {\n        return rgb2cmyk(hsv2rgb(args));\n    }\n    \n    function hsv2keyword(args) {\n        return rgb2keyword(hsv2rgb(args));\n    }\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n    function hwb2rgb(hwb) {\n        var h = hwb[0] / 360,\n            wh = hwb[1] / 100,\n            bl = hwb[2] / 100,\n            ratio = wh + bl,\n            i, v, f, n;\n        \n        // wh + bl cant be > 1\n        if (ratio > 1) {\n            wh /= ratio;\n            bl /= ratio;\n        }\n        \n        i = Math.floor(6 * h);\n        v = 1 - bl;\n        f = 6 * h - i;\n        if ((i & 0x01) != 0) {\n            f = 1 - f;\n        }\n        n = wh + f * (v - wh);  // linear interpolation\n        \n        switch (i) {\n            default:\n            case 6:\n            case 0: r = v; g = n; b = wh; break;\n            case 1: r = n; g = v; b = wh; break;\n            case 2: r = wh; g = v; b = n; break;\n            case 3: r = wh; g = n; b = v; break;\n            case 4: r = n; g = wh; b = v; break;\n            case 5: r = v; g = wh; b = n; break;\n        }\n        \n        return [r * 255, g * 255, b * 255];\n    }\n    \n    function hwb2hsl(args) {\n        return rgb2hsl(hwb2rgb(args));\n    }\n    \n    function hwb2hsv(args) {\n        return rgb2hsv(hwb2rgb(args));\n    }\n    \n    function hwb2cmyk(args) {\n        return rgb2cmyk(hwb2rgb(args));\n    }\n    \n    function hwb2keyword(args) {\n        return rgb2keyword(hwb2rgb(args));\n    }\n    \n    function cmyk2rgb(cmyk) {\n        var c = cmyk[0] / 100,\n            m = cmyk[1] / 100,\n            y = cmyk[2] / 100,\n            k = cmyk[3] / 100,\n            r, g, b;\n        \n        r = 1 - Math.min(1, c * (1 - k) + k);\n        g = 1 - Math.min(1, m * (1 - k) + k);\n        b = 1 - Math.min(1, y * (1 - k) + k);\n        return [r * 255, g * 255, b * 255];\n    }\n    \n    function cmyk2hsl(args) {\n        return rgb2hsl(cmyk2rgb(args));\n    }\n    \n    function cmyk2hsv(args) {\n        return rgb2hsv(cmyk2rgb(args));\n    }\n    \n    function cmyk2hwb(args) {\n        return rgb2hwb(cmyk2rgb(args));\n    }\n    \n    function cmyk2keyword(args) {\n        return rgb2keyword(cmyk2rgb(args));\n    }\n    \n    \n    function xyz2rgb(xyz) {\n        var x = xyz[0] / 100,\n            y = xyz[1] / 100,\n            z = xyz[2] / 100,\n            r, g, b;\n        \n        r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n        g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n        b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n        \n        // assume sRGB\n        r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n            : r = (r * 12.92);\n        \n        g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n            : g = (g * 12.92);\n        \n        b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n            : b = (b * 12.92);\n        \n        r = Math.min(Math.max(0, r), 1);\n        g = Math.min(Math.max(0, g), 1);\n        b = Math.min(Math.max(0, b), 1);\n        \n        return [r * 255, g * 255, b * 255];\n    }\n    \n    function xyz2lab(xyz) {\n        var x = xyz[0],\n            y = xyz[1],\n            z = xyz[2],\n            l, a, b;\n        \n        x /= 95.047;\n        y /= 100;\n        z /= 108.883;\n        \n        x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n        y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n        z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n        \n        l = (116 * y) - 16;\n        a = 500 * (x - y);\n        b = 200 * (y - z);\n        \n        return [l, a, b];\n    }\n    \n    function xyz2lch(args) {\n        return lab2lch(xyz2lab(args));\n    }\n    \n    function lab2xyz(lab) {\n        var l = lab[0],\n            a = lab[1],\n            b = lab[2],\n            x, y, z, y2;\n        \n        if (l <= 8) {\n            y = (l * 100) / 903.3;\n            y2 = (7.787 * (y / 100)) + (16 / 116);\n        } else {\n            y = 100 * Math.pow((l + 16) / 116, 3);\n            y2 = Math.pow(y / 100, 1/3);\n        }\n        \n        x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n        \n        z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n        \n        return [x, y, z];\n    }\n    \n    function lab2lch(lab) {\n        var l = lab[0],\n            a = lab[1],\n            b = lab[2],\n            hr, h, c;\n        \n        hr = Math.atan2(b, a);\n        h = hr * 360 / 2 / Math.PI;\n        if (h < 0) {\n            h += 360;\n        }\n        c = Math.sqrt(a * a + b * b);\n        return [l, c, h];\n    }\n    \n    function lab2rgb(args) {\n        return xyz2rgb(lab2xyz(args));\n    }\n    \n    function lch2lab(lch) {\n        var l = lch[0],\n            c = lch[1],\n            h = lch[2],\n            a, b, hr;\n        \n        hr = h / 360 * 2 * Math.PI;\n        a = c * Math.cos(hr);\n        b = c * Math.sin(hr);\n        return [l, a, b];\n    }\n    \n    function lch2xyz(args) {\n        return lab2xyz(lch2lab(args));\n    }\n    \n    function lch2rgb(args) {\n        return lab2rgb(lch2lab(args));\n    }\n    \n    function keyword2rgb(keyword) {\n        return cssKeywords[keyword];\n    }\n    \n    function keyword2hsl(args) {\n        return rgb2hsl(keyword2rgb(args));\n    }\n    \n    function keyword2hsv(args) {\n        return rgb2hsv(keyword2rgb(args));\n    }\n    \n    function keyword2hwb(args) {\n        return rgb2hwb(keyword2rgb(args));\n    }\n    \n    function keyword2cmyk(args) {\n        return rgb2cmyk(keyword2rgb(args));\n    }\n    \n    function keyword2lab(args) {\n        return rgb2lab(keyword2rgb(args));\n    }\n    \n    function keyword2xyz(args) {\n        return rgb2xyz(keyword2rgb(args));\n    }\n    \n    var cssKeywords = {\n        aliceblue:  [240,248,255],\n        antiquewhite: [250,235,215],\n        aqua: [0,255,255],\n        aquamarine: [127,255,212],\n        azure:  [240,255,255],\n        beige:  [245,245,220],\n        bisque: [255,228,196],\n        black:  [0,0,0],\n        blanchedalmond: [255,235,205],\n        blue: [0,0,255],\n        blueviolet: [138,43,226],\n        brown:  [165,42,42],\n        burlywood:  [222,184,135],\n        cadetblue:  [95,158,160],\n        chartreuse: [127,255,0],\n        chocolate:  [210,105,30],\n        coral:  [255,127,80],\n        cornflowerblue: [100,149,237],\n        cornsilk: [255,248,220],\n        crimson:  [220,20,60],\n        cyan: [0,255,255],\n        darkblue: [0,0,139],\n        darkcyan: [0,139,139],\n        darkgoldenrod:  [184,134,11],\n        darkgray: [169,169,169],\n        darkgreen:  [0,100,0],\n        darkgrey: [169,169,169],\n        darkkhaki:  [189,183,107],\n        darkmagenta:  [139,0,139],\n        darkolivegreen: [85,107,47],\n        darkorange: [255,140,0],\n        darkorchid: [153,50,204],\n        darkred:  [139,0,0],\n        darksalmon: [233,150,122],\n        darkseagreen: [143,188,143],\n        darkslateblue:  [72,61,139],\n        darkslategray:  [47,79,79],\n        darkslategrey:  [47,79,79],\n        darkturquoise:  [0,206,209],\n        darkviolet: [148,0,211],\n        deeppink: [255,20,147],\n        deepskyblue:  [0,191,255],\n        dimgray:  [105,105,105],\n        dimgrey:  [105,105,105],\n        dodgerblue: [30,144,255],\n        firebrick:  [178,34,34],\n        floralwhite:  [255,250,240],\n        forestgreen:  [34,139,34],\n        fuchsia:  [255,0,255],\n        gainsboro:  [220,220,220],\n        ghostwhite: [248,248,255],\n        gold: [255,215,0],\n        goldenrod:  [218,165,32],\n        gray: [128,128,128],\n        green:  [0,128,0],\n        greenyellow:  [173,255,47],\n        grey: [128,128,128],\n        honeydew: [240,255,240],\n        hotpink:  [255,105,180],\n        indianred:  [205,92,92],\n        indigo: [75,0,130],\n        ivory:  [255,255,240],\n        khaki:  [240,230,140],\n        lavender: [230,230,250],\n        lavenderblush:  [255,240,245],\n        lawngreen:  [124,252,0],\n        lemonchiffon: [255,250,205],\n        lightblue:  [173,216,230],\n        lightcoral: [240,128,128],\n        lightcyan:  [224,255,255],\n        lightgoldenrodyellow: [250,250,210],\n        lightgray:  [211,211,211],\n        lightgreen: [144,238,144],\n        lightgrey:  [211,211,211],\n        lightpink:  [255,182,193],\n        lightsalmon:  [255,160,122],\n        lightseagreen:  [32,178,170],\n        lightskyblue: [135,206,250],\n        lightslategray: [119,136,153],\n        lightslategrey: [119,136,153],\n        lightsteelblue: [176,196,222],\n        lightyellow:  [255,255,224],\n        lime: [0,255,0],\n        limegreen:  [50,205,50],\n        linen:  [250,240,230],\n        magenta:  [255,0,255],\n        maroon: [128,0,0],\n        mediumaquamarine: [102,205,170],\n        mediumblue: [0,0,205],\n        mediumorchid: [186,85,211],\n        mediumpurple: [147,112,219],\n        mediumseagreen: [60,179,113],\n        mediumslateblue:  [123,104,238],\n        mediumspringgreen:  [0,250,154],\n        mediumturquoise:  [72,209,204],\n        mediumvioletred:  [199,21,133],\n        midnightblue: [25,25,112],\n        mintcream:  [245,255,250],\n        mistyrose:  [255,228,225],\n        moccasin: [255,228,181],\n        navajowhite:  [255,222,173],\n        navy: [0,0,128],\n        oldlace:  [253,245,230],\n        olive:  [128,128,0],\n        olivedrab:  [107,142,35],\n        orange: [255,165,0],\n        orangered:  [255,69,0],\n        orchid: [218,112,214],\n        palegoldenrod:  [238,232,170],\n        palegreen:  [152,251,152],\n        paleturquoise:  [175,238,238],\n        palevioletred:  [219,112,147],\n        papayawhip: [255,239,213],\n        peachpuff:  [255,218,185],\n        peru: [205,133,63],\n        pink: [255,192,203],\n        plum: [221,160,221],\n        powderblue: [176,224,230],\n        purple: [128,0,128],\n        rebeccapurple: [102, 51, 153],\n        red:  [255,0,0],\n        rosybrown:  [188,143,143],\n        royalblue:  [65,105,225],\n        saddlebrown:  [139,69,19],\n        salmon: [250,128,114],\n        sandybrown: [244,164,96],\n        seagreen: [46,139,87],\n        seashell: [255,245,238],\n        sienna: [160,82,45],\n        silver: [192,192,192],\n        skyblue:  [135,206,235],\n        slateblue:  [106,90,205],\n        slategray:  [112,128,144],\n        slategrey:  [112,128,144],\n        snow: [255,250,250],\n        springgreen:  [0,255,127],\n        steelblue:  [70,130,180],\n        tan:  [210,180,140],\n        teal: [0,128,128],\n        thistle:  [216,191,216],\n        tomato: [255,99,71],\n        turquoise:  [64,224,208],\n        violet: [238,130,238],\n        wheat:  [245,222,179],\n        white:  [255,255,255],\n        whitesmoke: [245,245,245],\n        yellow: [255,255,0],\n        yellowgreen:  [154,205,50]\n    };\n    \n    var reverseKeywords = {};\n    for (var key in cssKeywords) {\n        reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n    }\n    \n},{}],48:[function(require,module,exports){\n    var conversions = require(47);\n    \n    var convert = function() {\n        return new Converter();\n    }\n    \n    for (var func in conversions) {\n        // export Raw versions\n        convert[func + \"Raw\"] =  (function(func) {\n            // accept array or plain args\n            return function(arg) {\n                if (typeof arg == \"number\")\n                    arg = Array.prototype.slice.call(arguments);\n                return conversions[func](arg);\n            }\n        })(func);\n        \n        var pair = /(\\w+)2(\\w+)/.exec(func),\n            from = pair[1],\n            to = pair[2];\n        \n        // export rgb2hsl and [\"rgb\"][\"hsl\"]\n        convert[from] = convert[from] || {};\n        \n        convert[from][to] = convert[func] = (function(func) {\n            return function(arg) {\n                if (typeof arg == \"number\")\n                    arg = Array.prototype.slice.call(arguments);\n                \n                var val = conversions[func](arg);\n                if (typeof val == \"string\" || val === undefined)\n                    return val; // keyword\n                \n                for (var i = 0; i < val.length; i++)\n                    val[i] = Math.round(val[i]);\n                return val;\n            }\n        })(func);\n    }\n    \n    \n    /* Converter does lazy conversion and caching */\n    var Converter = function() {\n        this.convs = {};\n    };\n    \n    /* Either get the values for a space or\n     set the values for a space, depending on args */\n    Converter.prototype.routeSpace = function(space, args) {\n        var values = args[0];\n        if (values === undefined) {\n            // color.rgb()\n            return this.getValues(space);\n        }\n        // color.rgb(10, 10, 10)\n        if (typeof values == \"number\") {\n            values = Array.prototype.slice.call(args);\n        }\n        \n        return this.setValues(space, values);\n    };\n    \n    /* Set the values for a space, invalidating cache */\n    Converter.prototype.setValues = function(space, values) {\n        this.space = space;\n        this.convs = {};\n        this.convs[space] = values;\n        return this;\n    };\n    \n    /* Get the values for a space. If there's already\n     a conversion for the space, fetch it, otherwise\n     compute it */\n    Converter.prototype.getValues = function(space) {\n        var vals = this.convs[space];\n        if (!vals) {\n            var fspace = this.space,\n                from = this.convs[fspace];\n            vals = convert[fspace][space](from);\n            \n            this.convs[space] = vals;\n        }\n        return vals;\n    };\n    \n    [\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n        Converter.prototype[space] = function(vals) {\n            return this.routeSpace(space, arguments);\n        }\n    });\n    \n    module.exports = convert;\n},{\"47\":47}],49:[function(require,module,exports){\n    module.exports = {\n        \"aliceblue\": [240, 248, 255],\n        \"antiquewhite\": [250, 235, 215],\n        \"aqua\": [0, 255, 255],\n        \"aquamarine\": [127, 255, 212],\n        \"azure\": [240, 255, 255],\n        \"beige\": [245, 245, 220],\n        \"bisque\": [255, 228, 196],\n        \"black\": [0, 0, 0],\n        \"blanchedalmond\": [255, 235, 205],\n        \"blue\": [0, 0, 255],\n        \"blueviolet\": [138, 43, 226],\n        \"brown\": [165, 42, 42],\n        \"burlywood\": [222, 184, 135],\n        \"cadetblue\": [95, 158, 160],\n        \"chartreuse\": [127, 255, 0],\n        \"chocolate\": [210, 105, 30],\n        \"coral\": [255, 127, 80],\n        \"cornflowerblue\": [100, 149, 237],\n        \"cornsilk\": [255, 248, 220],\n        \"crimson\": [220, 20, 60],\n        \"cyan\": [0, 255, 255],\n        \"darkblue\": [0, 0, 139],\n        \"darkcyan\": [0, 139, 139],\n        \"darkgoldenrod\": [184, 134, 11],\n        \"darkgray\": [169, 169, 169],\n        \"darkgreen\": [0, 100, 0],\n        \"darkgrey\": [169, 169, 169],\n        \"darkkhaki\": [189, 183, 107],\n        \"darkmagenta\": [139, 0, 139],\n        \"darkolivegreen\": [85, 107, 47],\n        \"darkorange\": [255, 140, 0],\n        \"darkorchid\": [153, 50, 204],\n        \"darkred\": [139, 0, 0],\n        \"darksalmon\": [233, 150, 122],\n        \"darkseagreen\": [143, 188, 143],\n        \"darkslateblue\": [72, 61, 139],\n        \"darkslategray\": [47, 79, 79],\n        \"darkslategrey\": [47, 79, 79],\n        \"darkturquoise\": [0, 206, 209],\n        \"darkviolet\": [148, 0, 211],\n        \"deeppink\": [255, 20, 147],\n        \"deepskyblue\": [0, 191, 255],\n        \"dimgray\": [105, 105, 105],\n        \"dimgrey\": [105, 105, 105],\n        \"dodgerblue\": [30, 144, 255],\n        \"firebrick\": [178, 34, 34],\n        \"floralwhite\": [255, 250, 240],\n        \"forestgreen\": [34, 139, 34],\n        \"fuchsia\": [255, 0, 255],\n        \"gainsboro\": [220, 220, 220],\n        \"ghostwhite\": [248, 248, 255],\n        \"gold\": [255, 215, 0],\n        \"goldenrod\": [218, 165, 32],\n        \"gray\": [128, 128, 128],\n        \"green\": [0, 128, 0],\n        \"greenyellow\": [173, 255, 47],\n        \"grey\": [128, 128, 128],\n        \"honeydew\": [240, 255, 240],\n        \"hotpink\": [255, 105, 180],\n        \"indianred\": [205, 92, 92],\n        \"indigo\": [75, 0, 130],\n        \"ivory\": [255, 255, 240],\n        \"khaki\": [240, 230, 140],\n        \"lavender\": [230, 230, 250],\n        \"lavenderblush\": [255, 240, 245],\n        \"lawngreen\": [124, 252, 0],\n        \"lemonchiffon\": [255, 250, 205],\n        \"lightblue\": [173, 216, 230],\n        \"lightcoral\": [240, 128, 128],\n        \"lightcyan\": [224, 255, 255],\n        \"lightgoldenrodyellow\": [250, 250, 210],\n        \"lightgray\": [211, 211, 211],\n        \"lightgreen\": [144, 238, 144],\n        \"lightgrey\": [211, 211, 211],\n        \"lightpink\": [255, 182, 193],\n        \"lightsalmon\": [255, 160, 122],\n        \"lightseagreen\": [32, 178, 170],\n        \"lightskyblue\": [135, 206, 250],\n        \"lightslategray\": [119, 136, 153],\n        \"lightslategrey\": [119, 136, 153],\n        \"lightsteelblue\": [176, 196, 222],\n        \"lightyellow\": [255, 255, 224],\n        \"lime\": [0, 255, 0],\n        \"limegreen\": [50, 205, 50],\n        \"linen\": [250, 240, 230],\n        \"magenta\": [255, 0, 255],\n        \"maroon\": [128, 0, 0],\n        \"mediumaquamarine\": [102, 205, 170],\n        \"mediumblue\": [0, 0, 205],\n        \"mediumorchid\": [186, 85, 211],\n        \"mediumpurple\": [147, 112, 219],\n        \"mediumseagreen\": [60, 179, 113],\n        \"mediumslateblue\": [123, 104, 238],\n        \"mediumspringgreen\": [0, 250, 154],\n        \"mediumturquoise\": [72, 209, 204],\n        \"mediumvioletred\": [199, 21, 133],\n        \"midnightblue\": [25, 25, 112],\n        \"mintcream\": [245, 255, 250],\n        \"mistyrose\": [255, 228, 225],\n        \"moccasin\": [255, 228, 181],\n        \"navajowhite\": [255, 222, 173],\n        \"navy\": [0, 0, 128],\n        \"oldlace\": [253, 245, 230],\n        \"olive\": [128, 128, 0],\n        \"olivedrab\": [107, 142, 35],\n        \"orange\": [255, 165, 0],\n        \"orangered\": [255, 69, 0],\n        \"orchid\": [218, 112, 214],\n        \"palegoldenrod\": [238, 232, 170],\n        \"palegreen\": [152, 251, 152],\n        \"paleturquoise\": [175, 238, 238],\n        \"palevioletred\": [219, 112, 147],\n        \"papayawhip\": [255, 239, 213],\n        \"peachpuff\": [255, 218, 185],\n        \"peru\": [205, 133, 63],\n        \"pink\": [255, 192, 203],\n        \"plum\": [221, 160, 221],\n        \"powderblue\": [176, 224, 230],\n        \"purple\": [128, 0, 128],\n        \"rebeccapurple\": [102, 51, 153],\n        \"red\": [255, 0, 0],\n        \"rosybrown\": [188, 143, 143],\n        \"royalblue\": [65, 105, 225],\n        \"saddlebrown\": [139, 69, 19],\n        \"salmon\": [250, 128, 114],\n        \"sandybrown\": [244, 164, 96],\n        \"seagreen\": [46, 139, 87],\n        \"seashell\": [255, 245, 238],\n        \"sienna\": [160, 82, 45],\n        \"silver\": [192, 192, 192],\n        \"skyblue\": [135, 206, 235],\n        \"slateblue\": [106, 90, 205],\n        \"slategray\": [112, 128, 144],\n        \"slategrey\": [112, 128, 144],\n        \"snow\": [255, 250, 250],\n        \"springgreen\": [0, 255, 127],\n        \"steelblue\": [70, 130, 180],\n        \"tan\": [210, 180, 140],\n        \"teal\": [0, 128, 128],\n        \"thistle\": [216, 191, 216],\n        \"tomato\": [255, 99, 71],\n        \"turquoise\": [64, 224, 208],\n        \"violet\": [238, 130, 238],\n        \"wheat\": [245, 222, 179],\n        \"white\": [255, 255, 255],\n        \"whitesmoke\": [245, 245, 245],\n        \"yellow\": [255, 255, 0],\n        \"yellowgreen\": [154, 205, 50]\n    };\n},{}]},{},[1])(1)\n});","Mirasvit_Report/js/lib/moment.min.js":"//! moment.js\n//! version : 2.10.3\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n//! @codingStandardsIgnoreFile\n!function(a,b){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=b():\"function\"==typeof define&&define.amd?define(b):a.moment=b()}(this,function(){\"use strict\";function a(){return Dc.apply(null,arguments)}function b(a){Dc=a}function c(a){return\"[object Array]\"===Object.prototype.toString.call(a)}function d(a){return a instanceof Date||\"[object Date]\"===Object.prototype.toString.call(a)}function e(a,b){var c,d=[];for(c=0;c<a.length;++c)d.push(b(a[c],c));return d}function f(a,b){return Object.prototype.hasOwnProperty.call(a,b)}function g(a,b){for(var c in b)f(b,c)&&(a[c]=b[c]);return f(b,\"toString\")&&(a.toString=b.toString),f(b,\"valueOf\")&&(a.valueOf=b.valueOf),a}function h(a,b,c,d){return za(a,b,c,d,!0).utc()}function i(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1}}function j(a){return null==a._pf&&(a._pf=i()),a._pf}function k(a){if(null==a._isValid){var b=j(a);a._isValid=!isNaN(a._d.getTime())&&b.overflow<0&&!b.empty&&!b.invalidMonth&&!b.nullInput&&!b.invalidFormat&&!b.userInvalidated,a._strict&&(a._isValid=a._isValid&&0===b.charsLeftOver&&0===b.unusedTokens.length&&void 0===b.bigHour)}return a._isValid}function l(a){var b=h(0/0);return null!=a?g(j(b),a):j(b).userInvalidated=!0,b}function m(a,b){var c,d,e;if(\"undefined\"!=typeof b._isAMomentObject&&(a._isAMomentObject=b._isAMomentObject),\"undefined\"!=typeof b._i&&(a._i=b._i),\"undefined\"!=typeof b._f&&(a._f=b._f),\"undefined\"!=typeof b._l&&(a._l=b._l),\"undefined\"!=typeof b._strict&&(a._strict=b._strict),\"undefined\"!=typeof b._tzm&&(a._tzm=b._tzm),\"undefined\"!=typeof b._isUTC&&(a._isUTC=b._isUTC),\"undefined\"!=typeof b._offset&&(a._offset=b._offset),\"undefined\"!=typeof b._pf&&(a._pf=j(b)),\"undefined\"!=typeof b._locale&&(a._locale=b._locale),Fc.length>0)for(c in Fc)d=Fc[c],e=b[d],\"undefined\"!=typeof e&&(a[d]=e);return a}function n(b){m(this,b),this._d=new Date(+b._d),Gc===!1&&(Gc=!0,a.updateOffset(this),Gc=!1)}function o(a){return a instanceof n||null!=a&&null!=a._isAMomentObject}function p(a){var b=+a,c=0;return 0!==b&&isFinite(b)&&(c=b>=0?Math.floor(b):Math.ceil(b)),c}function q(a,b,c){var d,e=Math.min(a.length,b.length),f=Math.abs(a.length-b.length),g=0;for(d=0;e>d;d++)(c&&a[d]!==b[d]||!c&&p(a[d])!==p(b[d]))&&g++;return g+f}function r(){}function s(a){return a?a.toLowerCase().replace(\"_\",\"-\"):a}function t(a){for(var b,c,d,e,f=0;f<a.length;){for(e=s(a[f]).split(\"-\"),b=e.length,c=s(a[f+1]),c=c?c.split(\"-\"):null;b>0;){if(d=u(e.slice(0,b).join(\"-\")))return d;if(c&&c.length>=b&&q(e,c,!0)>=b-1)break;b--}f++}return null}function u(a){var b=null;if(!Hc[a]&&\"undefined\"!=typeof module&&module&&module.exports)try{b=Ec._abbr,require(\"./locale/\"+a),v(b)}catch(c){}return Hc[a]}function v(a,b){var c;return a&&(c=\"undefined\"==typeof b?x(a):w(a,b),c&&(Ec=c)),Ec._abbr}function w(a,b){return null!==b?(b.abbr=a,Hc[a]||(Hc[a]=new r),Hc[a].set(b),v(a),Hc[a]):(delete Hc[a],null)}function x(a){var b;if(a&&a._locale&&a._locale._abbr&&(a=a._locale._abbr),!a)return Ec;if(!c(a)){if(b=u(a))return b;a=[a]}return t(a)}function y(a,b){var c=a.toLowerCase();Ic[c]=Ic[c+\"s\"]=Ic[b]=a}function z(a){return\"string\"==typeof a?Ic[a]||Ic[a.toLowerCase()]:void 0}function A(a){var b,c,d={};for(c in a)f(a,c)&&(b=z(c),b&&(d[b]=a[c]));return d}function B(b,c){return function(d){return null!=d?(D(this,b,d),a.updateOffset(this,c),this):C(this,b)}}function C(a,b){return a._d[\"get\"+(a._isUTC?\"UTC\":\"\")+b]()}function D(a,b,c){return a._d[\"set\"+(a._isUTC?\"UTC\":\"\")+b](c)}function E(a,b){var c;if(\"object\"==typeof a)for(c in a)this.set(c,a[c]);else if(a=z(a),\"function\"==typeof this[a])return this[a](b);return this}function F(a,b,c){for(var d=\"\"+Math.abs(a),e=a>=0;d.length<b;)d=\"0\"+d;return(e?c?\"+\":\"\":\"-\")+d}function G(a,b,c,d){var e=d;\"string\"==typeof d&&(e=function(){return this[d]()}),a&&(Mc[a]=e),b&&(Mc[b[0]]=function(){return F(e.apply(this,arguments),b[1],b[2])}),c&&(Mc[c]=function(){return this.localeData().ordinal(e.apply(this,arguments),a)})}function H(a){return a.match(/\\[[\\s\\S]/)?a.replace(/^\\[|\\]$/g,\"\"):a.replace(/\\\\/g,\"\")}function I(a){var b,c,d=a.match(Jc);for(b=0,c=d.length;c>b;b++)Mc[d[b]]?d[b]=Mc[d[b]]:d[b]=H(d[b]);return function(e){var f=\"\";for(b=0;c>b;b++)f+=d[b]instanceof Function?d[b].call(e,a):d[b];return f}}function J(a,b){return a.isValid()?(b=K(b,a.localeData()),Lc[b]||(Lc[b]=I(b)),Lc[b](a)):a.localeData().invalidDate()}function K(a,b){function c(a){return b.longDateFormat(a)||a}var d=5;for(Kc.lastIndex=0;d>=0&&Kc.test(a);)a=a.replace(Kc,c),Kc.lastIndex=0,d-=1;return a}function L(a,b,c){_c[a]=\"function\"==typeof b?b:function(a){return a&&c?c:b}}function M(a,b){return f(_c,a)?_c[a](b._strict,b._locale):new RegExp(N(a))}function N(a){return a.replace(\"\\\\\",\"\").replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g,function(a,b,c,d,e){return b||c||d||e}).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\")}function O(a,b){var c,d=b;for(\"string\"==typeof a&&(a=[a]),\"number\"==typeof b&&(d=function(a,c){c[b]=p(a)}),c=0;c<a.length;c++)ad[a[c]]=d}function P(a,b){O(a,function(a,c,d,e){d._w=d._w||{},b(a,d._w,d,e)})}function Q(a,b,c){null!=b&&f(ad,a)&&ad[a](b,c._a,c,a)}function R(a,b){return new Date(Date.UTC(a,b+1,0)).getUTCDate()}function S(a){return this._months[a.month()]}function T(a){return this._monthsShort[a.month()]}function U(a,b,c){var d,e,f;for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),d=0;12>d;d++){if(e=h([2e3,d]),c&&!this._longMonthsParse[d]&&(this._longMonthsParse[d]=new RegExp(\"^\"+this.months(e,\"\").replace(\".\",\"\")+\"$\",\"i\"),this._shortMonthsParse[d]=new RegExp(\"^\"+this.monthsShort(e,\"\").replace(\".\",\"\")+\"$\",\"i\")),c||this._monthsParse[d]||(f=\"^\"+this.months(e,\"\")+\"|^\"+this.monthsShort(e,\"\"),this._monthsParse[d]=new RegExp(f.replace(\".\",\"\"),\"i\")),c&&\"MMMM\"===b&&this._longMonthsParse[d].test(a))return d;if(c&&\"MMM\"===b&&this._shortMonthsParse[d].test(a))return d;if(!c&&this._monthsParse[d].test(a))return d}}function V(a,b){var c;return\"string\"==typeof b&&(b=a.localeData().monthsParse(b),\"number\"!=typeof b)?a:(c=Math.min(a.date(),R(a.year(),b)),a._d[\"set\"+(a._isUTC?\"UTC\":\"\")+\"Month\"](b,c),a)}function W(b){return null!=b?(V(this,b),a.updateOffset(this,!0),this):C(this,\"Month\")}function X(){return R(this.year(),this.month())}function Y(a){var b,c=a._a;return c&&-2===j(a).overflow&&(b=c[cd]<0||c[cd]>11?cd:c[dd]<1||c[dd]>R(c[bd],c[cd])?dd:c[ed]<0||c[ed]>24||24===c[ed]&&(0!==c[fd]||0!==c[gd]||0!==c[hd])?ed:c[fd]<0||c[fd]>59?fd:c[gd]<0||c[gd]>59?gd:c[hd]<0||c[hd]>999?hd:-1,j(a)._overflowDayOfYear&&(bd>b||b>dd)&&(b=dd),j(a).overflow=b),a}function Z(b){a.suppressDeprecationWarnings===!1&&\"undefined\"!=typeof console&&console.warn&&console.warn(\"Deprecation warning: \"+b)}function $(a,b){var c=!0,d=a+\"\\n\"+(new Error).stack;return g(function(){return c&&(Z(d),c=!1),b.apply(this,arguments)},b)}function _(a,b){kd[a]||(Z(b),kd[a]=!0)}function aa(a){var b,c,d=a._i,e=ld.exec(d);if(e){for(j(a).iso=!0,b=0,c=md.length;c>b;b++)if(md[b][1].exec(d)){a._f=md[b][0]+(e[6]||\" \");break}for(b=0,c=nd.length;c>b;b++)if(nd[b][1].exec(d)){a._f+=nd[b][0];break}d.match(Yc)&&(a._f+=\"Z\"),ta(a)}else a._isValid=!1}function ba(b){var c=od.exec(b._i);return null!==c?void(b._d=new Date(+c[1])):(aa(b),void(b._isValid===!1&&(delete b._isValid,a.createFromInputFallback(b))))}function ca(a,b,c,d,e,f,g){var h=new Date(a,b,c,d,e,f,g);return 1970>a&&h.setFullYear(a),h}function da(a){var b=new Date(Date.UTC.apply(null,arguments));return 1970>a&&b.setUTCFullYear(a),b}function ea(a){return fa(a)?366:365}function fa(a){return a%4===0&&a%100!==0||a%400===0}function ga(){return fa(this.year())}function ha(a,b,c){var d,e=c-b,f=c-a.day();return f>e&&(f-=7),e-7>f&&(f+=7),d=Aa(a).add(f,\"d\"),{week:Math.ceil(d.dayOfYear()/7),year:d.year()}}function ia(a){return ha(a,this._week.dow,this._week.doy).week}function ja(){return this._week.dow}function ka(){return this._week.doy}function la(a){var b=this.localeData().week(this);return null==a?b:this.add(7*(a-b),\"d\")}function ma(a){var b=ha(this,1,4).week;return null==a?b:this.add(7*(a-b),\"d\")}function na(a,b,c,d,e){var f,g,h=da(a,0,1).getUTCDay();return h=0===h?7:h,c=null!=c?c:e,f=e-h+(h>d?7:0)-(e>h?7:0),g=7*(b-1)+(c-e)+f+1,{year:g>0?a:a-1,dayOfYear:g>0?g:ea(a-1)+g}}function oa(a){var b=Math.round((this.clone().startOf(\"day\")-this.clone().startOf(\"year\"))/864e5)+1;return null==a?b:this.add(a-b,\"d\")}function pa(a,b,c){return null!=a?a:null!=b?b:c}function qa(a){var b=new Date;return a._useUTC?[b.getUTCFullYear(),b.getUTCMonth(),b.getUTCDate()]:[b.getFullYear(),b.getMonth(),b.getDate()]}function ra(a){var b,c,d,e,f=[];if(!a._d){for(d=qa(a),a._w&&null==a._a[dd]&&null==a._a[cd]&&sa(a),a._dayOfYear&&(e=pa(a._a[bd],d[bd]),a._dayOfYear>ea(e)&&(j(a)._overflowDayOfYear=!0),c=da(e,0,a._dayOfYear),a._a[cd]=c.getUTCMonth(),a._a[dd]=c.getUTCDate()),b=0;3>b&&null==a._a[b];++b)a._a[b]=f[b]=d[b];for(;7>b;b++)a._a[b]=f[b]=null==a._a[b]?2===b?1:0:a._a[b];24===a._a[ed]&&0===a._a[fd]&&0===a._a[gd]&&0===a._a[hd]&&(a._nextDay=!0,a._a[ed]=0),a._d=(a._useUTC?da:ca).apply(null,f),null!=a._tzm&&a._d.setUTCMinutes(a._d.getUTCMinutes()-a._tzm),a._nextDay&&(a._a[ed]=24)}}function sa(a){var b,c,d,e,f,g,h;b=a._w,null!=b.GG||null!=b.W||null!=b.E?(f=1,g=4,c=pa(b.GG,a._a[bd],ha(Aa(),1,4).year),d=pa(b.W,1),e=pa(b.E,1)):(f=a._locale._week.dow,g=a._locale._week.doy,c=pa(b.gg,a._a[bd],ha(Aa(),f,g).year),d=pa(b.w,1),null!=b.d?(e=b.d,f>e&&++d):e=null!=b.e?b.e+f:f),h=na(c,d,e,g,f),a._a[bd]=h.year,a._dayOfYear=h.dayOfYear}function ta(b){if(b._f===a.ISO_8601)return void aa(b);b._a=[],j(b).empty=!0;var c,d,e,f,g,h=\"\"+b._i,i=h.length,k=0;for(e=K(b._f,b._locale).match(Jc)||[],c=0;c<e.length;c++)f=e[c],d=(h.match(M(f,b))||[])[0],d&&(g=h.substr(0,h.indexOf(d)),g.length>0&&j(b).unusedInput.push(g),h=h.slice(h.indexOf(d)+d.length),k+=d.length),Mc[f]?(d?j(b).empty=!1:j(b).unusedTokens.push(f),Q(f,d,b)):b._strict&&!d&&j(b).unusedTokens.push(f);j(b).charsLeftOver=i-k,h.length>0&&j(b).unusedInput.push(h),j(b).bigHour===!0&&b._a[ed]<=12&&b._a[ed]>0&&(j(b).bigHour=void 0),b._a[ed]=ua(b._locale,b._a[ed],b._meridiem),ra(b),Y(b)}function ua(a,b,c){var d;return null==c?b:null!=a.meridiemHour?a.meridiemHour(b,c):null!=a.isPM?(d=a.isPM(c),d&&12>b&&(b+=12),d||12!==b||(b=0),b):b}function va(a){var b,c,d,e,f;if(0===a._f.length)return j(a).invalidFormat=!0,void(a._d=new Date(0/0));for(e=0;e<a._f.length;e++)f=0,b=m({},a),null!=a._useUTC&&(b._useUTC=a._useUTC),b._f=a._f[e],ta(b),k(b)&&(f+=j(b).charsLeftOver,f+=10*j(b).unusedTokens.length,j(b).score=f,(null==d||d>f)&&(d=f,c=b));g(a,c||b)}function wa(a){if(!a._d){var b=A(a._i);a._a=[b.year,b.month,b.day||b.date,b.hour,b.minute,b.second,b.millisecond],ra(a)}}function xa(a){var b,e=a._i,f=a._f;return a._locale=a._locale||x(a._l),null===e||void 0===f&&\"\"===e?l({nullInput:!0}):(\"string\"==typeof e&&(a._i=e=a._locale.preparse(e)),o(e)?new n(Y(e)):(c(f)?va(a):f?ta(a):d(e)?a._d=e:ya(a),b=new n(Y(a)),b._nextDay&&(b.add(1,\"d\"),b._nextDay=void 0),b))}function ya(b){var f=b._i;void 0===f?b._d=new Date:d(f)?b._d=new Date(+f):\"string\"==typeof f?ba(b):c(f)?(b._a=e(f.slice(0),function(a){return parseInt(a,10)}),ra(b)):\"object\"==typeof f?wa(b):\"number\"==typeof f?b._d=new Date(f):a.createFromInputFallback(b)}function za(a,b,c,d,e){var f={};return\"boolean\"==typeof c&&(d=c,c=void 0),f._isAMomentObject=!0,f._useUTC=f._isUTC=e,f._l=c,f._i=a,f._f=b,f._strict=d,xa(f)}function Aa(a,b,c,d){return za(a,b,c,d,!1)}function Ba(a,b){var d,e;if(1===b.length&&c(b[0])&&(b=b[0]),!b.length)return Aa();for(d=b[0],e=1;e<b.length;++e)b[e][a](d)&&(d=b[e]);return d}function Ca(){var a=[].slice.call(arguments,0);return Ba(\"isBefore\",a)}function Da(){var a=[].slice.call(arguments,0);return Ba(\"isAfter\",a)}function Ea(a){var b=A(a),c=b.year||0,d=b.quarter||0,e=b.month||0,f=b.week||0,g=b.day||0,h=b.hour||0,i=b.minute||0,j=b.second||0,k=b.millisecond||0;this._milliseconds=+k+1e3*j+6e4*i+36e5*h,this._days=+g+7*f,this._months=+e+3*d+12*c,this._data={},this._locale=x(),this._bubble()}function Fa(a){return a instanceof Ea}function Ga(a,b){G(a,0,0,function(){var a=this.utcOffset(),c=\"+\";return 0>a&&(a=-a,c=\"-\"),c+F(~~(a/60),2)+b+F(~~a%60,2)})}function Ha(a){var b=(a||\"\").match(Yc)||[],c=b[b.length-1]||[],d=(c+\"\").match(td)||[\"-\",0,0],e=+(60*d[1])+p(d[2]);return\"+\"===d[0]?e:-e}function Ia(b,c){var e,f;return c._isUTC?(e=c.clone(),f=(o(b)||d(b)?+b:+Aa(b))-+e,e._d.setTime(+e._d+f),a.updateOffset(e,!1),e):Aa(b).local();return c._isUTC?Aa(b).zone(c._offset||0):Aa(b).local()}function Ja(a){return 15*-Math.round(a._d.getTimezoneOffset()/15)}function Ka(b,c){var d,e=this._offset||0;return null!=b?(\"string\"==typeof b&&(b=Ha(b)),Math.abs(b)<16&&(b=60*b),!this._isUTC&&c&&(d=Ja(this)),this._offset=b,this._isUTC=!0,null!=d&&this.add(d,\"m\"),e!==b&&(!c||this._changeInProgress?$a(this,Va(b-e,\"m\"),1,!1):this._changeInProgress||(this._changeInProgress=!0,a.updateOffset(this,!0),this._changeInProgress=null)),this):this._isUTC?e:Ja(this)}function La(a,b){return null!=a?(\"string\"!=typeof a&&(a=-a),this.utcOffset(a,b),this):-this.utcOffset()}function Ma(a){return this.utcOffset(0,a)}function Na(a){return this._isUTC&&(this.utcOffset(0,a),this._isUTC=!1,a&&this.subtract(Ja(this),\"m\")),this}function Oa(){return this._tzm?this.utcOffset(this._tzm):\"string\"==typeof this._i&&this.utcOffset(Ha(this._i)),this}function Pa(a){return a=a?Aa(a).utcOffset():0,(this.utcOffset()-a)%60===0}function Qa(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function Ra(){if(this._a){var a=this._isUTC?h(this._a):Aa(this._a);return this.isValid()&&q(this._a,a.toArray())>0}return!1}function Sa(){return!this._isUTC}function Ta(){return this._isUTC}function Ua(){return this._isUTC&&0===this._offset}function Va(a,b){var c,d,e,g=a,h=null;return Fa(a)?g={ms:a._milliseconds,d:a._days,M:a._months}:\"number\"==typeof a?(g={},b?g[b]=a:g.milliseconds=a):(h=ud.exec(a))?(c=\"-\"===h[1]?-1:1,g={y:0,d:p(h[dd])*c,h:p(h[ed])*c,m:p(h[fd])*c,s:p(h[gd])*c,ms:p(h[hd])*c}):(h=vd.exec(a))?(c=\"-\"===h[1]?-1:1,g={y:Wa(h[2],c),M:Wa(h[3],c),d:Wa(h[4],c),h:Wa(h[5],c),m:Wa(h[6],c),s:Wa(h[7],c),w:Wa(h[8],c)}):null==g?g={}:\"object\"==typeof g&&(\"from\"in g||\"to\"in g)&&(e=Ya(Aa(g.from),Aa(g.to)),g={},g.ms=e.milliseconds,g.M=e.months),d=new Ea(g),Fa(a)&&f(a,\"_locale\")&&(d._locale=a._locale),d}function Wa(a,b){var c=a&&parseFloat(a.replace(\",\",\".\"));return(isNaN(c)?0:c)*b}function Xa(a,b){var c={milliseconds:0,months:0};return c.months=b.month()-a.month()+12*(b.year()-a.year()),a.clone().add(c.months,\"M\").isAfter(b)&&--c.months,c.milliseconds=+b-+a.clone().add(c.months,\"M\"),c}function Ya(a,b){var c;return b=Ia(b,a),a.isBefore(b)?c=Xa(a,b):(c=Xa(b,a),c.milliseconds=-c.milliseconds,c.months=-c.months),c}function Za(a,b){return function(c,d){var e,f;return null===d||isNaN(+d)||(_(b,\"moment().\"+b+\"(period, number) is deprecated. Please use moment().\"+b+\"(number, period).\"),f=c,c=d,d=f),c=\"string\"==typeof c?+c:c,e=Va(c,d),$a(this,e,a),this}}function $a(b,c,d,e){var f=c._milliseconds,g=c._days,h=c._months;e=null==e?!0:e,f&&b._d.setTime(+b._d+f*d),g&&D(b,\"Date\",C(b,\"Date\")+g*d),h&&V(b,C(b,\"Month\")+h*d),e&&a.updateOffset(b,g||h)}function _a(a){var b=a||Aa(),c=Ia(b,this).startOf(\"day\"),d=this.diff(c,\"days\",!0),e=-6>d?\"sameElse\":-1>d?\"lastWeek\":0>d?\"lastDay\":1>d?\"sameDay\":2>d?\"nextDay\":7>d?\"nextWeek\":\"sameElse\";return this.format(this.localeData().calendar(e,this,Aa(b)))}function ab(){return new n(this)}function bb(a,b){var c;return b=z(\"undefined\"!=typeof b?b:\"millisecond\"),\"millisecond\"===b?(a=o(a)?a:Aa(a),+this>+a):(c=o(a)?+a:+Aa(a),c<+this.clone().startOf(b))}function cb(a,b){var c;return b=z(\"undefined\"!=typeof b?b:\"millisecond\"),\"millisecond\"===b?(a=o(a)?a:Aa(a),+a>+this):(c=o(a)?+a:+Aa(a),+this.clone().endOf(b)<c)}function db(a,b,c){return this.isAfter(a,c)&&this.isBefore(b,c)}function eb(a,b){var c;return b=z(b||\"millisecond\"),\"millisecond\"===b?(a=o(a)?a:Aa(a),+this===+a):(c=+Aa(a),+this.clone().startOf(b)<=c&&c<=+this.clone().endOf(b))}function fb(a){return 0>a?Math.ceil(a):Math.floor(a)}function gb(a,b,c){var d,e,f=Ia(a,this),g=6e4*(f.utcOffset()-this.utcOffset());return b=z(b),\"year\"===b||\"month\"===b||\"quarter\"===b?(e=hb(this,f),\"quarter\"===b?e/=3:\"year\"===b&&(e/=12)):(d=this-f,e=\"second\"===b?d/1e3:\"minute\"===b?d/6e4:\"hour\"===b?d/36e5:\"day\"===b?(d-g)/864e5:\"week\"===b?(d-g)/6048e5:d),c?e:fb(e)}function hb(a,b){var c,d,e=12*(b.year()-a.year())+(b.month()-a.month()),f=a.clone().add(e,\"months\");return 0>b-f?(c=a.clone().add(e-1,\"months\"),d=(b-f)/(f-c)):(c=a.clone().add(e+1,\"months\"),d=(b-f)/(c-f)),-(e+d)}function ib(){return this.clone().locale(\"en\").format(\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\")}function jb(){var a=this.clone().utc();return 0<a.year()&&a.year()<=9999?\"function\"==typeof Date.prototype.toISOString?this.toDate().toISOString():J(a,\"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\"):J(a,\"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\")}function kb(b){var c=J(this,b||a.defaultFormat);return this.localeData().postformat(c)}function lb(a,b){return this.isValid()?Va({to:this,from:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function mb(a){return this.from(Aa(),a)}function nb(a,b){return this.isValid()?Va({from:this,to:a}).locale(this.locale()).humanize(!b):this.localeData().invalidDate()}function ob(a){return this.to(Aa(),a)}function pb(a){var b;return void 0===a?this._locale._abbr:(b=x(a),null!=b&&(this._locale=b),this)}function qb(){return this._locale}function rb(a){switch(a=z(a)){case\"year\":this.month(0);case\"quarter\":case\"month\":this.date(1);case\"week\":case\"isoWeek\":case\"day\":this.hours(0);case\"hour\":this.minutes(0);case\"minute\":this.seconds(0);case\"second\":this.milliseconds(0)}return\"week\"===a&&this.weekday(0),\"isoWeek\"===a&&this.isoWeekday(1),\"quarter\"===a&&this.month(3*Math.floor(this.month()/3)),this}function sb(a){return a=z(a),void 0===a||\"millisecond\"===a?this:this.startOf(a).add(1,\"isoWeek\"===a?\"week\":a).subtract(1,\"ms\")}function tb(){return+this._d-6e4*(this._offset||0)}function ub(){return Math.floor(+this/1e3)}function vb(){return this._offset?new Date(+this):this._d}function wb(){var a=this;return[a.year(),a.month(),a.date(),a.hour(),a.minute(),a.second(),a.millisecond()]}function xb(){return k(this)}function yb(){return g({},j(this))}function zb(){return j(this).overflow}function Ab(a,b){G(0,[a,a.length],0,b)}function Bb(a,b,c){return ha(Aa([a,11,31+b-c]),b,c).week}function Cb(a){var b=ha(this,this.localeData()._week.dow,this.localeData()._week.doy).year;return null==a?b:this.add(a-b,\"y\")}function Db(a){var b=ha(this,1,4).year;return null==a?b:this.add(a-b,\"y\")}function Eb(){return Bb(this.year(),1,4)}function Fb(){var a=this.localeData()._week;return Bb(this.year(),a.dow,a.doy)}function Gb(a){return null==a?Math.ceil((this.month()+1)/3):this.month(3*(a-1)+this.month()%3)}function Hb(a,b){if(\"string\"==typeof a)if(isNaN(a)){if(a=b.weekdaysParse(a),\"number\"!=typeof a)return null}else a=parseInt(a,10);return a}function Ib(a){return this._weekdays[a.day()]}function Jb(a){return this._weekdaysShort[a.day()]}function Kb(a){return this._weekdaysMin[a.day()]}function Lb(a){var b,c,d;for(this._weekdaysParse||(this._weekdaysParse=[]),b=0;7>b;b++)if(this._weekdaysParse[b]||(c=Aa([2e3,1]).day(b),d=\"^\"+this.weekdays(c,\"\")+\"|^\"+this.weekdaysShort(c,\"\")+\"|^\"+this.weekdaysMin(c,\"\"),this._weekdaysParse[b]=new RegExp(d.replace(\".\",\"\"),\"i\")),this._weekdaysParse[b].test(a))return b}function Mb(a){var b=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=a?(a=Hb(a,this.localeData()),this.add(a-b,\"d\")):b}function Nb(a){var b=(this.day()+7-this.localeData()._week.dow)%7;return null==a?b:this.add(a-b,\"d\")}function Ob(a){return null==a?this.day()||7:this.day(this.day()%7?a:a-7)}function Pb(a,b){G(a,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),b)})}function Qb(a,b){return b._meridiemParse}function Rb(a){return\"p\"===(a+\"\").toLowerCase().charAt(0)}function Sb(a,b,c){return a>11?c?\"pm\":\"PM\":c?\"am\":\"AM\"}function Tb(a){G(0,[a,3],0,\"millisecond\")}function Ub(){return this._isUTC?\"UTC\":\"\"}function Vb(){return this._isUTC?\"Coordinated Universal Time\":\"\"}function Wb(a){return Aa(1e3*a)}function Xb(){return Aa.apply(null,arguments).parseZone()}function Yb(a,b,c){var d=this._calendar[a];return\"function\"==typeof d?d.call(b,c):d}function Zb(a){var b=this._longDateFormat[a];return!b&&this._longDateFormat[a.toUpperCase()]&&(b=this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g,function(a){return a.slice(1)}),this._longDateFormat[a]=b),b}function $b(){return this._invalidDate}function _b(a){return this._ordinal.replace(\"%d\",a)}function ac(a){return a}function bc(a,b,c,d){var e=this._relativeTime[c];return\"function\"==typeof e?e(a,b,c,d):e.replace(/%d/i,a)}function cc(a,b){var c=this._relativeTime[a>0?\"future\":\"past\"];return\"function\"==typeof c?c(b):c.replace(/%s/i,b)}function dc(a){var b,c;for(c in a)b=a[c],\"function\"==typeof b?this[c]=b:this[\"_\"+c]=b;this._ordinalParseLenient=new RegExp(this._ordinalParse.source+\"|\"+/\\d{1,2}/.source)}function ec(a,b,c,d){var e=x(),f=h().set(d,b);return e[c](f,a)}function fc(a,b,c,d,e){if(\"number\"==typeof a&&(b=a,a=void 0),a=a||\"\",null!=b)return ec(a,b,c,e);var f,g=[];for(f=0;d>f;f++)g[f]=ec(a,f,c,e);return g}function gc(a,b){return fc(a,b,\"months\",12,\"month\")}function hc(a,b){return fc(a,b,\"monthsShort\",12,\"month\")}function ic(a,b){return fc(a,b,\"weekdays\",7,\"day\")}function jc(a,b){return fc(a,b,\"weekdaysShort\",7,\"day\")}function kc(a,b){return fc(a,b,\"weekdaysMin\",7,\"day\")}function lc(){var a=this._data;return this._milliseconds=Rd(this._milliseconds),this._days=Rd(this._days),this._months=Rd(this._months),a.milliseconds=Rd(a.milliseconds),a.seconds=Rd(a.seconds),a.minutes=Rd(a.minutes),a.hours=Rd(a.hours),a.months=Rd(a.months),a.years=Rd(a.years),this}function mc(a,b,c,d){var e=Va(b,c);return a._milliseconds+=d*e._milliseconds,a._days+=d*e._days,a._months+=d*e._months,a._bubble()}function nc(a,b){return mc(this,a,b,1)}function oc(a,b){return mc(this,a,b,-1)}function pc(){var a,b,c,d=this._milliseconds,e=this._days,f=this._months,g=this._data,h=0;return g.milliseconds=d%1e3,a=fb(d/1e3),g.seconds=a%60,b=fb(a/60),g.minutes=b%60,c=fb(b/60),g.hours=c%24,e+=fb(c/24),h=fb(qc(e)),e-=fb(rc(h)),f+=fb(e/30),e%=30,h+=fb(f/12),f%=12,g.days=e,g.months=f,g.years=h,this}function qc(a){return 400*a/146097}function rc(a){return 146097*a/400}function sc(a){var b,c,d=this._milliseconds;if(a=z(a),\"month\"===a||\"year\"===a)return b=this._days+d/864e5,c=this._months+12*qc(b),\"month\"===a?c:c/12;switch(b=this._days+Math.round(rc(this._months/12)),a){case\"week\":return b/7+d/6048e5;case\"day\":return b+d/864e5;case\"hour\":return 24*b+d/36e5;case\"minute\":return 1440*b+d/6e4;case\"second\":return 86400*b+d/1e3;case\"millisecond\":return Math.floor(864e5*b)+d;default:throw new Error(\"Unknown unit \"+a)}}function tc(){return this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*p(this._months/12)}function uc(a){return function(){return this.as(a)}}function vc(a){return a=z(a),this[a+\"s\"]()}function wc(a){return function(){return this._data[a]}}function xc(){return fb(this.days()/7)}function yc(a,b,c,d,e){return e.relativeTime(b||1,!!c,a,d)}function zc(a,b,c){var d=Va(a).abs(),e=fe(d.as(\"s\")),f=fe(d.as(\"m\")),g=fe(d.as(\"h\")),h=fe(d.as(\"d\")),i=fe(d.as(\"M\")),j=fe(d.as(\"y\")),k=e<ge.s&&[\"s\",e]||1===f&&[\"m\"]||f<ge.m&&[\"mm\",f]||1===g&&[\"h\"]||g<ge.h&&[\"hh\",g]||1===h&&[\"d\"]||h<ge.d&&[\"dd\",h]||1===i&&[\"M\"]||i<ge.M&&[\"MM\",i]||1===j&&[\"y\"]||[\"yy\",j];return k[2]=b,k[3]=+a>0,k[4]=c,yc.apply(null,k)}function Ac(a,b){return void 0===ge[a]?!1:void 0===b?ge[a]:(ge[a]=b,!0)}function Bc(a){var b=this.localeData(),c=zc(this,!a,b);return a&&(c=b.pastFuture(+this,c)),b.postformat(c)}function Cc(){var a=he(this.years()),b=he(this.months()),c=he(this.days()),d=he(this.hours()),e=he(this.minutes()),f=he(this.seconds()+this.milliseconds()/1e3),g=this.asSeconds();return g?(0>g?\"-\":\"\")+\"P\"+(a?a+\"Y\":\"\")+(b?b+\"M\":\"\")+(c?c+\"D\":\"\")+(d||e||f?\"T\":\"\")+(d?d+\"H\":\"\")+(e?e+\"M\":\"\")+(f?f+\"S\":\"\"):\"P0D\"}var Dc,Ec,Fc=a.momentProperties=[],Gc=!1,Hc={},Ic={},Jc=/(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,Kc=/(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Lc={},Mc={},Nc=/\\d/,Oc=/\\d\\d/,Pc=/\\d{3}/,Qc=/\\d{4}/,Rc=/[+-]?\\d{6}/,Sc=/\\d\\d?/,Tc=/\\d{1,3}/,Uc=/\\d{1,4}/,Vc=/[+-]?\\d{1,6}/,Wc=/\\d+/,Xc=/[+-]?\\d+/,Yc=/Z|[+-]\\d\\d:?\\d\\d/gi,Zc=/[+-]?\\d+(\\.\\d{1,3})?/,$c=/[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i,_c={},ad={},bd=0,cd=1,dd=2,ed=3,fd=4,gd=5,hd=6;G(\"M\",[\"MM\",2],\"Mo\",function(){return this.month()+1}),G(\"MMM\",0,0,function(a){return this.localeData().monthsShort(this,a)}),G(\"MMMM\",0,0,function(a){return this.localeData().months(this,a)}),y(\"month\",\"M\"),L(\"M\",Sc),L(\"MM\",Sc,Oc),L(\"MMM\",$c),L(\"MMMM\",$c),O([\"M\",\"MM\"],function(a,b){b[cd]=p(a)-1}),O([\"MMM\",\"MMMM\"],function(a,b,c,d){var e=c._locale.monthsParse(a,d,c._strict);null!=e?b[cd]=e:j(c).invalidMonth=a});var id=\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),jd=\"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\".split(\"_\"),kd={};a.suppressDeprecationWarnings=!1;var ld=/^\\s*(?:[+-]\\d{6}|\\d{4})-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,md=[[\"YYYYYY-MM-DD\",/[+-]\\d{6}-\\d{2}-\\d{2}/],[\"YYYY-MM-DD\",/\\d{4}-\\d{2}-\\d{2}/],[\"GGGG-[W]WW-E\",/\\d{4}-W\\d{2}-\\d/],[\"GGGG-[W]WW\",/\\d{4}-W\\d{2}/],[\"YYYY-DDD\",/\\d{4}-\\d{3}/]],nd=[[\"HH:mm:ss.SSSS\",/(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d+/],[\"HH:mm:ss\",/(T| )\\d\\d:\\d\\d:\\d\\d/],[\"HH:mm\",/(T| )\\d\\d:\\d\\d/],[\"HH\",/(T| )\\d\\d/]],od=/^\\/?Date\\((\\-?\\d+)/i;a.createFromInputFallback=$(\"moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.\",function(a){a._d=new Date(a._i+(a._useUTC?\" UTC\":\"\"))}),G(0,[\"YY\",2],0,function(){return this.year()%100}),G(0,[\"YYYY\",4],0,\"year\"),G(0,[\"YYYYY\",5],0,\"year\"),G(0,[\"YYYYYY\",6,!0],0,\"year\"),y(\"year\",\"y\"),L(\"Y\",Xc),L(\"YY\",Sc,Oc),L(\"YYYY\",Uc,Qc),L(\"YYYYY\",Vc,Rc),L(\"YYYYYY\",Vc,Rc),O([\"YYYY\",\"YYYYY\",\"YYYYYY\"],bd),O(\"YY\",function(b,c){c[bd]=a.parseTwoDigitYear(b)}),a.parseTwoDigitYear=function(a){return p(a)+(p(a)>68?1900:2e3)};var pd=B(\"FullYear\",!1);G(\"w\",[\"ww\",2],\"wo\",\"week\"),G(\"W\",[\"WW\",2],\"Wo\",\"isoWeek\"),y(\"week\",\"w\"),y(\"isoWeek\",\"W\"),L(\"w\",Sc),L(\"ww\",Sc,Oc),L(\"W\",Sc),L(\"WW\",Sc,Oc),P([\"w\",\"ww\",\"W\",\"WW\"],function(a,b,c,d){b[d.substr(0,1)]=p(a)});var qd={dow:0,doy:6};G(\"DDD\",[\"DDDD\",3],\"DDDo\",\"dayOfYear\"),y(\"dayOfYear\",\"DDD\"),L(\"DDD\",Tc),L(\"DDDD\",Pc),O([\"DDD\",\"DDDD\"],function(a,b,c){c._dayOfYear=p(a)}),a.ISO_8601=function(){};var rd=$(\"moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548\",function(){var a=Aa.apply(null,arguments);return this>a?this:a}),sd=$(\"moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548\",function(){var a=Aa.apply(null,arguments);return a>this?this:a});Ga(\"Z\",\":\"),Ga(\"ZZ\",\"\"),L(\"Z\",Yc),L(\"ZZ\",Yc),O([\"Z\",\"ZZ\"],function(a,b,c){c._useUTC=!0,c._tzm=Ha(a)});var td=/([\\+\\-]|\\d\\d)/gi;a.updateOffset=function(){};var ud=/(\\-)?(?:(\\d*)\\.)?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?)?/,vd=/^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;Va.fn=Ea.prototype;var wd=Za(1,\"add\"),xd=Za(-1,\"subtract\");a.defaultFormat=\"YYYY-MM-DDTHH:mm:ssZ\";var yd=$(\"moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.\",function(a){return void 0===a?this.localeData():this.locale(a)});G(0,[\"gg\",2],0,function(){return this.weekYear()%100}),G(0,[\"GG\",2],0,function(){return this.isoWeekYear()%100}),Ab(\"gggg\",\"weekYear\"),Ab(\"ggggg\",\"weekYear\"),Ab(\"GGGG\",\"isoWeekYear\"),Ab(\"GGGGG\",\"isoWeekYear\"),y(\"weekYear\",\"gg\"),y(\"isoWeekYear\",\"GG\"),L(\"G\",Xc),L(\"g\",Xc),L(\"GG\",Sc,Oc),L(\"gg\",Sc,Oc),L(\"GGGG\",Uc,Qc),L(\"gggg\",Uc,Qc),L(\"GGGGG\",Vc,Rc),L(\"ggggg\",Vc,Rc),P([\"gggg\",\"ggggg\",\"GGGG\",\"GGGGG\"],function(a,b,c,d){b[d.substr(0,2)]=p(a)}),P([\"gg\",\"GG\"],function(b,c,d,e){c[e]=a.parseTwoDigitYear(b)}),G(\"Q\",0,0,\"quarter\"),y(\"quarter\",\"Q\"),L(\"Q\",Nc),O(\"Q\",function(a,b){b[cd]=3*(p(a)-1)}),G(\"D\",[\"DD\",2],\"Do\",\"date\"),y(\"date\",\"D\"),L(\"D\",Sc),L(\"DD\",Sc,Oc),L(\"Do\",function(a,b){return a?b._ordinalParse:b._ordinalParseLenient}),O([\"D\",\"DD\"],dd),O(\"Do\",function(a,b){b[dd]=p(a.match(Sc)[0],10)});var zd=B(\"Date\",!0);G(\"d\",0,\"do\",\"day\"),G(\"dd\",0,0,function(a){return this.localeData().weekdaysMin(this,a)}),G(\"ddd\",0,0,function(a){return this.localeData().weekdaysShort(this,a)}),G(\"dddd\",0,0,function(a){return this.localeData().weekdays(this,a)}),G(\"e\",0,0,\"weekday\"),G(\"E\",0,0,\"isoWeekday\"),y(\"day\",\"d\"),y(\"weekday\",\"e\"),y(\"isoWeekday\",\"E\"),L(\"d\",Sc),L(\"e\",Sc),L(\"E\",Sc),L(\"dd\",$c),L(\"ddd\",$c),L(\"dddd\",$c),P([\"dd\",\"ddd\",\"dddd\"],function(a,b,c){var d=c._locale.weekdaysParse(a);null!=d?b.d=d:j(c).invalidWeekday=a}),P([\"d\",\"e\",\"E\"],function(a,b,c,d){b[d]=p(a)});var Ad=\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),Bd=\"Sun_Mon_Tue_Wed_Thu_Fri_Sat\".split(\"_\"),Cd=\"Su_Mo_Tu_We_Th_Fr_Sa\".split(\"_\");G(\"H\",[\"HH\",2],0,\"hour\"),G(\"h\",[\"hh\",2],0,function(){return this.hours()%12||12}),Pb(\"a\",!0),Pb(\"A\",!1),y(\"hour\",\"h\"),L(\"a\",Qb),L(\"A\",Qb),L(\"H\",Sc),L(\"h\",Sc),L(\"HH\",Sc,Oc),L(\"hh\",Sc,Oc),O([\"H\",\"HH\"],ed),O([\"a\",\"A\"],function(a,b,c){c._isPm=c._locale.isPM(a),c._meridiem=a}),O([\"h\",\"hh\"],function(a,b,c){b[ed]=p(a),j(c).bigHour=!0});var Dd=/[ap]\\.?m?\\.?/i,Ed=B(\"Hours\",!0);G(\"m\",[\"mm\",2],0,\"minute\"),y(\"minute\",\"m\"),L(\"m\",Sc),L(\"mm\",Sc,Oc),O([\"m\",\"mm\"],fd);var Fd=B(\"Minutes\",!1);G(\"s\",[\"ss\",2],0,\"second\"),y(\"second\",\"s\"),L(\"s\",Sc),L(\"ss\",Sc,Oc),O([\"s\",\"ss\"],gd);var Gd=B(\"Seconds\",!1);G(\"S\",0,0,function(){return~~(this.millisecond()/100)}),G(0,[\"SS\",2],0,function(){return~~(this.millisecond()/10)}),Tb(\"SSS\"),Tb(\"SSSS\"),y(\"millisecond\",\"ms\"),L(\"S\",Tc,Nc),L(\"SS\",Tc,Oc),L(\"SSS\",Tc,Pc),L(\"SSSS\",Wc),O([\"S\",\"SS\",\"SSS\",\"SSSS\"],function(a,b){b[hd]=p(1e3*(\"0.\"+a))});var Hd=B(\"Milliseconds\",!1);G(\"z\",0,0,\"zoneAbbr\"),G(\"zz\",0,0,\"zoneName\");var Id=n.prototype;Id.add=wd,Id.calendar=_a,Id.clone=ab,Id.diff=gb,Id.endOf=sb,Id.format=kb,Id.from=lb,Id.fromNow=mb,Id.to=nb,Id.toNow=ob,Id.get=E,Id.invalidAt=zb,Id.isAfter=bb,Id.isBefore=cb,Id.isBetween=db,Id.isSame=eb,Id.isValid=xb,Id.lang=yd,Id.locale=pb,Id.localeData=qb,Id.max=sd,Id.min=rd,Id.parsingFlags=yb,Id.set=E,Id.startOf=rb,Id.subtract=xd,Id.toArray=wb,Id.toDate=vb,Id.toISOString=jb,Id.toJSON=jb,Id.toString=ib,Id.unix=ub,Id.valueOf=tb,Id.year=pd,Id.isLeapYear=ga,Id.weekYear=Cb,Id.isoWeekYear=Db,Id.quarter=Id.quarters=Gb,Id.month=W,Id.daysInMonth=X,Id.week=Id.weeks=la,Id.isoWeek=Id.isoWeeks=ma,Id.weeksInYear=Fb,Id.isoWeeksInYear=Eb,Id.date=zd,Id.day=Id.days=Mb,Id.weekday=Nb,Id.isoWeekday=Ob,Id.dayOfYear=oa,Id.hour=Id.hours=Ed,Id.minute=Id.minutes=Fd,Id.second=Id.seconds=Gd,Id.millisecond=Id.milliseconds=Hd,Id.utcOffset=Ka,Id.utc=Ma,Id.local=Na,Id.parseZone=Oa,Id.hasAlignedHourOffset=Pa,Id.isDST=Qa,Id.isDSTShifted=Ra,Id.isLocal=Sa,Id.isUtcOffset=Ta,Id.isUtc=Ua,Id.isUTC=Ua,Id.zoneAbbr=Ub,Id.zoneName=Vb,Id.dates=$(\"dates accessor is deprecated. Use date instead.\",zd),Id.months=$(\"months accessor is deprecated. Use month instead\",W),Id.years=$(\"years accessor is deprecated. Use year instead\",pd),Id.zone=$(\"moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779\",La);var Jd=Id,Kd={sameDay:\"[Today at] LT\",nextDay:\"[Tomorrow at] LT\",nextWeek:\"dddd [at] LT\",lastDay:\"[Yesterday at] LT\",lastWeek:\"[Last] dddd [at] LT\",sameElse:\"L\"},Ld={LTS:\"h:mm:ss A\",LT:\"h:mm A\",L:\"MM/DD/YYYY\",LL:\"MMMM D, YYYY\",LLL:\"MMMM D, YYYY LT\",LLLL:\"dddd, MMMM D, YYYY LT\"},Md=\"Invalid date\",Nd=\"%d\",Od=/\\d{1,2}/,Pd={future:\"in %s\",past:\"%s ago\",s:\"a few seconds\",m:\"a minute\",mm:\"%d minutes\",h:\"an hour\",\nhh:\"%d hours\",d:\"a day\",dd:\"%d days\",M:\"a month\",MM:\"%d months\",y:\"a year\",yy:\"%d years\"},Qd=r.prototype;Qd._calendar=Kd,Qd.calendar=Yb,Qd._longDateFormat=Ld,Qd.longDateFormat=Zb,Qd._invalidDate=Md,Qd.invalidDate=$b,Qd._ordinal=Nd,Qd.ordinal=_b,Qd._ordinalParse=Od,Qd.preparse=ac,Qd.postformat=ac,Qd._relativeTime=Pd,Qd.relativeTime=bc,Qd.pastFuture=cc,Qd.set=dc,Qd.months=S,Qd._months=id,Qd.monthsShort=T,Qd._monthsShort=jd,Qd.monthsParse=U,Qd.week=ia,Qd._week=qd,Qd.firstDayOfYear=ka,Qd.firstDayOfWeek=ja,Qd.weekdays=Ib,Qd._weekdays=Ad,Qd.weekdaysMin=Kb,Qd._weekdaysMin=Cd,Qd.weekdaysShort=Jb,Qd._weekdaysShort=Bd,Qd.weekdaysParse=Lb,Qd.isPM=Rb,Qd._meridiemParse=Dd,Qd.meridiem=Sb,v(\"en\",{ordinalParse:/\\d{1,2}(th|st|nd|rd)/,ordinal:function(a){var b=a%10,c=1===p(a%100/10)?\"th\":1===b?\"st\":2===b?\"nd\":3===b?\"rd\":\"th\";return a+c}}),a.lang=$(\"moment.lang is deprecated. Use moment.locale instead.\",v),a.langData=$(\"moment.langData is deprecated. Use moment.localeData instead.\",x);var Rd=Math.abs,Sd=uc(\"ms\"),Td=uc(\"s\"),Ud=uc(\"m\"),Vd=uc(\"h\"),Wd=uc(\"d\"),Xd=uc(\"w\"),Yd=uc(\"M\"),Zd=uc(\"y\"),$d=wc(\"milliseconds\"),_d=wc(\"seconds\"),ae=wc(\"minutes\"),be=wc(\"hours\"),ce=wc(\"days\"),de=wc(\"months\"),ee=wc(\"years\"),fe=Math.round,ge={s:45,m:45,h:22,d:26,M:11},he=Math.abs,ie=Ea.prototype;ie.abs=lc,ie.add=nc,ie.subtract=oc,ie.as=sc,ie.asMilliseconds=Sd,ie.asSeconds=Td,ie.asMinutes=Ud,ie.asHours=Vd,ie.asDays=Wd,ie.asWeeks=Xd,ie.asMonths=Yd,ie.asYears=Zd,ie.valueOf=tc,ie._bubble=pc,ie.get=vc,ie.milliseconds=$d,ie.seconds=_d,ie.minutes=ae,ie.hours=be,ie.days=ce,ie.weeks=xc,ie.months=de,ie.years=ee,ie.humanize=Bc,ie.toISOString=Cc,ie.toString=Cc,ie.toJSON=Cc,ie.locale=pb,ie.localeData=qb,ie.toIsoString=$(\"toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)\",Cc),ie.lang=yd,G(\"X\",0,0,\"unix\"),G(\"x\",0,0,\"valueOf\"),L(\"x\",Xc),L(\"X\",Zc),O(\"X\",function(a,b,c){c._d=new Date(1e3*parseFloat(a,10))}),O(\"x\",function(a,b,c){c._d=new Date(p(a))}),a.version=\"2.10.3\",b(Aa),a.fn=Jd,a.min=Ca,a.max=Da,a.utc=h,a.unix=Wb,a.months=gc,a.isDate=d,a.locale=v,a.invalid=l,a.duration=Va,a.isMoment=o,a.weekdays=ic,a.parseZone=Xb,a.localeData=x,a.isDuration=Fa,a.monthsShort=hc,a.weekdaysMin=kc,a.defineLocale=w,a.weekdaysShort=jc,a.normalizeUnits=z,a.relativeTimeThreshold=Ac;var je=a;return je});","Mirasvit_Report/js/lib/daterangepicker/daterange.js":"/**\n * DatePicker 1.0.0\n *\n * A jQuery-based DatePicker that provides an easy way of creating both single\n * and multi-viewed calendars capable of accepting single, range, and multiple\n * selected dates.  Easily styled with two example styles provided: an attractive\n * 'dark' style, and a Google Analytics-like 'clean' style.\n *\n * View project page for Examples and Documentation:\n * http://foxrunsoftware.github.com/DatePicker/\n *\n * This project is distinct from and not affiliated with the jquery.ui.datepicker.\n *\n * Copyright 2012, Justin Stern (www.foxrunsoftware.net)\n * Dual licensed under the MIT and GPL Version 2 licenses.\n *\n * Based on Work by Original Author: Stefan Petre www.eyecon.ro\n *\n * Depends:\n *   jquery.js\n */\n(function ($) {\n    var cache = {}, tmpl,\n        DatePicker = function () {\n            var ids = {},\n                views = {\n                    years: 'datepickerViewYears',\n                    moths: 'datepickerViewMonths',\n                    days:  'datepickerViewDays'\n                },\n                tpl = {\n                    wrapper: '<div class=\"datepicker\"><div class=\"datepickerContainer\"><table cellspacing=\"0\" cellpadding=\"0\"><tbody><tr></tr></tbody></table></div></div>',\n                    head:    [\n                        '<td class=\"datepickerBlock\">',\n                        '<table cellspacing=\"0\" cellpadding=\"0\">',\n                        '<thead>',\n                        '<tr>',\n                        '<th colspan=\"7\"><a class=\"datepickerGoPrev\" href=\"#\"><span><%=prev%></span></a>',\n                        '<a class=\"datepickerMonth\" href=\"#\"><span></span></a>',\n                        '<a class=\"datepickerGoNext\" href=\"#\"><span><%=next%></span></a></th>',\n                        '</tr>',\n                        '<tr class=\"datepickerDoW\">',\n                        '<th><span><%=day1%></span></th>',\n                        '<th><span><%=day2%></span></th>',\n                        '<th><span><%=day3%></span></th>',\n                        '<th><span><%=day4%></span></th>',\n                        '<th><span><%=day5%></span></th>',\n                        '<th><span><%=day6%></span></th>',\n                        '<th><span><%=day7%></span></th>',\n                        '</tr>',\n                        '</thead>',\n                        '</table></td>'\n                    ],\n                    space:   '<td class=\"datepickerSpace\"><div></div></td>',\n                    days:    [\n                        '<tbody class=\"datepickerDays\">',\n                        '<tr>',\n                        '<td class=\"<%=weeks[0].days[0].classname%>\"><a href=\"#\"><span><%=weeks[0].days[0].text%></span></a></td>',\n                        '<td class=\"<%=weeks[0].days[1].classname%>\"><a href=\"#\"><span><%=weeks[0].days[1].text%></span></a></td>',\n                        '<td class=\"<%=weeks[0].days[2].classname%>\"><a href=\"#\"><span><%=weeks[0].days[2].text%></span></a></td>',\n                        '<td class=\"<%=weeks[0].days[3].classname%>\"><a href=\"#\"><span><%=weeks[0].days[3].text%></span></a></td>',\n                        '<td class=\"<%=weeks[0].days[4].classname%>\"><a href=\"#\"><span><%=weeks[0].days[4].text%></span></a></td>',\n                        '<td class=\"<%=weeks[0].days[5].classname%>\"><a href=\"#\"><span><%=weeks[0].days[5].text%></span></a></td>',\n                        '<td class=\"<%=weeks[0].days[6].classname%>\"><a href=\"#\"><span><%=weeks[0].days[6].text%></span></a></td>',\n                        '</tr>',\n                        '<tr>',\n                        '<td class=\"<%=weeks[1].days[0].classname%>\"><a href=\"#\"><span><%=weeks[1].days[0].text%></span></a></td>',\n                        '<td class=\"<%=weeks[1].days[1].classname%>\"><a href=\"#\"><span><%=weeks[1].days[1].text%></span></a></td>',\n                        '<td class=\"<%=weeks[1].days[2].classname%>\"><a href=\"#\"><span><%=weeks[1].days[2].text%></span></a></td>',\n                        '<td class=\"<%=weeks[1].days[3].classname%>\"><a href=\"#\"><span><%=weeks[1].days[3].text%></span></a></td>',\n                        '<td class=\"<%=weeks[1].days[4].classname%>\"><a href=\"#\"><span><%=weeks[1].days[4].text%></span></a></td>',\n                        '<td class=\"<%=weeks[1].days[5].classname%>\"><a href=\"#\"><span><%=weeks[1].days[5].text%></span></a></td>',\n                        '<td class=\"<%=weeks[1].days[6].classname%>\"><a href=\"#\"><span><%=weeks[1].days[6].text%></span></a></td>',\n                        '</tr>',\n                        '<tr>',\n                        '<td class=\"<%=weeks[2].days[0].classname%>\"><a href=\"#\"><span><%=weeks[2].days[0].text%></span></a></td>',\n                        '<td class=\"<%=weeks[2].days[1].classname%>\"><a href=\"#\"><span><%=weeks[2].days[1].text%></span></a></td>',\n                        '<td class=\"<%=weeks[2].days[2].classname%>\"><a href=\"#\"><span><%=weeks[2].days[2].text%></span></a></td>',\n                        '<td class=\"<%=weeks[2].days[3].classname%>\"><a href=\"#\"><span><%=weeks[2].days[3].text%></span></a></td>',\n                        '<td class=\"<%=weeks[2].days[4].classname%>\"><a href=\"#\"><span><%=weeks[2].days[4].text%></span></a></td>',\n                        '<td class=\"<%=weeks[2].days[5].classname%>\"><a href=\"#\"><span><%=weeks[2].days[5].text%></span></a></td>',\n                        '<td class=\"<%=weeks[2].days[6].classname%>\"><a href=\"#\"><span><%=weeks[2].days[6].text%></span></a></td>',\n                        '</tr>',\n                        '<tr>',\n                        '<td class=\"<%=weeks[3].days[0].classname%>\"><a href=\"#\"><span><%=weeks[3].days[0].text%></span></a></td>',\n                        '<td class=\"<%=weeks[3].days[1].classname%>\"><a href=\"#\"><span><%=weeks[3].days[1].text%></span></a></td>',\n                        '<td class=\"<%=weeks[3].days[2].classname%>\"><a href=\"#\"><span><%=weeks[3].days[2].text%></span></a></td>',\n                        '<td class=\"<%=weeks[3].days[3].classname%>\"><a href=\"#\"><span><%=weeks[3].days[3].text%></span></a></td>',\n                        '<td class=\"<%=weeks[3].days[4].classname%>\"><a href=\"#\"><span><%=weeks[3].days[4].text%></span></a></td>',\n                        '<td class=\"<%=weeks[3].days[5].classname%>\"><a href=\"#\"><span><%=weeks[3].days[5].text%></span></a></td>',\n                        '<td class=\"<%=weeks[3].days[6].classname%>\"><a href=\"#\"><span><%=weeks[3].days[6].text%></span></a></td>',\n                        '</tr>',\n                        '<tr>',\n                        '<td class=\"<%=weeks[4].days[0].classname%>\"><a href=\"#\"><span><%=weeks[4].days[0].text%></span></a></td>',\n                        '<td class=\"<%=weeks[4].days[1].classname%>\"><a href=\"#\"><span><%=weeks[4].days[1].text%></span></a></td>',\n                        '<td class=\"<%=weeks[4].days[2].classname%>\"><a href=\"#\"><span><%=weeks[4].days[2].text%></span></a></td>',\n                        '<td class=\"<%=weeks[4].days[3].classname%>\"><a href=\"#\"><span><%=weeks[4].days[3].text%></span></a></td>',\n                        '<td class=\"<%=weeks[4].days[4].classname%>\"><a href=\"#\"><span><%=weeks[4].days[4].text%></span></a></td>',\n                        '<td class=\"<%=weeks[4].days[5].classname%>\"><a href=\"#\"><span><%=weeks[4].days[5].text%></span></a></td>',\n                        '<td class=\"<%=weeks[4].days[6].classname%>\"><a href=\"#\"><span><%=weeks[4].days[6].text%></span></a></td>',\n                        '</tr>',\n                        '<tr>',\n                        '<td class=\"<%=weeks[5].days[0].classname%>\"><a href=\"#\"><span><%=weeks[5].days[0].text%></span></a></td>',\n                        '<td class=\"<%=weeks[5].days[1].classname%>\"><a href=\"#\"><span><%=weeks[5].days[1].text%></span></a></td>',\n                        '<td class=\"<%=weeks[5].days[2].classname%>\"><a href=\"#\"><span><%=weeks[5].days[2].text%></span></a></td>',\n                        '<td class=\"<%=weeks[5].days[3].classname%>\"><a href=\"#\"><span><%=weeks[5].days[3].text%></span></a></td>',\n                        '<td class=\"<%=weeks[5].days[4].classname%>\"><a href=\"#\"><span><%=weeks[5].days[4].text%></span></a></td>',\n                        '<td class=\"<%=weeks[5].days[5].classname%>\"><a href=\"#\"><span><%=weeks[5].days[5].text%></span></a></td>',\n                        '<td class=\"<%=weeks[5].days[6].classname%>\"><a href=\"#\"><span><%=weeks[5].days[6].text%></span></a></td>',\n                        '</tr>',\n                        '</tbody>'\n                    ],\n                    months:  [\n                        '<tbody class=\"<%=className%>\">',\n                        '<tr>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[0]%></span></a></td>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[1]%></span></a></td>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[2]%></span></a></td>',\n                        '<td colspan=\"1\"><a href=\"#\"><span><%=data[3]%></span></a></td>',\n                        '</tr>',\n                        '<tr>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[4]%></span></a></td>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[5]%></span></a></td>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[6]%></span></a></td>',\n                        '<td colspan=\"1\"><a href=\"#\"><span><%=data[7]%></span></a></td>',\n                        '</tr>',\n                        '<tr>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[8]%></span></a></td>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[9]%></span></a></td>',\n                        '<td colspan=\"2\"><a href=\"#\"><span><%=data[10]%></span></a></td>',\n                        '<td colspan=\"1\"><a href=\"#\"><span><%=data[11]%></span></a></td>',\n                        '</tr>',\n                        '</tbody>'\n                    ]\n                },\n                defaults = {\n                    /**\n                     * The currently selected date(s).  This can be: a single date, an array\n                     * of two dates (sets a range when 'mode' is 'range'), or an array of\n                     * any number of dates (selects all dates when 'mode' is 'multiple'.\n                     * The supplied dates can be any one of: Date object, milliseconds\n                     * (as from date.getTime(), date.valueOf()), or a date string\n                     * parseable by Date.parse().\n                     */\n                    date:            null,\n                    /**\n                     * Optional date which determines the current calendar month/year.  This\n                     * can be one of: Date object, milliseconds (as from date.getTime(), date.valueOf()), or a date string\n                     * parseable by Date.parse().  Defaults to todays date.\n                     */\n                    current:         null,\n                    /**\n                     * Optional date range which limits the selectable dates. The range of acceptable dates,\n                     * in an array of [min, max], disables any date outside of the range. Arguments should be\n                     * Date objects.\n                     */\n                    selectableDates: null,\n                    /**\n                     * true causes the datepicker calendar to be appended to the DatePicker\n                     * element and rendered, false binds the DatePicker to an event on the trigger element\n                     */\n                    inline:          false,\n                    /**\n                     * Date selection mode, one of 'single', 'range' or 'multiple'.  Default\n                     * 'single'.  'Single' allows the selection of a single date, 'range'\n                     * allows the selection of range of dates, and 'multiple' allows the\n                     * selection of any number of individual dates.\n                     */\n                    mode:            'single',\n                    /**\n                     * Number of side-by-side calendars, defaults to 1.\n                     */\n                    calendars:       1,\n                    /**\n                     * The day that starts the week, where 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, 4: Thursday, 5: Friday, 6: Saturday.  Defaults to Sunday\n                     */\n                    starts:          0,\n                    /**\n                     * Previous link text.  Default '&#9664;' (Unicode left arrow)\n                     */\n                    prev:            '&#9664;',\n                    /**\n                     * Next link text.  Default '&#9664;' (Unicode left arrow)\n                     */\n                    next:            '&#9654;',\n                    /**\n                     * Initial calendar view, one of 'days', 'months' or 'years'.  Defaults to 'days'.\n                     */\n                    view:            'days',\n                    /**\n                     * Date picker's position relative to the trigger element (non inline\n                     * mode only), one of 'top', 'left', 'right' or 'bottom'. Defaults to 'bottom'\n                     */\n                    position:        'bottom',\n                    /**\n                     * The trigger event used to show a non-inline calendar.  Defaults to\n                     * 'focus' which is useful when the trigger element is a text input,\n                     * can also be 'click' for instance if the trigger element is a button\n                     * or some text element.\n                     */\n                    showOn:          'focus',\n                    /**\n                     * Callback, invoked prior to the rendering of each date cell, which\n                     * allows control of the styling of the cell via the returned hash.\n                     *\n                     * @param HTMLDivElement el the datepicker containing element, ie the\n                     *        div with class 'datepicker'\n                     * @param Date date the date that will be rendered\n                     * @return hash with the following optional attributes:\n                     *         selected: if true, date will be selected\n                     *         disabled: if true, date cell will be disabled\n                     *         className: css class name to add to the cell\n                     */\n                    onRenderCell:    function () {\n                        return {}\n                    },\n                    /*\n                     * Callback, invoked when a date is selected, with 'this' referring to\n                     * the HTMLElement that DatePicker was invoked upon.\n                     *\n                     * @param dates: Selected date(s) depending on calendar mode.  When calendar mode  is 'single' this\n                     *        is a single Date object.  When calendar mode is 'range', this is an array containing\n                     *        a 'from' and 'to' Date objects.  When calendar mode is 'multiple' this is an array\n                     *        of Date objects.\n                     * @param HTMLElement el the DatePicker element, ie the element that DatePicker was invoked upon\n                     */\n                    onChange:        function () {\n                    },\n                    /*\n                     * Callback, invoked when a date range is selected, with 'this' referring to\n                     * the HTMLElement that DatePicker was invoked upon.\n                     *\n                     * @param dates: Selected date(s), ie an array containing a 'from' and 'to' Date objects.\n                     * @param HTMLElement el the DatePicker element, ie the element that DatePicker was invoked upon\n                     */\n                    onRangeChange:   function () {\n                    },\n                    /**\n                     * Invoked before a non-inline datepicker is shown, with 'this'\n                     * referring to the HTMLElement that DatePicker was invoked upon, ie\n                     * the trigger element\n                     *\n                     * @param HTMLDivElement el The datepicker container element, ie the div with class 'datepicker'.\n                     * @return true to allow the datepicker to be shown, false to keep it hidden\n                     */\n\n                    onBeforeShow:    function () {\n                        return true\n                    },\n                    /**\n                     * Invoked after a non-inline datepicker is shown, with 'this'\n                     * referring to the HTMLElement that DatePicker was invoked upon, ie\n                     * the trigger element\n                     *\n                     * @param HTMLDivElement el The datepicker container element, ie the div with class 'datepicker'\n                     */\n                    onAfterShow:     function () {\n                    },\n                    /**\n                     * Invoked before a non-inline datepicker is hidden, with 'this'\n                     * referring to the HTMLElement that DatePicker was invoked upon, ie\n                     * the trigger element\n                     *\n                     * @param HTMLDivElement el The datepicker container element, ie the div with class 'datepicker'\n                     * @return true to allow the datepicker to be hidden, false to keep it visible\n                     */\n                    onBeforeHide:    function () {\n                        return true\n                    },\n                    /**\n                     * Invoked after a non-inline datepicker is hidden, with 'this'\n                     * referring to the HTMLElement that DatePicker was invoked upon, ie\n                     * the trigger element\n                     *\n                     * @param HTMLDivElement el The datepicker container element, ie the div with class 'datepicker'\n                     */\n                    onAfterHide:     function () {\n                    },\n                    /**\n                     * Locale text for day/month names: provide a hash with keys 'daysMin', 'months' and 'monthsShort'. Default english\n                     */\n                    locale:          {\n                        daysMin:     [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\n                        months:      [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n                        monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n                    },\n                    /**\n                     * The combined height from the top/bottom borders.  'false' is the default\n                     * and generally the correct value.\n                     */\n                    extraHeight:     false,\n                    /**\n                     * The combined width from the left/right borders.  'false' is the default\n                     * and generally the correct value.\n                     */\n                    extraWidth:      false,\n                    /**\n                     * Private option, used to determine when a range is selected\n                     */\n                    lastSel:         false\n                },\n\n                /**\n                 * Internal method which renders the calendar cells\n                 *\n                 * @param HTMLDivElement el datepicker container element\n                 */\n                fill = function (el) {\n                    var options = $(el).data('datepicker');\n                    var cal = $(el);\n                    var currentCal = Math.floor(options.calendars / 2), date, data, dow, month, cnt = 0, days, indic, indic2, html, tblCal;\n\n                    cal.find('td>table tbody').remove();\n                    for (var i = 0; i < options.calendars; i++) {\n                        date = new Date(options.current);\n                        date.addMonths(-currentCal + i);\n                        tblCal = cal.find('table').eq(i + 1);\n\n                        if (i == 0) tblCal.addClass('datepickerFirstView');\n                        if (i == options.calendars - 1) tblCal.addClass('datepickerLastView');\n\n                        if (tblCal.hasClass('datepickerViewDays')) {\n                            dow = date.getMonthName(true) + \", \" + date.getFullYear();\n                        } else if (tblCal.hasClass('datepickerViewMonths')) {\n                            dow = date.getFullYear();\n                        } else if (tblCal.hasClass('datepickerViewYears')) {\n                            dow = (date.getFullYear() - 6) + ' - ' + (date.getFullYear() + 5);\n                        }\n                        tblCal.find('thead tr:first th a:eq(1) span').text(dow);\n                        dow = date.getFullYear() - 6;\n                        data = {\n                            data:      [],\n                            className: 'datepickerYears'\n                        }\n                        for (var j = 0; j < 12; j++) {\n                            data.data.push(dow + j);\n                        }\n                        // datepickerYears template\n                        html = tmpl(tpl.months.join(''), data);\n                        date.setDate(1);\n                        data = {weeks: [], test: 10};\n                        month = date.getMonth();\n                        var dow = (date.getDay() - options.starts) % 7;\n                        date.addDays(-(dow + (dow < 0 ? 7 : 0)));\n                        cnt = 0;\n                        while (cnt < 42) {\n                            indic = parseInt(cnt / 7, 10);\n                            indic2 = cnt % 7;\n                            if (!data.weeks[indic]) {\n                                data.weeks[indic] = {\n                                    days: []\n                                };\n                            }\n                            data.weeks[indic].days[indic2] = {\n                                text:      date.getDate(),\n                                classname: []\n                            };\n                            var today = new Date();\n                            if (today.getDate() == date.getDate() && today.getMonth() == date.getMonth() && today.getYear() == date.getYear()) {\n                                data.weeks[indic].days[indic2].classname.push('datepickerToday');\n                            }\n                            if ($.isArray(options.selectableDates) && options.selectableDates.length == 2) {\n                                if (date < options.selectableDates[0] || date > options.selectableDates[1]) {\n                                    data.weeks[indic].days[indic2].classname.push('datepickerFuture');\n                                    data.weeks[indic].days[indic2].classname.push('datepickerDisabled');\n                                }\n                            } else if (date > today) {\n                                // current month, date in future\n                                data.weeks[indic].days[indic2].classname.push('datepickerFuture');\n                            }\n\n                            if (month != date.getMonth()) {\n                                data.weeks[indic].days[indic2].classname.push('datepickerNotInMonth');\n                                // disable clicking of the 'not in month' cells\n                                data.weeks[indic].days[indic2].classname.push('datepickerDisabled');\n                            }\n                            if (date.getDay() == 0) {\n                                data.weeks[indic].days[indic2].classname.push('datepickerSunday');\n                            }\n                            if (date.getDay() == 6) {\n                                data.weeks[indic].days[indic2].classname.push('datepickerSaturday');\n                            }\n                            var fromUser = options.onRenderCell(el, date);\n                            var val = date.valueOf();\n                            if (options.date && (!$.isArray(options.date) || options.date.length > 0)) {\n                                if (options.mode != 'tworanges') {\n                                    if (fromUser.selected || options.date == val || ($.isArray(options.date) && $.inArray(val, options.date.slice(0, 2)) > -1) || (options.mode == 'range' && val >= options.date[0] && val <= options.date[1])) {\n                                        data.weeks[indic].days[indic2].classname.push('datepickerSelected');\n                                    }\n                                } else {\n                                    if ((val >= options.date[0] && val <= options.date[1]) || (val == options.date[0])) {\n                                        data.weeks[indic].days[indic2].classname.push('datepickerSelected');\n                                    }\n                                    if ((val >= options.date[2] && val <= options.date[3]) || (val == options.date[2])) {\n                                        data.weeks[indic].days[indic2].classname.push('datepickerSelected2');\n                                    }\n                                }\n                            }\n                            if (fromUser.disabled) {\n                                data.weeks[indic].days[indic2].classname.push('datepickerDisabled');\n                            }\n                            if (fromUser.className) {\n                                data.weeks[indic].days[indic2].classname.push(fromUser.className);\n                            }\n                            data.weeks[indic].days[indic2].classname = data.weeks[indic].days[indic2].classname.join(' ');\n                            cnt++;\n                            date.addDays(1);\n                        }\n                        // Fill the datepickerDays template with data\n                        html = tmpl(tpl.days.join(''), data) + html;\n\n                        data = {\n                            data:      options.locale.monthsShort,\n                            className: 'datepickerMonths'\n                        };\n                        // datepickerMonths template\n                        html = tmpl(tpl.months.join(''), data) + html;\n                        tblCal.append(html);\n                    }\n                },\n\n                /**\n                 * Extends the Date object with some useful helper methods\n                 */\n                extendDate = function (locale) {\n                    if (Date.prototype.tempDate) {\n                        return;\n                    }\n                    Date.prototype.tempDate = null;\n                    Date.prototype.months = locale.months;\n                    Date.prototype.monthsShort = locale.monthsShort;\n                    Date.prototype.getMonthName = function (fullName) {\n                        return this[fullName ? 'months' : 'monthsShort'][this.getMonth()];\n                    };\n                    Date.prototype.addDays = function (n) {\n                        this.setDate(this.getDate() + n);\n                        this.tempDate = this.getDate();\n                    };\n                    Date.prototype.addMonths = function (n) {\n                        if (this.tempDate == null) {\n                            this.tempDate = this.getDate();\n                        }\n                        this.setDate(1);\n                        this.setMonth(this.getMonth() + n);\n                        this.setDate(Math.min(this.tempDate, this.getMaxDays()));\n                    };\n                    Date.prototype.addYears = function (n) {\n                        if (this.tempDate == null) {\n                            this.tempDate = this.getDate();\n                        }\n                        this.setDate(1);\n                        this.setFullYear(this.getFullYear() + n);\n                        this.setDate(Math.min(this.tempDate, this.getMaxDays()));\n                    };\n                    Date.prototype.getMaxDays = function () {\n                        var tmpDate = new Date(Date.parse(this)),\n                            d = 28, m;\n                        m = tmpDate.getMonth();\n                        d = 28;\n                        while (tmpDate.getMonth() == m) {\n                            d++;\n                            tmpDate.setDate(d);\n                        }\n                        return d - 1;\n                    };\n                },\n\n                /**\n                 * Internal method which lays out the calendar widget\n                 */\n                layout = function (el) {\n                    var options = $(el).data('datepicker');\n                    var cal = $('#' + options.id);\n                    // if (options.extraHeight === false) {\n                    //     var divs = $(el).find('div');\n                    //     options.extraHeight = divs.get(0).offsetHeight + divs.get(1).offsetHeight;  // heights from top/bottom borders\n                    //     options.extraWidth = divs.get(2).offsetWidth + divs.get(3).offsetWidth;     // widths from left/right borders\n                    // }\n                    var tbl = cal.find('table:first').get(0);\n                    var width = tbl.offsetWidth;\n                    var height = tbl.offsetHeight;\n                    // cal.css({\n                    //     width:  width + options.extraWidth + 'px',\n                    //     height: height + options.extraHeight + 'px'\n                    // }).find('div.datepickerContainer').css({\n                    //     width:  width + 'px',\n                    //     height: height + 'px'\n                    // });\n                },\n\n                /**\n                 * Internal method, bound to the HTML DatePicker Element, onClick.\n                 * This is the function that controls the behavior of the calendar when\n                 * the title, next/previous, or a date cell is clicked on.\n                 */\n                click = function (ev) {\n                    if ($(ev.target).is('span')) {\n                        ev.target = ev.target.parentNode;\n                    }\n                    var el = $(ev.target);\n                    if (el.is('a')) {\n                        ev.target.blur();\n                        if (el.hasClass('datepickerDisabled')) {\n                            return false;\n                        }\n                        var options = $(this).data('datepicker');\n                        var parentEl = el.parent();\n                        var tblEl = parentEl.parent().parent().parent();\n                        var tblIndex = $('table', this).index(tblEl.get(0)) - 1;\n                        var tmp = new Date(options.current);\n                        var tmpStart = new Date(options.current);\n                        var tmpEnd = new Date(options.current);\n                        var changed = false;\n                        var changedRange = false;\n                        var fillIt = false;\n                        var currentCal = Math.floor(options.calendars / 2);\n\n                        if (parentEl.is('th')) {\n                            // clicking the calendar title\n\n                            if (el.hasClass('datepickerMonth')) {\n                                // clicking on the title of a Month Datepicker\n                                tmp.addMonths(tblIndex - currentCal);\n                                tmpStart.addMonths(tblIndex - currentCal);\n                                tmpEnd.addMonths(tblIndex - currentCal);\n\n                                if (options.mode == 'tworanges') {\n                                    var offset = (options.lastSel > 1) ? 2 : 0;\n                                    var nextSel = (options.lastSel > 1) ? 0 : 2;\n                                    // range, select the whole month\n                                    options.date[offset] = (tmp.setHours(0, 0, 0, 0)).valueOf();\n                                    tmp.addDays(tmp.getMaxDays() - 1);\n                                    tmp.setHours(23, 59, 59, 0);\n                                    options.date[offset + 1] = tmp.valueOf();\n                                    fillIt = true;\n                                    changed = true;\n                                    options.lastSel = nextSel;\n                                } else if (options.mode == 'range') {\n                                    // range, select the whole month\n\n                                    // Check if the start date is allowed\n                                    // options.selectableDates[0];\n                                    // options.selectableDates[1];\n                                    var baseDate = options.selectableDates[0];\n                                    var endDate = options.selectableDates[1];\n\n                                    tmpStart.setHours(0, 0, 0, 0);\n                                    tmpStart.setDate(1);\n\n                                    if (options.selectableDates != null) {\n                                        if (tmpStart.getTime() < baseDate.getTime()) {\n                                            tmpStart.setTime(baseDate.getTime());\n                                        }\n                                    }\n                                    options.date[0] = tmpStart.valueOf();\n\n                                    // Check if the end date is allowed\n                                    tmpEnd.setDate(tmpEnd.getMaxDays());\n                                    tmpEnd.setHours(23, 59, 59, 0);\n\n                                    if (options.selectableDates != null) {\n                                        if (tmpEnd.getTime() > endDate.getTime()) {\n                                            tmpEnd.setTime(endDate.getTime());\n                                        }\n                                    }\n                                    options.date[1] = tmpEnd.valueOf();\n\n                                    if (options.selectableDates != null) {\n                                        if ((tmpStart.getTime() > endDate.getTime()) || (tmpEnd.getTime() < baseDate.getTime())) {\n                                            options.date[0] = 0;\n                                            options.date[1] = 0;\n                                        }\n                                    }\n\n                                    fillIt = true;\n                                    changed = true;\n                                    options.lastSel = false;\n                                } else if (options.calendars == 1) {\n                                    // single/multiple mode with a single calendar: swap between daily/monthly/yearly view.\n                                    // Note:  there's no reason a multi-calendar widget can't have this functionality,\n                                    //   however I think it looks really unintuitive.\n                                    if (tblEl.eq(0).hasClass('datepickerViewDays')) {\n                                        tblEl.eq(0).toggleClass('datepickerViewDays datepickerViewMonths');\n                                        el.find('span').text(tmp.getFullYear());\n                                    } else if (tblEl.eq(0).hasClass('datepickerViewMonths')) {\n                                        tblEl.eq(0).toggleClass('datepickerViewMonths datepickerViewYears');\n                                        el.find('span').text((tmp.getFullYear() - 6) + ' - ' + (tmp.getFullYear() + 5));\n                                    } else if (tblEl.eq(0).hasClass('datepickerViewYears')) {\n                                        tblEl.eq(0).toggleClass('datepickerViewYears datepickerViewDays');\n                                        el.find('span').text(tmp.getMonthName(true) + \", \" + tmp.getFullYear());\n                                    }\n                                }\n                            } else if (parentEl.parent().parent().is('thead')) {\n                                // clicked either next/previous arrows\n                                if (tblEl.eq(0).hasClass('datepickerViewDays')) {\n                                    options.current.addMonths(el.hasClass('datepickerGoPrev') ? -1 : 1);\n                                } else if (tblEl.eq(0).hasClass('datepickerViewMonths')) {\n                                    options.current.addYears(el.hasClass('datepickerGoPrev') ? -1 : 1);\n                                } else if (tblEl.eq(0).hasClass('datepickerViewYears')) {\n                                    options.current.addYears(el.hasClass('datepickerGoPrev') ? -12 : 12);\n                                }\n                                fillIt = true;\n                            }\n\n                        } else if (parentEl.is('td') && !parentEl.hasClass('datepickerDisabled')) {\n                            // clicking the calendar grid\n\n                            if (tblEl.eq(0).hasClass('datepickerViewMonths')) {\n                                // clicked a month cell\n                                options.current.setMonth(tblEl.find('tbody.datepickerMonths td').index(parentEl));\n                                options.current.setFullYear(parseInt(tblEl.find('thead th a.datepickerMonth span').text(), 10));\n                                options.current.addMonths(currentCal - tblIndex);\n                                tblEl.eq(0).toggleClass('datepickerViewMonths datepickerViewDays');\n                            } else if (tblEl.eq(0).hasClass('datepickerViewYears')) {\n                                // clicked a year cell\n                                options.current.setFullYear(parseInt(el.text(), 10));\n                                tblEl.eq(0).toggleClass('datepickerViewYears datepickerViewMonths');\n                            } else {\n                                // clicked a day cell\n                                var val = parseInt(el.text(), 10);\n                                tmp.addMonths(tblIndex - currentCal);\n                                if (parentEl.hasClass('datepickerNotInMonth')) {\n                                    tmp.addMonths(val > 15 ? -1 : 1);\n                                }\n                                tmp.setDate(val);\n                                switch (options.mode) {\n                                case 'multiple':\n                                    val = (tmp.setHours(0, 0, 0, 0)).valueOf();\n                                    if ($.inArray(val, options.date) > -1) {\n                                        $.each(options.date, function (nr, dat) {\n                                            if (dat == val) {\n                                                options.date.splice(nr, 1);\n                                                return false;\n                                            }\n                                        });\n                                    } else {\n                                        options.date.push(val);\n                                    }\n                                    break;\n                                case 'range':\n                                case 'tworanges':\n                                    var mapping_other = [1, 0, 3, 2];\n                                    var mapping_first = [0, 0, 2, 2];\n                                    options.lastSel = options.lastSel + 1 - 1; // force to num\n                                    var current = options.lastSel;\n                                    var other = mapping_other[options.lastSel];\n                                    var first = mapping_first[options.lastSel];\n                                    var second = first + 1;\n                                    if (options.weeklyMode) {\n                                        var day = tmp.getDay();\n                                        var diff = (day == 0 ? -6 : 1) - day;\n                                        var monday = new Date(tmp.getTime() + diff * 24 * 3600000); // return closest monday\n                                        var sunday = new Date(monday.getTime() + 6 * 24 * 3600000); // return next sunday\n                                        changedRange = true;\n                                        options.date[first] = (monday.setHours(0, 0, 0, 0)).valueOf();\n                                        options.date[second] = (sunday.setHours(23, 59, 59, 999)).valueOf();\n                                        var modulo = options.mode == 'range' ? 2 : 4;\n                                        options.lastSel = (current + 2) % modulo;\n                                    }\n                                    else if (options.monthlyMode) {\n                                        tmp.setDate(1);\n                                        var year = tmp.getFullYear();\n                                        var month = tmp.getMonth() + 1\n                                        if (month == 12) {\n                                            year++;\n                                            month = 0;\n                                        }\n                                        var firstDayNextMonth = new Date(year, month, 1, 23, 59, 59, 999);\n                                        var lastMonthDate = new Date(firstDayNextMonth.getTime() - 24 * 3600000); // return last day of this month\n                                        changedRange = true;\n                                        options.date[first] = (tmp.setHours(0, 0, 0, 0)).valueOf();\n                                        options.date[second] = lastMonthDate.valueOf();\n                                        var modulo = options.mode == 'range' ? 2 : 4;\n                                        options.lastSel = (current + 2) % modulo;\n                                    }\n                                    else {\n                                        if (current == first) {\n                                            // first click: set to the start of the day\n                                            options.date[first] = (tmp.setHours(0, 0, 0, 0)).valueOf();\n                                        }\n                                        // get the very end of the day clicked\n                                        val = (tmp.setHours(23, 59, 59, 0)).valueOf();\n\n                                        if (val < options.date[other]) {\n                                            // second range click < first\n                                            options.date[1] = options.date[0] + 86399000;  // starting date + 1 day\n                                            options.date[0] = val - 86399000;  // minus 1 day\n\n                                            options.date[second] = options.date[first] + 86399000;  // starting date + 1 day\n                                            options.date[first] = val - 86399000;  // minus 1 day\n                                        } else {\n                                            // initial range click, or final range click >= first\n                                            options.date[second] = val;\n                                        }\n                                        options.lastSel = !options.lastSel;\n                                        changedRange = !options.lastSel;\n                                        var modulo = options.mode == 'range' ? 2 : 4;\n                                        options.lastSel = (current + 1) % modulo;\n                                    }\n                                    break;\n                                default:\n                                    options.date = tmp.valueOf();\n                                    break;\n                                }\n                                changed = true;\n                            }\n                            fillIt = true;\n                        }\n                        if (fillIt) {\n                            fill(this);\n                        }\n                        if (changed) {\n                            options.onChange.apply(this, prepareDate(options));\n                        }\n                        if (changedRange) {\n                            options.onRangeChange.apply(this, prepareDate(options));\n                        }\n                    }\n                    return false;\n                },\n\n                /**\n                 * Internal method, called from the public getDate() method, and when\n                 * invoking the onChange callback function\n                 *\n                 * @param object options with the following attributes: 'mode' which can\n                 *        be one of 'single', 'range', or 'multiple'.  Attribute 'date'\n                 *        which will be a single timestamp when 'mode' is 'single', or\n                 *        an array of timestamps otherwise.  Attribute 'el' which is the\n                 *        HTML element that DatePicker was invoked upon.\n                 * @return array where the first item is either a Date object, or an\n                 *         array of Date objects, depending on the DatePicker mode, and\n                 *         the second item is the HTMLElement that DatePicker was invoked\n                 *         upon.\n                 */\n                prepareDate = function (options) {\n                    var dates = null;\n                    if (options.mode == 'single') {\n                        if (options.date) dates = new Date(options.date);\n                    } else {\n                        dates = new Array();\n                        $(options.date).each(function (i, val) {\n                            dates.push(new Date(val));\n                        });\n                    }\n                    return [dates, options.el];\n                },\n\n                /**\n                 * Internal method, returns an object containing the viewport dimensions\n                 */\n                getViewport = function () {\n                    var m = document.compatMode == 'CSS1Compat';\n                    return {\n                        l: window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),\n                        t: window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),\n                        w: window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),\n                        h: window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)\n                    };\n                },\n\n                /**\n                 * Internal method, returns true if el is a child of parentEl\n                 */\n                isChildOf = function (parentEl, el, container) {\n                    if (parentEl == el) {\n                        return true;\n                    }\n                    if (parentEl.contains) {\n                        return parentEl.contains(el);\n                    }\n                    if (parentEl.compareDocumentPosition) {\n                        return !!(parentEl.compareDocumentPosition(el) & 16);\n                    }\n                    var prEl = el.parentNode;\n                    while (prEl && prEl != container) {\n                        if (prEl == parentEl)\n                            return true;\n                        prEl = prEl.parentNode;\n                    }\n                    return false;\n                },\n\n                /**\n                 * Bound to the HTML DatePicker element when it's not inline, and also\n                 * can be called directly to show the bound datepicker.  A DatePicker\n                 * calendar shown with this method will hide on a mouseclick outside\n                 * of the calendar.\n                 *\n                 * Method is not applicable for inline DatePickers\n                 */\n                show = function (ev) {\n                    var cal = $('#' + $(this).data('datepickerId'));\n                    if (!cal.is(':visible')) {\n                        var calEl = cal.get(0);\n                        var options = cal.data('datepicker');\n\n                        var test = options.onBeforeShow.apply(this, [calEl]);\n                        if (options.onBeforeShow.apply(this, [calEl]) == false) {\n                            return;\n                        }\n\n                        fill(calEl);\n                        var pos = $(this).offset();\n                        var viewPort = getViewport();\n                        var top = pos.top;\n                        var left = pos.left;\n                        var oldDisplay = $.css(calEl, 'display');\n                        cal.css({\n                            visibility: 'hidden',\n                            display:    'block'\n                        });\n                        layout(calEl);\n                        switch (options.position) {\n                        case 'top':\n                            top -= calEl.offsetHeight;\n                            break;\n                        case 'left':\n                            left -= calEl.offsetWidth;\n                            break;\n                        case 'right':\n                            left += this.offsetWidth;\n                            break;\n                        case 'bottom':\n                            top += this.offsetHeight;\n                            break;\n                        }\n                        if (top + calEl.offsetHeight > viewPort.t + viewPort.h) {\n                            top = pos.top - calEl.offsetHeight;\n                        }\n                        if (top < viewPort.t) {\n                            top = pos.top + this.offsetHeight + calEl.offsetHeight;\n                        }\n                        if (left + calEl.offsetWidth > viewPort.l + viewPort.w) {\n                            left = pos.left - calEl.offsetWidth;\n                        }\n                        if (left < viewPort.l) {\n                            left = pos.left + this.offsetWidth\n                        }\n                        cal.css({\n                            visibility: 'visible',\n                            display:    'block',\n                            top:        top + 'px',\n                            left:       left + 'px'\n                        });\n                        options.onAfterShow.apply(this, [cal.get(0)]);\n                        $(document).bind('mousedown', {cal: cal, trigger: this}, hide);  // global listener so clicking outside the calendar will close it\n                    }\n                    return false;\n                },\n\n                /**\n                 * Hide a non-inline DatePicker calendar.\n                 *\n                 * Not applicable for inline DatePickers.\n                 *\n                 * @param ev Event object\n                 */\n                hide = function (ev) {\n                    if (ev.target != ev.data.trigger && !isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {\n                        if (ev.data.cal.data('datepicker').onBeforeHide.apply(this, [ev.data.cal.get(0)]) != false) {\n                            ev.data.cal.hide();\n                            ev.data.cal.data('datepicker').onAfterHide.apply(this, [ev.data.cal.get(0)]);\n                            $(document).unbind('mousedown', hide);  // remove the global listener\n                        }\n                    }\n                },\n\n                /**\n                 * Internal method to normalize the selected date based on the current\n                 * calendar mode.\n                 */\n                normalizeDate = function (mode, date) {\n                    // if range/multi mode, make sure that the current date value is at least an empty array\n                    if (mode != 'single' && !date) date = [];\n\n                    // if we have a selected date and not a null or empty array\n                    if (date && (!$.isArray(date) || date.length > 0)) {\n                        // Create a standardized date depending on the calendar mode\n                        if (mode != 'single') {\n                            if (!$.isArray(date)) {\n                                date = [((new Date(date)).setHours(0, 0, 0, 0)).valueOf()];\n                                if (mode == 'range') {\n                                    // create a range of one day\n                                    date.push(((new Date(date[0])).setHours(23, 59, 59, 0)).valueOf());\n                                }\n                            } else {\n                                for (var i = 0; i < date.length; i++) {\n                                    // Safari does not support pattern yyyy-MM-dd\n                                    if (typeof date[i] === 'string') {\n                                        date[i] = date[i].replace(/-/g, '/');\n                                    }\n\n                                    date[i] = ((new Date(date[i])).setHours(0, 0, 0, 0)).valueOf();\n                                }\n                                if (mode == 'range') {\n                                    // for range mode, create the other end of the range\n                                    if (date.length == 1) date.push(new Date(date[0]));\n                                    date[1] = ((new Date(date[1])).setHours(23, 59, 59, 0)).valueOf();\n                                }\n                            }\n                        } else {\n                            // mode is single, convert date object into a timestamp\n                            date = ((new Date(date)).setHours(0, 0, 0, 0)).valueOf();\n                        }\n                        // at this point date is either a timestamp at hour zero\n                        //  for 'single' mode, an array of timestamps at hour zero for\n                        //  'multiple' mode, or a two-item array with timestamps at hour\n                        //  zero and hour 23:59 for 'range' mode\n                    }\n                    return date;\n                };\n            return {\n                /**\n                 * 'Public' functions\n                 */\n\n                /**\n                 * Called when element.DatePicker() is invoked\n                 *\n                 * Note that 'this' is the HTML element that DatePicker was invoked upon\n                 * @see DatePicker()\n                 */\n                init: function (options) {\n                    options = $.extend({}, defaults, options || {});\n                    extendDate(options.locale);\n                    options.calendars = Math.max(1, parseInt(options.calendars, 10) || 1);\n                    options.mode = /single|multiple|range/.test(options.mode) ? options.mode : 'single';\n\n                    return this.each(function () {\n                        if (!$(this).data('datepicker')) {\n                            options.el = this;\n\n                            options.date = normalizeDate(options.mode, options.date);\n\n                            if (!options.current) {\n                                options.current = new Date();\n                            } else {\n                                options.current = new Date(options.current);\n                            }\n                            options.current.setDate(1);\n                            options.current.setHours(0, 0, 0, 0);\n\n                            var id = 'datepicker_' + parseInt(Math.random() * 1000), cnt;\n                            options.id = id;\n                            $(this).data('datepickerId', options.id);\n                            var cal = $(tpl.wrapper).attr('id', id).bind('click', click).data('datepicker', options);\n                            if (options.className) {\n                                cal.addClass(options.className);\n                            }\n                            var html = '';\n                            for (var i = 0; i < options.calendars; i++) {\n                                cnt = options.starts;\n                                if (i > 0) {\n                                    html += tpl.space;\n                                }\n                                // calendar header template\n                                html += tmpl(tpl.head.join(''), {\n                                    prev: options.prev,\n                                    next: options.next,\n                                    day1: options.locale.daysMin[(cnt++) % 7],\n                                    day2: options.locale.daysMin[(cnt++) % 7],\n                                    day3: options.locale.daysMin[(cnt++) % 7],\n                                    day4: options.locale.daysMin[(cnt++) % 7],\n                                    day5: options.locale.daysMin[(cnt++) % 7],\n                                    day6: options.locale.daysMin[(cnt++) % 7],\n                                    day7: options.locale.daysMin[(cnt++) % 7]\n                                });\n                            }\n                            cal\n                            .find('tr:first').append(html)\n                            .find('table').addClass(views[options.view]);\n                            fill(cal.get(0));\n                            if (options.inline) {\n                                cal.appendTo(this).show().css('position', 'relative');\n                                layout(cal.get(0));\n                            } else {\n                                cal.appendTo(document.body);\n                                $(this).bind(options.showOn, show);\n                            }\n                        }\n                        if (/range/.test(options.mode)) {\n                            cal.addClass('selectableRange');\n                        }\n                    });\n                },\n\n                /**\n                 * Shows the DatePicker, applicable only when the picker is not inline\n                 *\n                 * @return the DatePicker HTML element\n                 * @see DatePickerShow()\n                 */\n                showPicker: function () {\n                    return this.each(function () {\n                        if ($(this).data('datepickerId')) {\n                            var cal = $('#' + $(this).data('datepickerId'));\n                            var options = cal.data('datepicker');\n                            if (!options.inline) {\n                                show.apply(this);\n                            }\n                        }\n                    });\n                },\n\n                /**\n                 * Hides the DatePicker, applicable only when the picker is not inline\n                 *\n                 * @return the DatePicker HTML element\n                 * @see DatePickerHide()\n                 */\n                hidePicker: function () {\n                    return this.each(function () {\n                        if ($(this).data('datepickerId')) {\n                            var cal = $('#' + $(this).data('datepickerId'));\n                            var options = cal.data('datepicker');\n                            if (!options.inline) {\n                                $('#' + $(this).data('datepickerId')).hide();\n                            }\n                        }\n                    });\n                },\n\n                /**\n                 * Sets the DatePicker current date, and optionally shifts the current\n                 * calendar to that date.\n                 *\n                 * @param Date|String|int|Array date The currently selected date(s).\n                 *        This can be: a single date, an array\n                 *        of two dates (sets a range when 'mode' is 'range'), or an array of\n                 *        any number of dates (selects all dates when 'mode' is 'multiple'.\n                 *        The supplied dates can be any one of: Date object, milliseconds\n                 *        (as from date.getTime(), date.valueOf()), or a date string\n                 *        parseable by Date.parse().\n                 * @param boolean shiftTo if true, shifts the visible calendar to the\n                 *        newly set date(s)\n                 *\n                 * @see DatePickerSetDate()\n                 */\n                setDate: function (date, shiftTo) {\n                    return this.each(function () {\n                        if ($(this).data('datepickerId')) {\n                            var cal = $('#' + $(this).data('datepickerId'));\n                            var options = cal.data('datepicker');\n                            options.date = normalizeDate(options.mode, date);\n\n                            if (shiftTo) {\n                                options.current = new Date(options.mode != 'single' ? options.date[0] : options.date);\n                            }\n                            fill(cal.get(0));\n                        }\n                    });\n                },\n\n                /**\n                 * Returns the currently selected date(s) and the datepicker element.\n                 *\n                 * @return array where the first element is the selected date(s)  When calendar mode  is 'single' this\n                 *        is a single date object, or null if no date is selected.  When calendar mode is 'range', this is an array containing\n                 *        a 'from' and 'to' date objects, or the empty array if no date range is selected.  When calendar mode is 'multiple' this\n                 *        is an array of Date objects, or the empty array if no date is selected.\n                 *        The second element is the HTMLElement that DatePicker was invoked upon\n                 *\n                 * @see DatePickerGetDate()\n                 */\n                getDate: function () {\n                    if (this.size() > 0) {\n                        return prepareDate($('#' + $(this).data('datepickerId')).data('datepicker'));\n                    }\n                },\n\n                /**\n                 * Clears the currently selected date(s)\n                 *\n                 * @see DatePickerClear()\n                 */\n                clear: function () {\n                    return this.each(function () {\n                        if ($(this).data('datepickerId')) {\n                            var cal = $('#' + $(this).data('datepickerId'));\n                            var options = cal.data('datepicker');\n                            if (options.mode == 'single') {\n                                options.date = null;\n                            } else {\n                                options.date = [];\n                            }\n                            fill(cal.get(0));\n                        }\n                    });\n                },\n\n                /**\n                 * Only applicable when the DatePicker is inline\n                 *\n                 * @see DatePickerLayout()\n                 */\n                fixLayout: function () {\n                    return this.each(function () {\n                        if ($(this).data('datepickerId')) {\n                            var cal = $('#' + $(this).data('datepickerId'));\n                            var options = cal.data('datepicker');\n                            if (options.inline) {\n                                layout(cal.get(0));\n                            }\n                        }\n                    });\n                },\n\n                /**\n                 * Returns options.lastSel\n                 */\n                getLastSel: function () {\n                    var cal = $('#' + $(this).data('datepickerId'));\n                    var options = cal.data('datepicker');\n\n                    return options.lastSel;\n                },\n\n                /**\n                 * Sets options.lastSel\n                 */\n                setLastSel: function (lastSel) {\n                    var cal = $('#' + $(this).data('datepickerId'));\n                    var options = cal.data('datepicker');\n                    options.lastSel = parseInt(lastSel);\n                },\n\n                /**\n                 * Returns options.mode\n                 */\n                getMode: function () {\n                    var cal = $('#' + $(this).data('datepickerId'));\n                    var options = cal.data('datepicker');\n                    return options.mode;\n                },\n\n                /**\n                 * Sets options.mode\n                 */\n                setMode: function (mode) {\n                    var cal = $('#' + $(this).data('datepickerId'));\n                    var options = cal.data('datepicker');\n                    options.mode = mode;\n                    fill(cal);\n                }\n            };\n        }();  // DatePicker\n\n    // Extend jQuery with the following functions so that they can be called on HTML elements, ie: $('#widgetCalendar').DatePicker();\n    $.fn.extend({\n        DatePicker:           DatePicker.init,\n        DatePickerHide:       DatePicker.hidePicker,\n        DatePickerShow:       DatePicker.showPicker,\n        DatePickerSetDate:    DatePicker.setDate,\n        DatePickerGetDate:    DatePicker.getDate,\n        DatePickerClear:      DatePicker.clear,\n        DatePickerGetLastSel: DatePicker.getLastSel,\n        DatePickerSetLastSel: DatePicker.setLastSel,\n        DatePickerGetMode:    DatePicker.getMode,\n        DatePickerSetMode:    DatePicker.setMode,\n        DatePickerLayout:     DatePicker.fixLayout\n    });\n\n    tmpl = function tmpl(str, data) {\n        // Figure out if we're getting a template, or if we need to\n        // load the template - and be sure to cache the result.\n        var fn = !/\\W/.test(str) ?\n            cache[str] = cache[str] ||\n                tmpl(document.getElementById(str).innerHTML) :\n\n            // Generate a reusable function that will serve as a template\n            // generator (and which will be cached).\n            new Function(\"obj\",\n                \"var p=[],print=function(){p.push.apply(p,arguments);};\" +\n\n                // Introduce the data as local variables using with(){}\n                \"with(obj){p.push('\" +\n\n                // Convert the template into pure JavaScript\n                str\n                .replace(/[\\r\\t\\n]/g, \" \")\n                .split(\"<%\").join(\"\\t\")\n                .replace(/((^|%>)[^\\t]*)'/g, \"$1\\r\")\n                .replace(/\\t=(.*?)%>/g, \"',$1,'\")\n                .split(\"\\t\").join(\"');\")\n                .split(\"%>\").join(\"p.push('\")\n                .split(\"\\r\").join(\"\\\\'\")\n                + \"');}return p.join('');\");\n\n        // Provide some basic currying to the user\n        return data ? fn(data) : fn;\n    };\n\n})(jQuery);\n","Mirasvit_Report/js/lib/daterangepicker/daterangepicker.js":"define([\n    'jquery',\n    'Mirasvit_Report/js/lib/moment.min'\n], function ($, moment) {\n\n    var $currentTarget;\n    var $dropdown;\n\n    // form elements\n    var $datepicker;\n\n    var $daterangePreset;\n\n    var $enableComparison;\n    var $comparisonPreset;\n\n    var defaultOptions = {\n        values: {}\n    };\n\n    var methods = {\n        init: function (options) {\n            return this.each(function () {\n                var $this = $(this);\n                var data = $this.data('DateRangesWidget');\n                $this.data('test', internal);\n\n                if (!data) {\n                    var effectiveOptions = $.extend({}, defaultOptions, options);\n                    $this.data('DateRangesWidget', {\n                        options: effectiveOptions\n                    });\n                }\n\n                internal.createElements($this);\n                internal.updateDateField($this);\n            });\n        }\n    };\n\n    var internal = {\n\n        refreshForm: function () {\n            var lastSel = $datepicker.DatePickerGetLastSel();\n\n            if ($('.comparison-preset', $dropdown).val() != 'custom') {\n                lastSel = lastSel % 2;\n                $datepicker.DatePickerSetLastSel(lastSel);\n            }\n\n            $('.dr', $dropdown).removeClass('active');\n            $('.dr[lastSel=' + lastSel + ']', $dropdown).addClass('active');\n\n            var dates = $datepicker.DatePickerGetDate()[0];\n\n            var newFrom = moment(dates[0]).format('ll');\n            var newTo = moment(dates[1]).format('ll');\n\n            var oldFrom = $('.dr1.from', $dropdown).val();\n            var oldTo = $('.dr1.to', $dropdown).val();\n\n            if (newFrom != oldFrom || newTo != oldTo) {\n                $('.dr1.from', $dropdown).val(newFrom);\n                $('.dr1.to', $dropdown).val(newTo);\n            }\n\n            if (dates[2]) {\n                $('.dr2.from', $dropdown).val(moment(dates[2]).format('ll'));\n            }\n\n            if (dates[3]) {\n                $('.dr2.to', $dropdown).val(moment(dates[3]).format('ll'));\n            }\n        },\n\n        createElements: function ($target) {\n            // modify div to act like a dropdown\n            $target.html(\n                '<div class=\"date-range-field\">' +\n                '<span class=\"main\"></span>' +\n                //'<span class=\"comparison-divider\"> Cmp to: </span>'+\n                '<span class=\"comparison\"></span>' +\n                '<a href=\"#\" class=\"arrow\"></a>' +\n                '</div>'\n            );\n\n            // only one dropdown exists even though multiple widgets may be on the page\n            if (!$dropdown) {\n                $dropdown = $(\n                    '<div id=\"datepicker-dropdown\">' +\n                    '<div class=\"date-ranges-picker\"></div>' +\n                    '<div class=\"date-ranges-form\">' +\n                    '<div class=\"main-daterange\">' +\n                    '<div class=\"ranges\">' +\n                    '<select class=\"daterange-preset admin__control-select\">' +\n                    '</select>' +\n                    '</div>' +\n                    '<input type=\"text\" class=\"dr dr1 from admin__control-text\" lastSel=\"0\" /> - <input type=\"text\" class=\"dr dr1 to admin__control-text\" lastSel=\"1\" />' +\n                    '<input type=\"hidden\" class=\"dr dr1 from_millis\" lastSel=\"2\" /><input type=\"hidden\" class=\"dr dr1 to_millis\" lastSel=\"3\" />' +\n                    '</div>' +\n                    '<div class=\"compare-daterange\">' +\n                    '<div class=\"admin__field admin__field-option\">' +\n                    '<input type=\"checkbox\" checked=\"checked\" id=\"compare\" class=\"enable-comparison admin__control-checkbox\" />' +\n                    '<label class=\"admin__field-label\" for=\"compare\">Compare to:</label>' +\n                    '</div>' +\n                    '<select class=\"comparison-preset admin__control-select\">' +\n                    '<option value=\"custom\">Custom</option>' +\n                    '<option value=\"previousperiod\" selected=\"selected\">Previous period</option>' +\n                    '<option value=\"previousyear\">Previous year</option>' +\n                    '</select>' +\n                    '</div>' +\n                    '<div class=\"comparison-daterange\" style=\"display: none\">' +\n                    '<input type=\"text\" class=\"dr dr2 from admin__control-text\" lastSel=\"2\" /> - <input type=\"text\" class=\"dr dr2 to admin__control-text\" lastSel=\"3\" />' +\n                    '<input type=\"hidden\" class=\"dr dr2 from_millis\" lastSel=\"2\" /><input type=\"hidden\" class=\"dr dr2 to_millis\" lastSel=\"3\" />' +\n                    '</div>' +\n                    '<div class=\"btn-group\">' +\n                    '<button class=\"btn primary\" id=\"button-ok\">Apply</button>' +\n                    '<button class=\"btn secondary\" id=\"button-cancel\">Cancel</button>' +\n                    '</div>' +\n                    '</div>' +\n                    '</div>');\n                //\n                // <div class=\"admin__field admin__field-option\">\n                //         <input name=\"comment[is_customer_notified]\" type=\"checkbox\" class=\"admin__control-checkbox\" id=\"history_notify\" value=\"1\">\n                //         <label class=\"admin__field-label\" for=\"history_notify\">Notify Customer by Email</label>\n                //     </div>\n                $dropdown.appendTo($('body'));\n\n                $datepicker = $('.date-ranges-picker', $dropdown);\n\n                $daterangePreset = $('.daterange-preset', $dropdown);\n\n                $enableComparison = $('.enable-comparison', $dropdown);\n                $comparisonPreset = $('.comparison-preset', $dropdown);\n\n                var options = $target.data('DateRangesWidget').options;\n\n                options = _.extend(options, {\n                    onChange: function (dates, el, options) {\n                        internal.setDaterangePreset('custom');\n                    }\n                });\n                $datepicker.DatePicker(options);\n\n                internal.options = options;\n\n                /**\n                 * Handle change of datePreset\n                 */\n                $daterangePreset.change(function () {\n                    var datePreset = internal.getDaterangePreset();\n                    $('.dr1', $dropdown).prop('disabled', ($daterangePreset.val() == 'custom' ? false : true));\n\n                    internal.recalculateDaterange();\n                });\n\n                /**\n                 * Handle enable/disable comparison.\n                 */\n                $enableComparison.change(function () {\n                    internal.setComparisonEnabled($(this).is(':checked'));\n                });\n\n                /**\n                 * Handle change of comparison preset.\n                 */\n                $comparisonPreset.change(function () {\n                    internal.recalculateComparison();\n                });\n\n                /**\n                 * Handle clicking on date field.\n                 */\n                $('.dr', $dropdown).click(function () {\n                    $datepicker.DatePickerSetLastSel($(this).attr('lastSel'));\n                });\n\n                /**\n                 * Handle clicking on OK button.\n                 */\n                $('#button-ok', $dropdown).click(function () {\n                    internal.retractDropdown($currentTarget);\n                    internal.saveValues($currentTarget);\n                    internal.updateDateField($currentTarget);\n                    return false;\n                });\n\n                /**\n                 * Handle clicking on OK button.\n                 */\n                $('#button-cancel', $dropdown).click(function () {\n                    var $this = $(this);\n                    internal.retractDropdown($currentTarget);\n                    return false;\n                });\n            }\n\n            /**\n             * Handle expand/retract of dropdown.\n             */\n            $target.bind('click', function () {\n                var $this = $(this);\n                if ($this.hasClass('DRWClosed')) {\n                    internal.expandDropdown($this);\n                } else {\n                    internal.retractDropdown($this);\n                }\n                return false;\n            });\n\n            $target.addClass('DRWInitialized');\n            $target.addClass('DRWClosed');\n        },\n\n        recalculateDaterange: function () {\n            var datePreset = internal.getDaterangePreset();\n\n            var dates = $datepicker.DatePickerGetDate()[0];\n\n            var d = datePreset;\n\n            if (d != null) {\n                dates[0] = d[0];\n                dates[1] = d[1];\n            }\n\n            $.each(internal.options.ranges, function (key, value) {\n                if (moment(value[0]).format('ll') == moment(dates[0]).format('ll')\n                    && moment(value[1]).format('ll') == moment(dates[1]).format('ll')) {\n                    $daterangePreset.val(key);\n                }\n            });\n\n            if (!$daterangePreset.val()) {\n                $daterangePreset.val('custom');\n            }\n\n            $datepicker.DatePickerSetDate(dates);\n\n            internal.recalculateComparison();\n        },\n\n        recalculateComparison: function () {\n            var dates = $datepicker.DatePickerGetDate()[0];\n            if (dates.length >= 2) {\n                var comparisonPreset = internal.getComparisonPreset();\n                //console.log(comparisonPreset);\n                switch (comparisonPreset) {\n                case 'previousperiod':\n                    var days = parseInt((dates[1] - dates[0]) / (24 * 3600 * 1000));\n                    dates[2] = new Date(dates[0]).setDate(dates[0].getDate() - (days + 1));\n                    dates[3] = new Date(dates[1]).setDate(dates[1].getDate() - (days + 1));\n                    break;\n                case 'previousyear':\n                    dates[2] = new Date(dates[0]).setFullYear(dates[0].getFullYear(dates[0]) - 1);\n                    dates[3] = new Date(dates[1]).setFullYear(dates[1].getFullYear(dates[1]) - 1);\n                    break;\n                }\n                $datepicker.DatePickerSetDate(dates);\n                //console.log('comp', $this.val());\n                $('.comparison-daterange input.dr', $dropdown).prop('disabled', (comparisonPreset == 'custom' ? false : true));\n                internal.refreshForm();\n            }\n        },\n\n        /**\n         * Loads values from target element's data to controls.\n         */\n        loadValues: function ($target) {\n            var values = $target.data('DateRangesWidget').options.values;\n\n            $('.dr1.from', $dropdown).val(values.dr1from);\n            $('.dr1.from', $dropdown).change();\n\n            $('.dr1.to', $dropdown).val(values.dr1to);\n            $('.dr1.to', $dropdown).change();\n\n            $('.dr2.from', $dropdown).val(values.dr2from);\n            $('.dr2.from', $dropdown).change();\n\n            $('.dr2.to', $dropdown).val(values.dr2to);\n            $('.dr2.to', $dropdown).change();\n\n            $daterangePreset.val(values.daterangePreset);\n            $daterangePreset.change();\n\n            if (values.comparisonEnabled === true || values.comparisonEnabled === 'true') {\n                $enableComparison.prop('checked', true);\n                $enableComparison.change();\n            } else {\n                $enableComparison.removeProp('checked');\n                $enableComparison.change();\n            }\n\n            if (values.comparisonPreset) {\n                $comparisonPreset.val(values.comparisonPreset);\n                $comparisonPreset.change();\n            }\n        },\n\n        /**\n         * Stores values from controls to target element's data.\n         */\n        saveValues: function ($target) {\n            var data = $target.data('DateRangesWidget');\n            var values = data.options.values;\n\n            values.daterangePreset = internal.getDaterangePresetVal();\n            values.dr1from = $('.dr1.from', $dropdown).val();\n            values.dr1to = $('.dr1.to', $dropdown).val();\n            values.dr1from_millis = $('.dr1.from_millis', $dropdown).val();\n            values.dr1to_millis = $('.dr1.to_millis', $dropdown).val();\n\n            values.comparisonEnabled = internal.getComparisonEnabled();\n            values.comparisonPreset = internal.getComparisonPreset();\n            values.dr2from = $('.dr2.from', $dropdown).val();\n            values.dr2to = $('.dr2.to', $dropdown).val();\n\n            values.dr2from_millis = $('.dr2.from_millis', $dropdown).val();\n            values.dr2to_millis = $('.dr2.to_millis', $dropdown).val();\n            $target.data('DateRangesWidget', data);\n\n            if ($target.data().DateRangesWidget.options.apply)\n                $target.data().DateRangesWidget.options.apply(values);\n\n        },\n\n        /**\n         * Updates target div with data from target element's data\n         */\n        updateDateField: function ($target) {\n            var values = $target.data(\"DateRangesWidget\").options.values;\n            if (values.dr1from && values.dr1to) {\n                $('span.main', $target).text(moment(values.dr1from).format('ll')\n                    + ' - '\n                    + moment(values.dr1to).format('ll'));\n            } else if (values.daterangePreset) {\n                var dates = db.datePresets[values.daterangePreset].dates();\n                $('span.main', $target).text(dates[0] + ' - ' + dates[1]);\n            } else {\n                $('span.main', $target).text('N/A');\n            }\n\n            if (values.comparisonEnabled && values.dr2from && values.dr2to) {\n                $('.date-range-field').addClass('comparison-enabled');\n                $('span.comparison', $target).text(moment(values.dr2from).format('ll')\n                    + ' - '\n                    + moment(values.dr2to).format('ll'));\n                $('span.comparison', $target).show();\n                $('span.comparison-divider', $target).show();\n            } else {\n                $('.date-range-field').removeClass('comparison-enabled');\n                $('span.comparison-divider', $target).hide();\n                $('span.comparison', $target).hide();\n            }\n\n            return true;\n        },\n\n        getDaterangePresetVal: function () {\n            return $daterangePreset.val();\n        },\n\n        getDaterangePreset: function () {\n            if (!$daterangePreset.val() || $daterangePreset.val() == 'custom') {\n                return null;\n            }\n\n            return internal.options.ranges[$daterangePreset.val()];\n        },\n\n        setDaterangePreset: function (value) {\n            $daterangePreset.val(value);\n            $daterangePreset.change();\n        },\n\n        setComparisonEnabled: function (enabled) {\n            if (enabled) {\n                $('.comparison-daterange').show();\n                $('.comparison-preset').removeProp('disabled');\n            } else {\n                $('.comparison-daterange').hide();\n                $('.comparison-preset').prop('disabled', true);\n            }\n            $datepicker.DatePickerSetMode(enabled ? 'tworanges' : 'range');\n        },\n\n        getComparisonEnabled: function () {\n            return $enableComparison.prop('checked');\n        },\n\n        getComparisonPreset: function () {\n            return $comparisonPreset.val();\n        },\n\n        populateDateRangePresets: function (options) {\n            var valueBackup = $daterangePreset.val();\n\n            $daterangePreset.html('');\n\n            $.each(options.ranges, function (text, dates) {\n                $daterangePreset.append($(\"<option/>\", {\n                    value: text,\n                    text:  text\n                }));\n            });\n\n            $daterangePreset.append($(\"<option/>\", {\n                value: 'custom',\n                text:  'Custom'\n            }));\n\n            $daterangePreset.val(valueBackup);\n        },\n\n        expandDropdown: function ($target) {\n            var options = $target.data(\"DateRangesWidget\").options;\n            $currentTarget = $target;\n\n            internal.populateDateRangePresets(options);\n\n            internal.loadValues($target);\n\n            // retract all other dropdowns\n            $('.DRWOpened').each(function () {\n                internal.retractDropdown($(this));\n            });\n\n            var leftDistance = $target.offset().left;\n            var rightDistance = $(document).width() - $target.offset().left - $target.width();\n            $dropdown.show();\n            if (rightDistance > leftDistance) {\n                $dropdown.offset({\n                    left: $target.offset().left,\n                    top:  $target.offset().top + $target.height() + 16\n                });\n            } else {\n                // align right edges\n                var fix = parseInt($dropdown.css('padding-left').replace('px', '')) +\n                    parseInt($dropdown.css('padding-right').replace('px', '')) +\n                    parseInt($dropdown.css('border-left-width').replace('px', '')) +\n                    parseInt($dropdown.css('border-right-width').replace('px', ''))\n                $dropdown.offset({\n                    left: $target.offset().left + $target.width() - $dropdown.width() - fix,\n                    top:  $target.offset().top + $target.height() + 16\n                });\n            }\n\n            // switch to up-arrow\n            $('.date-range-field a', $target);\n            $target.addClass('DRWOpened');\n            $target.removeClass('DRWClosed');\n\n            // refresh\n            internal.recalculateDaterange();\n        },\n\n        retractDropdown: function ($target) {\n            //console.log('retract', $target);\n\n            $dropdown.hide();\n            $('.date-range-field', $target).css({borderBottomLeftRadius: 5, borderBottomRightRadius: 5});\n            $target.addClass('DRWClosed');\n            $target.removeClass('DRWOpened');\n        },\n\n        getMonday: function (d) {\n            d = new Date(d);\n            var day = d.getDay();\n            var diff = d.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday\n            return new Date(d.setDate(diff));\n        }\n\n    };\n\n    $.fn.DateRangesWidget = function (method) {\n        if (methods[method]) {\n            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if (typeof method === 'object' || !method) {\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error('Method ' + method + ' does not exist on jQuery.DateRangesWidget');\n        }\n    };\n});\n","Mirasvit_Report/js/lib/ko/bind/daterangepicker.js":"define([\n    'ko',\n    'underscore',\n    'jquery',\n    'Mirasvit_Report/js/lib/moment.min',\n    'Mirasvit_Report/js/lib/daterangepicker/daterange',\n    'Mirasvit_Report/js/lib/daterangepicker/daterangepicker'\n], function (ko, _, $, moment) {\n    'use strict';\n\n    ko.bindingHandlers.daterangepicker = {\n        init: function (el, valueAccessor) {\n            var config = valueAccessor(),\n                observableFrom,\n                observableTo,\n                observableCompareFrom,\n                observableCompareTo,\n                observableComparisonEnabled,\n                options = {};\n\n            observableFrom = config.storageFrom;\n            observableTo = config.storageTo;\n            observableCompareFrom = config.storageCompareFrom;\n            observableCompareTo = config.storageCompareTo;\n            observableComparisonEnabled = config.storageComparisonEnabled;\n\n            _.extend(options, config.options);\n\n            _.extend(options, {\n                mode:      'tworanges',\n                starts:    1,\n                calendars: 3,\n                inline:    true,\n                apply:     function (obj) {\n                    observableFrom(moment(obj.dr1from).format('YYYY-MM-DD'));\n                    observableTo(moment(obj.dr1to).format('YYYY-MM-DD'));\n\n                    observableComparisonEnabled(obj.comparisonEnabled);\n                    if (obj.comparisonEnabled) {\n                        observableCompareFrom(moment(obj.dr2from).format('YYYY-MM-DD'));\n                        observableCompareTo(moment(obj.dr2to).format('YYYY-MM-DD'));\n                    } else {\n                        observableCompareFrom(null);\n                        observableCompareTo(null);\n                    }\n                }\n            });\n\n            $(el).DateRangesWidget(options);\n        },\n\n        /**\n         * Reads target observable from valueAccessor and writes its' value to el.value\n         * @param {HTMLElement} el - Element, that binding is applied to\n         * @param {Function} valueAccessor - Function that returns value, passed to binding\n         */\n        update: function (el, valueAccessor) {\n            var config = valueAccessor(),\n                observable,\n                value;\n\n            observable = typeof config === 'object' ?\n                config.storage :\n                config;\n        }\n    }\n})\n;","Mirasvit_Report/js/email/blocks.js":"define([\n    'jquery',\n    'underscore',\n    'ko',\n    'uiComponent'\n], function ($, _, ko, Component) {\n    'use strict';\n    \n    var Block = function (data) {\n        function guid() {\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000)\n                    .toString(16)\n                    .substring(1);\n            }\n            \n            return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n        }\n        \n        this.data = data;\n        \n        this.identifier = ko.observable();\n        this.timeRange = ko.observable();\n        this.limit = ko.observable(data.limit);\n        \n        this.guid = guid();\n        this.isSubscribed = false;\n        \n        this.subscribe = function (fnc) {\n            if (this.isSubscribed) {\n                return;\n            }\n            \n            this.identifier.subscribe(fnc);\n            this.timeRange.subscribe(fnc);\n            this.limit.subscribe(fnc);\n            this.isSubscribed = true;\n        }.bind(this);\n    };\n    \n    return Component.extend({\n        defaults: {\n            template: 'report/email/blocks',\n            blocks:   [],\n            ranges:   [],\n            reports:  [],\n            \n            links: {\n                email: '${ $.provider }:${ $.dataScope }'\n            }\n        },\n        \n        initialize: function () {\n            var i;\n            \n            this._super();\n            \n            _.bindAll(this, 'handleAdd', 'handleDelete', 'synchronize');\n            \n            if (this.email()) {\n                _.each(this.email().blocks, function (data) {\n                    this.handleAdd(data);\n                }.bind(this));\n            }\n            \n            return this;\n        },\n        \n        initObservable: function () {\n            this._super();\n            \n            this.email = ko.observable();\n            this.blocks = ko.observableArray();\n            \n            this.blocks.subscribe(function (items) {\n                items.forEach(function (item) {\n                    item.subscribe(this.synchronize);\n                }.bind(this));\n                \n                this.synchronize();\n            }.bind(this));\n            \n            return this;\n        },\n        \n        handleAdd: function (data) {\n            if (data === undefined) {\n                data = {};\n            }\n            this.blocks.push(new Block(data));\n        },\n        \n        handleDelete: function ($data) {\n            this.blocks.remove($data);\n        },\n        \n        \n        synchronize: function () {\n            var email = this.email();\n            var blocks = [];\n            \n            _.each(this.blocks(), function (item) {\n                blocks.push({\n                    identifier: item.identifier(),\n                    timeRange:  item.timeRange(),\n                    limit:      item.limit()\n                })\n            });\n            \n            email.blocks = blocks;\n            this.email(email);\n        },\n        \n        reportSelect: function ($data) {\n            var config = {\n                'Magento_Ui/js/core/app': {\n                    'components': {}\n                }\n            };\n            \n            config['Magento_Ui/js/core/app']['components'][$data.guid + 'report'] = {\n                component:     'Magento_Ui/js/form/element/ui-select',\n                template:      'ui/form/field',\n                elementTmpl:   'ui/grid/filters/elements/ui-select',\n                componentType: 'field',\n                formElement:   'select',\n                labelVisible:  false,\n                filterOptions: true,\n                showCheckbox:  false,\n                disableLabel:  true,\n                multiple:      false,\n                options:       this.reports,\n                value:         $data.identifier\n            };\n            \n            setTimeout(function () {\n                $data.identifier($data.data.identifier)\n            }.bind(this), 1000);\n            \n            return config;\n        },\n        \n        rangeSelect: function ($data) {\n            var config = {\n                'Magento_Ui/js/core/app': {\n                    'components': {}\n                }\n            };\n            \n            config['Magento_Ui/js/core/app']['components'][$data.guid + 'range'] = {\n                component:     'Magento_Ui/js/form/element/ui-select',\n                template:      'ui/form/field',\n                elementTmpl:   'ui/grid/filters/elements/ui-select',\n                componentType: 'field',\n                formElement:   'select',\n                labelVisible:  false,\n                filterOptions: true,\n                showCheckbox:  false,\n                disableLabel:  true,\n                multiple:      false,\n                options:       this.ranges,\n                value:         $data.timeRange\n            };\n            \n            setTimeout(function () {\n                $data.timeRange($data.data.timeRange)\n            }.bind(this), 1000);\n            \n            return config;\n        }\n    });\n});\n","Mirasvit_Report/js/grid/provider.js":"define([\n    'underscore',\n    'Magento_Ui/js/grid/provider'\n], function (_, Provider) {\n    'use strict';\n\n    return Provider.extend({\n        reload: function (options) {\n            this.params.ts = Date.now();\n            return this._super(options);\n        }\n    });\n});\n","Mirasvit_Report/js/grid/listing.js":"define([\n    'underscore',\n    'Magento_Ui/js/grid/listing'\n], function (_, Listing) {\n    'use strict';\n    \n    return Listing.extend({\n        defaults: {\n            template: 'report/grid/listing',\n            imports:  {\n                dynamicColumns:  '${ $.provider }:data.dynamicColumns',\n                dimensionColumn: '${ $.provider }:data.dimensionColumn',\n                columns:         '${ $.provider }:data.columns',\n                totals:          '${ $.provider }:data.totals'\n            },\n            \n            listens: {\n                dynamicColumns:  'onChangeDynamicColumns',\n                dimensionColumn: 'onChangeDimensionColumn'\n            }\n        },\n        \n        initObservable: function () {\n            this._super()\n                .track({\n                    totals: []\n                });\n            \n            return this;\n        },\n        \n        updateVisible: function () {\n            this.visibleColumns = [];\n            \n            _.each(this.elems.filter('visible'), function (elem) {\n                if (!elem.isFilterOnly) {\n                    this.visibleColumns.push(elem);\n                }\n            }.bind(this));\n            \n            return this;\n        },\n        \n        onChangeDynamicColumns: function () {\n            _.each(this.elems(), function (item) {\n                if (this.dynamicColumns[item.index] !== undefined) {\n                    item.visible = this.dynamicColumns[item.index].visible;\n                    this.positions[item.index] = this.dynamicColumns[item.index].sort;\n                } else {\n                    // offset all other columns\n                    this.positions[item.index] = 10;\n                }\n            }, this);\n            \n            this.applyPositions(this.positions);\n        },\n        \n        onChangeDimensionColumn: function () {\n            _.each(this.elems(), function (item) {\n                if (this.dimensionColumn === 'mst_reports_postcode|state' && item.index === 'sales_order_address|country') {\n                    item.visible = true;\n                    this.positions[item.index] = 0;\n                } else if (this.dimensionColumn === 'mst_reports_postcode|place' && item.index === 'sales_order_address|country') {\n                    item.visible = true;\n                    this.positions[item.index] = 3;\n                } else if (this.dimensionColumn === 'mst_reports_postcode|place' && item.index === 'mst_reports_postcode|state') {\n                    item.visible = true;\n                    this.positions[item.index] = 2;\n                } else if (this.dimensionColumn === 'mst_reports_postcode|postcode' && item.index === 'sales_order_address|country') {\n                    item.visible = true;\n                    this.positions[item.index] = 4;\n                } else if (this.dimensionColumn === 'mst_reports_postcode|postcode' && item.index === 'mst_reports_postcode|state') {\n                    item.visible = true;\n                    this.positions[item.index] = 3;\n                } else if (this.dimensionColumn === 'mst_reports_postcode|postcode' && item.index === 'mst_reports_postcode|place') {\n                    item.visible = true;\n                    this.positions[item.index] = 2;\n                } else if (item.index === this.dimensionColumn) {\n                    item.visible = true;\n                    this.positions[item.index] = 0;\n                } else {\n                    if (item.isDimension === true) {\n                        item.visible = false;\n                    }\n                    // offset all other columns\n                    this.positions[item.index] = 10;\n                }\n            }, this);\n            \n            this.applyPositions(this.positions);\n        },\n        \n        updatePositions: function () {\n            var positions = {};\n            \n            this.elems.each(function (elem, index) {\n                if (elem.isHidden) { // we do not want override user selection\n                    elem.visible = false;\n                }\n                if (elem.index === 'actions') {\n                    positions[elem.index] = 100000;\n                } else {\n                    positions[elem.index] = index;\n                }\n            });\n            \n            this.set('positions', positions);\n            \n            return this;\n        }\n    });\n});\n","Mirasvit_Report/js/grid/export.js":"define([\n    'jquery',\n    'underscore',\n    'ko',\n    'Magento_Ui/js/grid/export'\n], function (_, utils, $t, Export) {\n    'use strict';\n\n    return Export.extend({\n        defaults: {\n            imports: {\n                params: '${ $.provider }:params'\n            }\n        },\n\n        getParams: function () {\n            var result = this.params;\n\n            result['selected'] = false;\n            \n            return result;\n        }\n    });\n});\n","Mirasvit_Report/js/grid/filters/multiselect.js":"define([\n    'Magento_Ui/js/form/element/ui-select',\n    'underscore'\n], function (Multiselect, _) {\n    'use strict';\n\n    return Multiselect.extend({\n        getPreview: function () {\n            var values = this.value();\n\n            var options = [];\n            _.each(values, function(value) {\n                var option = _.findWhere(this.options(), {value: value});\n                options.push(option.label);\n            }.bind(this));\n\n            var preview = options.join(', ');\n\n            this.preview(preview);\n            return preview;\n        }\n    });\n});\n","Mirasvit_Report/js/grid/filters/filters.js":"define([\n    'Magento_Ui/js/grid/filters/filters',\n    'uiLayout'\n], function (Filters, layout) {\n    'use strict';\n    \n    return Filters.extend({\n        defaults: {\n            templates: {\n                filters: {\n                    base:   {\n                        parent:    '${ $.$data.filters.name }',\n                        name:      '${ $.$data.column.index }',\n                        provider:  '${ $.$data.filters.name }',\n                        dataScope: '${ $.$data.column.index }',\n                        label:     '${ $.$data.column.label }',\n                        imports:   {\n                            visible:      '${ $.$data.column.name }:visible',\n                            isFilterOnly: '${ $.$data.column.name }:isFilterOnly'\n                        }\n                    },\n                    select: {\n                        component:     'Mirasvit_Report/js/grid/filters/multiselect',\n                        template:      'ui/grid/filters/elements/ui-select',\n                        options:       '${ JSON.stringify($.$data.column.options) }',\n                        caption:       ' ',\n                        filterOptions: true\n                    }\n                }\n            }\n        },\n        \n        isFilterVisible: function (filter) {\n            return this._super(filter);// || filter.isFilterOnly;\n        }\n    });\n});\n","Mirasvit_Report/js/grid/controls/columns.js":"// extend for pass visible columns to data provider\n// extends default component for sort columns by name\ndefine([\n    'underscore',\n    'Magento_Ui/js/grid/controls/columns'\n], function (_, Columns) {\n    'use strict';\n    \n    return Columns.extend({\n        defaults: {\n            template: 'report/grid/controls/columns',\n            exports:  {\n                columns: '${ $.provider }:params.columns'\n            }\n        },\n        \n        addColumns: function (columns) {\n            this._super(columns);\n            \n            //this.elems(_.filter(this.elems(), {isFilterOnly: false}));\n            \n            return this;\n        },\n        \n        tables: function () {\n            var tables = {};\n            _.each(this.elems(), function (elem) {\n                var table = elem.table;\n                \n                if (tables[table] === undefined) {\n                    tables[table] = {\n                        label:   table,\n                        columns: []\n                    };\n                }\n                \n                tables[table].columns.push(elem);\n            }.bind(this));\n            \n            \n            return _.values(tables);\n        },\n        \n        isDisabled: function (column) {\n            var disabled = this._super(column);\n            \n            return disabled\n                || column.dataType === 'actions'\n                || column.isDimension;\n        },\n        \n        countVisible: function () {\n            var columns = [];\n            _.each(this.elems.filter('visible'), function (column) {\n                columns.push(column.index);\n            });\n            \n            if (this.get('columns') === undefined || columns.length > this.get('columns').length) {\n                // set and reload\n                this.set('columns', columns);\n            }\n            \n            return this.elems.filter('visible').length;\n        }\n    });\n});\n","Mirasvit_Report/js/grid/columns/html.js":"define([\n    'Magento_Ui/js/grid/columns/select'\n], function (Select) {\n    'use strict';\n    \n    return Select.extend({\n        defaults: {\n            bodyTmpl: 'report/grid/cells/html'\n        },\n        \n        initConfig: function () {\n            this._super();\n            return this;\n        },\n        \n        getLabel: function (record) {\n            var value = record[this.index];\n            \n            if (value) {\n                return value.replace(/\\n/g, \"<br />\");\n            }\n        }\n    });\n});\n","Mirasvit_Report/js/grid/columns/country.js":"define([\n    'Magento_Ui/js/grid/columns/select'\n], function (Select) {\n    'use strict';\n    \n    return Select.extend({\n        defaults: {\n            bodyTmpl: 'report/grid/cells/country'\n        },\n        \n        initConfig: function () {\n            this._super();\n            return this;\n        },\n        \n        getLabel: function (record) {\n            var value = record[this.index + '_orig'];\n            var text = record[this.index];\n            if (value != null) {\n                return '<img src=\"http://flagpedia.net/data/flags/w580/' + value.toLowerCase() + '.png\" style=\"max-width: 2rem;\">' + ' ' + text;\n            } else {\n                return text;\n            }\n        }\n    });\n});\n","Mirasvit_Report/js/grid/columns/column.js":"define([\n    'Magento_Ui/js/grid/columns/column',\n    'uiRegistry'\n], function (Column) {\n    'use strict';\n    \n    return Column.extend({\n        defaults: {\n            bodyTmpl: 'report/grid/cells/column'\n        },\n        \n        getComparisonLabel: function (record) {\n            if (record['c|' + this.index] !== undefined) {\n                return record['c|' + this.index];\n            }\n            \n            return null;\n        },\n        \n        getDiffLabel: function (record) {\n            if (record['c|' + this.index + '_orig'] !== undefined && record[this.index + '_orig'] !== undefined) {\n                var a = Math.abs(record[this.index + '_orig']);\n                var b = Math.abs(record['c|' + this.index + '_orig']);\n                \n                if (a === b) {\n                    return null;\n                }\n                \n                if (a === 0) {\n                    return '\u221e';\n                }\n                \n                return Math.round((a - b) / a * 100) + \"%\";\n            }\n            \n            return null;\n        },\n        \n        getDiffSign: function (record) {\n            if (record['c|' + this.index + '_orig'] !== undefined && record[this.index + '_orig'] !== undefined) {\n                var a = Math.abs(record[this.index + '_orig']);\n                var b = Math.abs(record['c|' + this.index + '_orig']);\n                \n                if (a > b) {\n                    return \"positive\";\n                } else {\n                    return \"negative\";\n                }\n            }\n        }\n    });\n});\n","Mirasvit_Report/js/grid/columns/number.js":"define([\n    'Mirasvit_Report/js/grid/columns/column'\n], function (Column) {\n    'use strict';\n    \n    return Column.extend({\n        defaults: {\n            bodyTmpl: 'report/grid/cells/number',\n            \n            imports: {\n                totals: '${ $.provider }:data.totals'\n            }\n        },\n        \n        getPercent: function (row) {\n            var total = 0;\n            if (this.totals.length) {\n                total = this.totals[0][this.index + '_orig'];\n            }\n\n            if (total === 0 || total === undefined || total === '' || total === null) {\n                return false;\n            }\n\n            var value  = row[this.index + '_orig'];\n            var result = false;\n            \n            if (this.valueType === 'percent') {\n                result = ((value / 100) * 100).toFixed(1);\n            } else if (this.valueType === 'money' || this.valueType === 'number') {\n                result = ((value / total) * 100).toFixed(1);\n            }\n            \n            return result;\n        }\n    });\n});\n","Mirasvit_Report/js/chart/geo.js":"define([\n    './abstract',\n    'jquery',\n    'underscore'\n], function (Abstract, $, _) {\n    return Abstract.extend({\n        isLoaded:  false,\n        chartType: 'geo',\n        \n        map:     null,\n        markers: [],\n        \n        ensureChart: function () {\n            if (this.isLoaded) {\n                this._ensureChart();\n            } else {\n                require([\n                    '//www.gstatic.com/charts/loader.js?nomin',\n                    '//maps.googleapis.com/maps/api/js?key=AIzaSyDOcoIgRmy7_yv_30OuqvZkulTwF2KJMiI&v=3.exp&signed_in=true&key=AIzaSyDOcoIgRmy7_yv_30OuqvZkulTwF2KJMiI'\n                ], function () {\n                    google.charts.load('current', {\n                        'packages':   ['geochart'],\n                        'mapsApiKey': 'AIzaSyBr3pLR_c6dttTc4X1zYhTdduVEiktpRHM'\n                    });\n                    google.charts.setOnLoadCallback(function () {\n                        this.isLoaded = true;\n                    }.bind(this));\n                }.bind(this));\n            }\n        },\n        \n        _ensureChart: function () {\n            if (!document.getElementById('map_div')) {\n                return false;\n            }\n            \n            $('#chart_canvas').remove();\n            \n            \n            if (this.chartType === 'geo') {\n                $('#map_div').hide();\n                $('#geo_div').show();\n            }\n            \n            if (this.chartType === 'map') {\n                $('#geo_div').hide();\n                $('#map_div').show();\n            }\n            \n            if (!this.chart) {\n                this.chart = new google.visualization.GeoChart(document.getElementById('geo_div'));\n            }\n            \n            if (!this.map) {\n                this.map = new google.maps.Map(document.getElementById('map_div'), {\n                    mapTypeId: google.maps.MapTypeId.TERRAIN,\n                    zoom:      3,\n                    center:    new google.maps.LatLng(40, 0)\n                });\n            }\n        },\n        \n        getChartConfig: function () {\n            var dimension = this.params.dimension;\n            if (!dimension) {\n                return {};\n            }\n            \n            var type = dimension.split('|')[1];\n            \n            if (type === 'country') {\n                this.chartType = 'geo';\n                return {}\n            } else if (type === 'state') {\n                this.chartType = 'geo';\n                return {\n                    region:                    this.mostPopularCountry(),\n                    resolution:                'provinces',\n                    enableRegionInteractivity: true,\n                    displayMode:               'regions'\n                };\n            } else if (type === 'place') {\n                this.chartType = 'geo';\n                return {\n                    region:                    this.mostPopularCountry(),\n                    resolution:                'provinces',\n                    enableRegionInteractivity: true,\n                    displayMode:               'markers'\n                };\n            } else if (type === 'postcode') {\n                this.chartType = 'map';\n            }\n            \n            this.ensureChart();\n            \n            return {};\n        },\n        \n        updateData: function () {\n            if (this.chartType === 'geo' && this.chart) {\n                var data = new google.visualization.DataTable();\n                \n                var rows = [];\n                \n                _.each(this.columns, function (column) {\n                    if (column.isDimension) {\n                        data.addColumn('string', column.label);\n                    }\n                    if (column.isVisible) {\n                        data.addColumn('number', column.label);\n                    }\n                }, this);\n                \n                \n                _.each(this.rows, function (row, i) {\n                    var item = [];\n                    var isValid = true;\n\n                    _.each(this.columns, function (column) {\n                        var value = row[column.index + '_orig'];\n\n                        if ((column.isDimension || column.isVisible) && !value) {\n                            isValid = false;\n                        }\n\n                        if (column.isDimension) {\n                            item.push(value);\n                        }\n                        if (column.isVisible) {\n                            value = parseFloat(parseFloat(value).toFixed(2));\n                            item.push(value);\n                        }\n                    }.bind(this));\n\n                    if (isValid) {\n                        rows.push(item);\n                    }\n                }, this);\n                \n                data.addRows(rows);\n                \n                this.chart.draw(data, this.getChartConfig());\n            }\n            \n            if (this.chartType === 'map' && this.map) {\n                _.each(this.markers, function (marker) {\n                    marker.setMap(null);\n                });\n                this.markers = [];\n                \n                var latLngList = [];\n                _.each(this.rows, function (row) {\n                    var pos = {\n                        lat: parseFloat(row['mst_reports_postcode|lat_orig']),\n                        lng: parseFloat(row['mst_reports_postcode|lng_orig'])\n                    };\n                    \n                    if (pos.lat && pos.lng) {\n                        latLngList.push(pos);\n    \n                        var marker = new google.maps.Marker({\n                            position: pos,\n                            map:      this.map,\n                            hint:     '***'\n                        });\n                        this.markers.push(marker);\n                    }\n                }, this);\n                this.getChartConfig();\n                \n                // center and zoom map based on markers\n                var bounds = new google.maps.LatLngBounds();\n                for (var i = 0, LtLgLen = latLngList.length; i < LtLgLen; i++) {\n                    bounds.extend(latLngList[i]);\n                }\n                this.map.fitBounds(bounds);\n            }\n        },\n        \n        mostPopularCountry: function () {\n            var countries = {};\n            _.each(this.rows, function (row) {\n                var country = _.find(row, function (value, column) {\n                    if (column.split('|')[1] === 'country_orig') {\n                        return value;\n                    }\n                });\n                countries[country] = countries[country] ? countries[country] + 1 : 1;\n            });\n            \n            return Object.keys(countries).reduce(function (a, b) {\n                return countries[a] > countries[b] ? a : b\n            });\n        }\n    });\n});","Mirasvit_Report/js/chart/abstract.js":"define([\n    'uiClass',\n    'jquery',\n    'underscore'\n], function (Class, $, _) {\n    return Class.extend({\n        wrapSelector: '.report__chart-wrap',\n        \n        chart: null,\n        \n        rows:    [],\n        columns: [],\n        \n        scaleTypes: ['money', 'number', 'percent'],\n        \n        ensureChart: function () {\n            if (!document.getElementById('chart_canvas')) {\n                return false;\n            }\n            \n            if (!this.getLabels().length) {\n                $(this.wrapSelector).hide();\n                return false;\n            } else {\n                $(this.wrapSelector).show();\n            }\n            \n            if (this.chart) {\n                return true;\n            }\n            \n            var context = document.getElementById('chart_canvas').getContext('2d');\n            \n            this.chart = new Chart(context, this.getChartConfig());\n        },\n        \n        getChartConfig: function () {\n        \n        },\n        \n        setRows: function (rows) {\n            this.rows = rows;\n            \n            this.ensureChart();\n            this.updateData();\n        },\n        \n        setParams: function (params) {\n            this.params = params;\n        },\n        \n        setColumns: function (columns) {\n            this.columns = columns;\n            \n            this.ensureChart();\n            this.updateData();\n        },\n        \n        getLabels: function () {\n            var labels = [];\n            \n            _.each(this.rows, function (obj) {\n                _.each(_.where(this.columns, {isDimension: true}), function (column) {\n                    labels.push(this.getCellValue(column, obj) + \"\");\n                }, this);\n            }, this);\n            \n            return labels;\n        },\n        \n        getCellValue: function (column, row, prefix) {\n            var index = column.index;\n            \n            if (prefix !== undefined) {\n                index = prefix + index;\n            }\n            \n            var value = row[index];\n            \n            var type = column.type;\n            \n            if (_.indexOf(this.scaleTypes, type) !== -1) {\n                value = row[index + '_orig'];\n                value = parseFloat(parseFloat(value).toFixed(2));\n            } else if (type === 'date') {\n                value = new Date(Date.parse(value));\n            } else if (type === 'country') {\n                value = value + '';\n            } else {\n                value = column.model.getLabel(row);\n            }\n            \n            return value;\n        },\n        \n        destroy: function () {\n            if (this.chart) {\n                this.chart.destroy();\n            }\n        }\n    });\n});","Mirasvit_Report/js/chart/pie.js":"define([\n    './abstract',\n    'jquery',\n    'underscore'\n], function (Abstract, $, _) {\n    return Abstract.extend({\n        \n        getChartConfig: function () {\n            return {\n                type:    'doughnut',\n                options: {\n                    title:               {\n                        display: false\n                    },\n                    legend:              {\n                        display: false\n                    },\n                    responsive:          true,\n                    maintainAspectRatio: false\n                }\n            };\n        },\n        \n        updateData: function () {\n            if (!this.chart) {\n                return;\n            }\n            \n            var data = {\n                labels:   this.getLabels(),\n                datasets: this.getDataSets()\n            };\n            \n            if (this.chart.data !== data) {\n                this.chart.data = data;\n                this.chart.update(0, true);\n            }\n        },\n        \n        \n        getDataSets: function () {\n            var sets = [];\n            \n            _.each(this.columns, function (column) {\n                if (column.isInternal) {\n                    return;\n                }\n                \n                var set = {\n                    label:           column.label,\n                    stack:           column.index,\n                    backgroundColor: [],\n                    borderColor:     [],\n                    borderWidth:     1,\n                    data:            [],\n                    hidden:          !column.isVisible\n                };\n                \n                _.each(this.rows, function (row, i) {\n                    var value = this.getCellValue(column, row);\n                    set.data.push(value);\n                    set.backgroundColor.push(this.getColor(i));\n                }, this);\n                \n                sets.push(set);\n            }, this);\n            \n            return sets;\n        },\n        \n        getColor: function (idx) {\n            var colors = [\n                '#97CC64',\n                '#FF5A3E',\n                '#77B6E7',\n                '#FFD963',\n                '#A9B9B8',\n                '#DC9D6B',\n                '#8549ba',\n                '#00a950',\n                '#166a8f',\n                '#acc236',\n                '#537bc4',\n                '#f53794',\n                '#f67019',\n                '#4dc9f6'\n            ];\n            \n            while (idx >= colors.length && colors.length > 0) {\n                idx = idx - colors.length;\n            }\n            \n            return colors[idx];\n        }\n    });\n});","Mirasvit_Report/js/chart/line.js":"define([\n    './column'\n], function (Column) {\n    return Column.extend({\n        opacity:       .5,\n        borderOpacity: 1,\n        \n        getChartConfig: function () {\n            var config = this._super();\n            config.type = 'line';\n            \n            return config;\n        }\n    });\n});","Mirasvit_Report/js/chart/column.js":"define([\n    './abstract',\n    'jquery',\n    'underscore'\n], function (Abstract, $, _) {\n    return Abstract.extend({\n        opacity:       .9,\n        borderOpacity: 1,\n        \n        getChartConfig: function () {\n            return {\n                type:    'bar',\n                options: {\n                    title:               {\n                        display: false\n                    },\n                    legend:              {\n                        display:  true,\n                        position: 'right',\n                        onClick:  function (e, legendItem) {\n                            var column = _.find(this.columns, {label: legendItem.text});\n                            \n                            if (!column.isVisible) {\n                                column.isVisible = true\n                            } else {\n                                if (!column.chartType) {\n                                    column.chartType = 'line';\n                                } else if (column.chartType === 'line') {\n                                    column.isVisible = false;\n                                    column.chartType = null;\n                                }\n                            }\n                            \n                            var index = legendItem.datasetIndex;\n                            var meta = this.chart.getDatasetMeta(index);\n                            meta.hidden = !column.isVisible;\n                            \n                            this.updateData();\n                        }.bind(this)\n                    },\n                    responsive:          true,\n                    maintainAspectRatio: false,\n                    scales:              this.getScales(),\n                    tooltips:            {\n                        mode:      'index',\n                        intersect: true\n                    }\n                }\n            };\n        },\n        \n        updateData: function () {\n            if (!this.chart) {\n                return;\n            }\n            \n            var chart = this.chart;\n            \n            var data = {\n                labels:   this.getLabels(),\n                datasets: this.getDataSets()\n            };\n            \n            if (this.chart.data !== data) {\n                this.chart.data = data;\n                this.chart.update(0, true);\n                \n                // dashed rectangle for comparison\n                _.each(this.chart.data.datasets, function (set) {\n                    if (set.xAxisID) {\n                        if (set._meta[0]) {\n                            _.each(set._meta[0].data, function (rectangle, index) {\n                                rectangle.draw = function () {\n                                    chart.chart.ctx.setLineDash([1, 1]);\n                                    Chart.elements.Rectangle.prototype.draw.apply(this, arguments);\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n            \n            this.updateScales();\n        },\n        \n        updateScales: function () {\n            _.each(this.scaleTypes, function (type) {\n                var scale = _.find(this.chart.options.scales.yAxes, {id: 'scale-' + type});\n                \n                scale.display = _.findIndex(this.columns, {\n                    type:      type,\n                    isVisible: true\n                }) >= 0;\n            }.bind(this));\n            \n            this.chart.update(0, true);\n        },\n        \n        getDataSets: function () {\n            var sets = [];\n            \n            _.each(this.columns, function (column) {\n                if (column.isInternal || _.indexOf(this.scaleTypes, column.type) === -1) {\n                    return;\n                }\n                \n                var set = {\n                    type:            column.chartType === 'line' ? 'line' : 'bar',\n                    label:           column.label,\n                    stack:           column.index,\n                    backgroundColor: Chart.helpers.color(column.color).alpha(this.opacity).rgbString(),\n                    borderColor:     Chart.helpers.color(column.color).alpha(this.borderOpacity).rgbString(),\n                    borderWidth:     1,\n                    data:            [],\n                    hidden:          !column.isVisible,\n                    yAxisID:         'scale-' + column.type\n                };\n                if (set.type === 'line') {\n                    set.fill = false;\n                    set.borderDash = [5, 5];\n                    set.borderWidth = 2;\n                }\n                \n                var comparisonSet = {\n                    label:           false,\n                    stack:           column.index + '_c',\n                    backgroundColor: Chart.helpers.color(column.color).alpha(.3).rgbString(),\n                    borderColor:     Chart.helpers.color(column.color).alpha(1).rgbString(),\n                    borderWidth:     1,\n                    data:            [],\n                    hidden:          !column.isVisible,\n                    yAxisID:         'scale-' + column.type,\n                    xAxisID:         'x-axis-c'\n                };\n                \n                _.each(this.rows, function (row) {\n                    var value = this.getCellValue(column, row);\n                    set.data.push(value);\n                    \n                    if (this.getCellValue(column, row, 'c|')) {\n                        comparisonSet.data.push(this.getCellValue(column, row, 'c|'));\n                    }\n                }, this);\n                \n                sets.push(set);\n                \n                if (comparisonSet.data.length) {\n                    sets.push(comparisonSet);\n                }\n            }, this);\n            \n            return sets;\n        },\n        \n        getScales: function () {\n            var scales = {\n                xAxes: [\n                    {\n                        display:   true,\n                        id:        'x-axis',\n                        stacked:   true,\n                        gridLines: {\n                            drawOnChartArea: false\n                        }\n                    },\n                    {\n                        display:            false,\n                        stacked:            true,\n                        id:                 \"x-axis-c\",\n                        inside:             true,\n                        type:               'category',\n                        position:           'left',\n                        categoryPercentage: 0.8,\n                        barPercentage:      0.9,\n                        gridLines:          {\n                            offsetGridLines: true\n                        }\n                    }\n                ],\n                yAxes: []\n            };\n            \n            _.each(this.scaleTypes, function (type) {\n                scales.yAxes.push({\n                    display:  true,\n                    id:       'scale-' + type,\n                    position: type === 'money' ? 'left' : 'right',\n                    ticks:    {\n                        beginAtZero: true\n                    }\n                });\n            });\n            \n            return scales;\n        }\n    });\n});","Mirasvit_Report/js/settings/columns.js":"define([\n    'uiElement',\n    'ko',\n    'underscore',\n    'mage/translate'\n], function (Element, ko, _, $t) {\n    'use strict';\n\n    return Element.extend({\n        defaults: {\n            template: 'report/settings/columns',\n            searchColumn: '',\n            columns: []\n        },\n\n        initObservable: function () {\n            this.searchColumn = ko.observable('');\n\n            return this._super();\n        },\n\n        resetSearch: function () {\n            this.searchColumn('');\n        },\n\n        findColumns: function () {\n            var columns = [];\n\n            if (this.searchColumn()) {\n                columns = _.filter(this.columns, function (column) {\n                    if (column.label.toLowerCase().indexOf(this.searchColumn().toLowerCase()) !== -1) {\n                        return column;\n                    }\n                }.bind(this));\n            } else {\n                columns = this.columns;\n            }\n\n            return columns;\n        },\n\n        toggle: function (col, e) {\n            var status = e.currentTarget.querySelector('input[type=\"checkbox\"]');\n            if (!status.disabled) {\n                status.checked = !status.checked;\n\n                if (status.checked) {\n                    e.currentTarget.classList.add('active');\n                } else {\n                    e.currentTarget.classList.remove('active');\n                }\n            }\n        }\n    });\n});\n","Mirasvit_Report/js/toolbar/dimension.js":"define([\n    'underscore',\n    'ko',\n    'uiElement'\n], function (_, ko, Element) {\n    'use strict';\n\n    return Element.extend({\n        defaults: {\n            template: 'reports/toolbar/dimension',\n\n            exports: {\n                groupBy: '${ $.provider }:params.groupBy'\n            },\n\n            listens: {}\n        },\n\n        initialize: function () {\n            this._super();\n\n            this.observe('current');\n\n            _.bindAll(this, 'onChange');\n\n            return this;\n        },\n\n        onChange: function (item) {\n            this.set('groupBy', item.value);\n            this.set('current', item.label);\n        }\n    });\n});\n","Mirasvit_Report/js/toolbar/menu.js":"define([\n    'jquery',\n    'underscore',\n    'ko',\n    'uiElement'\n], function ($, _, ko, Element) {\n    'use strict';\n\n    return Element.extend({\n        defaults: {\n            template: 'reports/toolbar/menu',\n            collapsible: true,\n            opened: false\n        },\n\n        initialize: function () {\n            this._super();\n\n            return this;\n        }\n    });\n});\n","Mirasvit_Report/js/toolbar/filter/date.js":"define([\n    'underscore',\n    'ko',\n    'uiElement',\n    'Mirasvit_Report/js/lib/ko/bind/daterangepicker'\n], function (_, ko, Element) {\n    'use strict';\n    \n    return Element.extend({\n        defaults: {\n            template: 'Mirasvit_Report/toolbar/filter/date',\n            \n            exports: {\n                from:              '${ $.provider }:params.filters[${ $.column }].from',\n                to:                '${ $.provider }:params.filters[${ $.column }].to',\n                compareFrom:       '${ $.provider }:params.filters[${ $.column }].compareFrom',\n                compareTo:         '${ $.provider }:params.filters[${ $.column }].compareTo',\n                comparisonEnabled: '${ $.provider }:params.filters[${ $.column }].comparisonEnabled'\n            },\n            \n            listens: {}\n        },\n        \n        initialize: function () {\n            this._super();\n            \n            return this;\n        },\n        \n        initObservable: function () {\n            this._super();\n            \n            this.from = ko.observable(this.value.from);\n            this.to = ko.observable(this.value.to);\n            this.compareFrom = ko.observable(this.value.compareFrom);\n            this.compareTo = ko.observable(this.value.compareTo);\n            this.comparisonEnabled = ko.observable(this.value.comparisonEnabled);\n            \n            return this;\n        }\n    });\n});\n","Mirasvit_Report/js/toolbar/filter/select.js":"define([\n    'underscore',\n    'ko',\n    'Magento_Ui/js/form/element/ui-select'\n], function (_, ko, UiSelect) {\n    'use strict';\n    \n    return UiSelect.extend({\n        defaults: {\n            template: 'ui/grid/filters/elements/ui-select',\n\n            exports: {\n                values: '${ $.provider }:params.filters[${ $.column }]'\n            },\n            \n            listens: {}\n        },\n\n        initObservable: function () {\n            this._super();\n\n            this.values = ko.observable();\n\n            return this;\n        },\n\n        onUpdate: function() {\n            this._super();\n\n            this.values(this.value());\n        }\n    });\n});\n","Mirasvit_Report/js/toolbar/filter/store.js":"define([\n    'underscore',\n    'ko',\n    'uiElement'\n], function (_, ko, Element) {\n    'use strict';\n\n    return Element.extend({\n        defaults: {\n            template: 'report/toolbar/filter/store',\n\n            exports: {\n                storeIds: '${ $.provider }:params.filters[${ $.column }].value'\n            },\n\n            listens: {}\n        },\n\n        initialize: function () {\n            this._super();\n\n            _.bindAll(this, 'onChangeStore');\n\n            return this;\n        },\n\n        initObservable: function () {\n            this._super();\n\n            this.storeIds = ko.observable();\n            this.current = ko.observable(this.current);\n\n            return this;\n        },\n\n        onChangeStore: function (store) {\n            this.storeIds(store.storeIds.split(','));\n            this.current(store.label);\n        }\n    });\n});\n","Mirasvit_Report/js/toolbar/filter/str.js":"define([\n    'underscore',\n    'ko',\n    'Magento_Ui/js/form/element/abstract'\n], function (_, ko, Element) {\n    'use strict';\n    \n    return Element.extend({\n        defaults: {\n            template: 'report/toolbar/filter/field',\n\n            links: {\n                value: '${ $.provider }:params.filters[${ $.column }]'\n            },\n            \n            listens: {}\n        }\n    });\n});\n"}
}});
